   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	ds18b20_reset
  12               	ds18b20_reset:
  13               	.LFB7:
  14               		.file 1 "ds18b20.c"
   1:ds18b20.c     **** /*
   2:ds18b20.c     **** ds18b20 lib 0x01
   3:ds18b20.c     **** 
   4:ds18b20.c     **** copyright (c) Davide Gironi, 2012
   5:ds18b20.c     **** 
   6:ds18b20.c     **** Released under GPLv3.
   7:ds18b20.c     **** Please refer to LICENSE file for licensing information.
   8:ds18b20.c     **** */
   9:ds18b20.c     **** 
  10:ds18b20.c     **** #include <avr/io.h>
  11:ds18b20.c     **** #include <util/delay.h>
  12:ds18b20.c     **** 
  13:ds18b20.c     **** #include "ds18b20.h"
  14:ds18b20.c     **** 
  15:ds18b20.c     **** /*
  16:ds18b20.c     ****  * ds18b20 init
  17:ds18b20.c     ****  */
  18:ds18b20.c     **** uint8_t ds18b20_reset(void) {
  15               		.loc 1 18 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  19:ds18b20.c     **** 	uint8_t i;
  20:ds18b20.c     **** 
  21:ds18b20.c     **** 	//low for 480us
  22:ds18b20.c     **** 	DS18B20_PORT &= ~ (1<<DS18B20_DQ); //low
  21               		.loc 1 22 0
  22 0000 4598      		cbi 0x8,5
  23:ds18b20.c     **** 	DS18B20_DDR |= (1<<DS18B20_DQ); //output
  23               		.loc 1 23 0
  24 0002 3D9A      		sbi 0x7,5
  25               	.LVL0:
  26               	.LBB175:
  27               	.LBB176:
  28               	.LBB177:
  29               	.LBB178:
  30               	.LBB179:
  31               	.LBB180:
  32               		.file 2 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h"
   1:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
   5:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
   8:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  11:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****      distribution.
  15:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  16:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  20:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  32:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h 2143 2010-06-08 21:19:51Z joerg_wunsch $ */
  33:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  34:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  37:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  39:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  40:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  41:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  42:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** #endif
  43:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  44:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** /** \file */
  45:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     \code
  47:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  48:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     \endcode
  49:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  50:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  51:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  57:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  58:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  61:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  62:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     to the overall delay time.
  64:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  65:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  67:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** */
  68:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  69:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  71:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     register.
  76:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  77:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     can be achieved.
  79:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** */
  80:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** void
  81:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** {
  83:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 	);
  89:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** }
  90:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  91:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  93:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     counter register pair.
  98:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  99:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****  */
 102:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** void
 103:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** {
 105:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  33               		.loc 2 105 0
  34 0004 8EEA      		ldi r24,lo8(-82)
  35 0006 97E0      		ldi r25,lo8(7)
  36               	/* #APP */
  37               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
  38 0008 0197      		1: sbiw r24,1
  39 000a 01F4      		brne 1b
  40               	 ;  0 "" 2
  41               	.LVL1:
  42               	/* #NOAPP */
  43               	.LBE180:
  44               	.LBE179:
  45               	.LBE178:
  46               	.LBE177:
  47               	.LBE176:
  48               	.LBE175:
  24:ds18b20.c     **** 	_delay_us(480);
  25:ds18b20.c     **** 
  26:ds18b20.c     **** 	//release line and wait for 60uS
  27:ds18b20.c     **** 	DS18B20_DDR &= ~(1<<DS18B20_DQ); //input
  49               		.loc 1 27 0
  50 000c 3D98      		cbi 0x7,5
  51               	.LVL2:
  52               	.LBB181:
  53               	.LBB182:
  54               	.LBB183:
  55               	.LBB184:
  56               	.LBB185:
  57               	.LBB186:
  58               		.loc 2 105 0
  59 000e 85EF      		ldi r24,lo8(-11)
  60 0010 90E0      		ldi r25,0
  61               	/* #APP */
  62               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
  63 0012 0197      		1: sbiw r24,1
  64 0014 01F4      		brne 1b
  65               	 ;  0 "" 2
  66               	.LVL3:
  67               	/* #NOAPP */
  68               	.LBE186:
  69               	.LBE185:
  70               	.LBE184:
  71               	.LBE183:
  72               	.LBE182:
  73               	.LBE181:
  28:ds18b20.c     **** 	_delay_us(60);
  29:ds18b20.c     **** 
  30:ds18b20.c     **** 	//get value and wait 420us
  31:ds18b20.c     **** 	i = (DS18B20_PIN & (1<<DS18B20_DQ));
  74               		.loc 1 31 0
  75 0016 86B1      		in r24,0x6
  76               	.LVL4:
  77               	.LBB187:
  78               	.LBB188:
  79               	.LBB189:
  80               	.LBB190:
  81               	.LBB191:
  82               	.LBB192:
  83               		.loc 2 105 0
  84 0018 E8EB      		ldi r30,lo8(-72)
  85 001a F6E0      		ldi r31,lo8(6)
  86               	/* #APP */
  87               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
  88 001c 3197      		1: sbiw r30,1
  89 001e 01F4      		brne 1b
  90               	 ;  0 "" 2
  91               	.LVL5:
  92               	/* #NOAPP */
  93               	.LBE192:
  94               	.LBE191:
  95               	.LBE190:
  96               	.LBE189:
  97               	.LBE188:
  98               	.LBE187:
  32:ds18b20.c     **** 	_delay_us(420);
  33:ds18b20.c     **** 
  34:ds18b20.c     **** 	//return the read value, 0=ok, 1=error
  35:ds18b20.c     **** 	return i;
  36:ds18b20.c     **** }
  99               		.loc 1 36 0
 100 0020 8072      		andi r24,lo8(32)
 101               	.LVL6:
 102 0022 0895      		ret
 103               		.cfi_endproc
 104               	.LFE7:
 106               	.global	ds18b20_writebit
 108               	ds18b20_writebit:
 109               	.LFB8:
  37:ds18b20.c     **** 
  38:ds18b20.c     **** /*
  39:ds18b20.c     ****  * write one bit
  40:ds18b20.c     ****  */
  41:ds18b20.c     **** void ds18b20_writebit(uint8_t bit){
 110               		.loc 1 41 0
 111               		.cfi_startproc
 112               	.LVL7:
 113               	/* prologue: function */
 114               	/* frame size = 0 */
 115               	/* stack size = 0 */
 116               	.L__stack_usage = 0
  42:ds18b20.c     **** 	//low for 1uS
  43:ds18b20.c     **** 	DS18B20_PORT &= ~ (1<<DS18B20_DQ); //low
 117               		.loc 1 43 0
 118 0024 4598      		cbi 0x8,5
  44:ds18b20.c     **** 	DS18B20_DDR |= (1<<DS18B20_DQ); //output
 119               		.loc 1 44 0
 120 0026 3D9A      		sbi 0x7,5
 121               	.LVL8:
 122               	.LBB193:
 123               	.LBB194:
 124               	.LBB195:
 125               	.LBB196:
  83:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 126               		.loc 2 83 0
 127 0028 95E0      		ldi r25,lo8(5)
 128               	/* #APP */
 129               	 ;  83 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 130 002a 9A95      		1: dec r25
 131 002c 01F4      		brne 1b
 132               	 ;  0 "" 2
 133               	.LVL9:
 134               	/* #NOAPP */
 135               	.LBE196:
 136               	.LBE195:
 137               	.LBE194:
 138               	.LBE193:
  45:ds18b20.c     **** 	_delay_us(1);
  46:ds18b20.c     **** 
  47:ds18b20.c     **** 	//if we want to write 1, release the line (if not will keep low)
  48:ds18b20.c     **** 	if(bit)
 139               		.loc 1 48 0
 140 002e 8111      		cpse r24,__zero_reg__
  49:ds18b20.c     **** 		DS18B20_DDR &= ~(1<<DS18B20_DQ); //input
 141               		.loc 1 49 0
 142 0030 3D98      		cbi 0x7,5
 143               	.L3:
 144               	.LVL10:
 145               	.LBB197:
 146               	.LBB198:
 147               	.LBB199:
 148               	.LBB200:
 149               	.LBB201:
 150               	.LBB202:
 151               		.loc 2 105 0
 152 0032 85EF      		ldi r24,lo8(-11)
 153 0034 90E0      		ldi r25,0
 154               	.LVL11:
 155               	/* #APP */
 156               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 157 0036 0197      		1: sbiw r24,1
 158 0038 01F4      		brne 1b
 159               	 ;  0 "" 2
 160               	.LVL12:
 161               	/* #NOAPP */
 162               	.LBE202:
 163               	.LBE201:
 164               	.LBE200:
 165               	.LBE199:
 166               	.LBE198:
 167               	.LBE197:
  50:ds18b20.c     **** 
  51:ds18b20.c     **** 	//wait 60uS and release the line
  52:ds18b20.c     **** 	_delay_us(60);
  53:ds18b20.c     **** 	DS18B20_DDR &= ~(1<<DS18B20_DQ); //input
 168               		.loc 1 53 0
 169 003a 3D98      		cbi 0x7,5
 170 003c 0895      		ret
 171               		.cfi_endproc
 172               	.LFE8:
 174               	.global	ds18b20_readbit
 176               	ds18b20_readbit:
 177               	.LFB9:
  54:ds18b20.c     **** }
  55:ds18b20.c     **** 
  56:ds18b20.c     **** /*
  57:ds18b20.c     ****  * read one bit
  58:ds18b20.c     ****  */
  59:ds18b20.c     **** uint8_t ds18b20_readbit(void){
 178               		.loc 1 59 0
 179               		.cfi_startproc
 180               	/* prologue: function */
 181               	/* frame size = 0 */
 182               	/* stack size = 0 */
 183               	.L__stack_usage = 0
 184               	.LVL13:
  60:ds18b20.c     **** 	uint8_t bit=0;
  61:ds18b20.c     **** 
  62:ds18b20.c     **** 	//low for 1uS
  63:ds18b20.c     **** 	DS18B20_PORT &= ~ (1<<DS18B20_DQ); //low
 185               		.loc 1 63 0
 186 003e 4598      		cbi 0x8,5
  64:ds18b20.c     **** 	DS18B20_DDR |= (1<<DS18B20_DQ); //output
 187               		.loc 1 64 0
 188 0040 3D9A      		sbi 0x7,5
 189               	.LVL14:
 190               	.LBB203:
 191               	.LBB204:
 192               	.LBB205:
 193               	.LBB206:
  83:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 194               		.loc 2 83 0
 195 0042 85E0      		ldi r24,lo8(5)
 196               	/* #APP */
 197               	 ;  83 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 198 0044 8A95      		1: dec r24
 199 0046 01F4      		brne 1b
 200               	 ;  0 "" 2
 201               	.LVL15:
 202               	/* #NOAPP */
 203               	.LBE206:
 204               	.LBE205:
 205               	.LBE204:
 206               	.LBE203:
  65:ds18b20.c     **** 	_delay_us(1);
  66:ds18b20.c     **** 
  67:ds18b20.c     **** 	//release line and wait for 14uS
  68:ds18b20.c     **** 	DS18B20_DDR &= ~(1<<DS18B20_DQ); //input
 207               		.loc 1 68 0
 208 0048 3D98      		cbi 0x7,5
 209               	.LVL16:
 210               	.LBB207:
 211               	.LBB208:
 212               	.LBB209:
 213               	.LBB210:
  83:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 214               		.loc 2 83 0
 215 004a 8CE4      		ldi r24,lo8(76)
 216               	/* #APP */
 217               	 ;  83 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 218 004c 8A95      		1: dec r24
 219 004e 01F4      		brne 1b
 220               	 ;  0 "" 2
 221               	.LVL17:
 222               	/* #NOAPP */
 223               	.LBE210:
 224               	.LBE209:
 225               	.LBE208:
 226               	.LBE207:
  69:ds18b20.c     **** 	_delay_us(14);
  70:ds18b20.c     **** 
  71:ds18b20.c     **** 	//read the value
  72:ds18b20.c     **** 	if(DS18B20_PIN & (1<<DS18B20_DQ))
 227               		.loc 1 72 0
 228 0050 86B1      		in r24,0x6
 229               	.LVL18:
 230               	.LBB211:
 231               	.LBB212:
 232               	.LBB213:
 233               	.LBB214:
  83:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 234               		.loc 2 83 0
 235 0052 95EF      		ldi r25,lo8(-11)
 236               	/* #APP */
 237               	 ;  83 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 238 0054 9A95      		1: dec r25
 239 0056 01F4      		brne 1b
 240               	 ;  0 "" 2
 241               	.LVL19:
 242               	/* #NOAPP */
 243               	.LBE214:
 244               	.LBE213:
 245               	.LBE212:
 246               	.LBE211:
  73:ds18b20.c     **** 		bit=1;
  74:ds18b20.c     **** 
  75:ds18b20.c     **** 	//wait 45uS and return read value
  76:ds18b20.c     **** 	_delay_us(45);
  77:ds18b20.c     **** 	return bit;
  78:ds18b20.c     **** }
 247               		.loc 1 78 0
 248 0058 85FB      		bst r24,5
 249 005a 8827      		clr r24
 250 005c 80F9      		bld r24,0
 251               	.LVL20:
 252 005e 0895      		ret
 253               		.cfi_endproc
 254               	.LFE9:
 256               	.global	ds18b20_writebyte
 258               	ds18b20_writebyte:
 259               	.LFB10:
  79:ds18b20.c     **** 
  80:ds18b20.c     **** /*
  81:ds18b20.c     ****  * write one byte
  82:ds18b20.c     ****  */
  83:ds18b20.c     **** void ds18b20_writebyte(uint8_t byte){
 260               		.loc 1 83 0
 261               		.cfi_startproc
 262               	.LVL21:
 263 0060 CF93      		push r28
 264               	.LCFI0:
 265               		.cfi_def_cfa_offset 3
 266               		.cfi_offset 28, -2
 267 0062 DF93      		push r29
 268               	.LCFI1:
 269               		.cfi_def_cfa_offset 4
 270               		.cfi_offset 29, -3
 271               	/* prologue: function */
 272               	/* frame size = 0 */
 273               	/* stack size = 2 */
 274               	.L__stack_usage = 2
 275 0064 D82F      		mov r29,r24
 276               	.LVL22:
  84:ds18b20.c     **** 	uint8_t i=8;
  85:ds18b20.c     **** 	while(i--){
 277               		.loc 1 85 0
 278 0066 C9E0      		ldi r28,lo8(9)
 279 0068 00C0      		rjmp .L9
 280               	.LVL23:
 281               	.L10:
  86:ds18b20.c     **** 		ds18b20_writebit(byte&1);
 282               		.loc 1 86 0
 283 006a 8D2F      		mov r24,r29
 284 006c 8170      		andi r24,lo8(1)
 285 006e 0E94 0000 		call ds18b20_writebit
 286               	.LVL24:
  87:ds18b20.c     **** 		byte >>= 1;
 287               		.loc 1 87 0
 288 0072 D695      		lsr r29
 289               	.LVL25:
 290               	.L9:
 291 0074 C150      		subi r28,lo8(-(-1))
  85:ds18b20.c     **** 	while(i--){
 292               		.loc 1 85 0 discriminator 1
 293 0076 01F4      		brne .L10
 294               	/* epilogue start */
  88:ds18b20.c     **** 	}
  89:ds18b20.c     **** }
 295               		.loc 1 89 0
 296 0078 DF91      		pop r29
 297               	.LVL26:
 298 007a CF91      		pop r28
 299 007c 0895      		ret
 300               		.cfi_endproc
 301               	.LFE10:
 303               	.global	ds18b20_readbyte
 305               	ds18b20_readbyte:
 306               	.LFB11:
  90:ds18b20.c     **** 
  91:ds18b20.c     **** /*
  92:ds18b20.c     ****  * read one byte
  93:ds18b20.c     ****  */
  94:ds18b20.c     **** uint8_t ds18b20_readbyte(void){
 307               		.loc 1 94 0
 308               		.cfi_startproc
 309 007e CF93      		push r28
 310               	.LCFI2:
 311               		.cfi_def_cfa_offset 3
 312               		.cfi_offset 28, -2
 313 0080 DF93      		push r29
 314               	.LCFI3:
 315               		.cfi_def_cfa_offset 4
 316               		.cfi_offset 29, -3
 317               	/* prologue: function */
 318               	/* frame size = 0 */
 319               	/* stack size = 2 */
 320               	.L__stack_usage = 2
 321               	.LVL27:
  95:ds18b20.c     **** 	uint8_t i=8, n=0;
  96:ds18b20.c     **** 	while(i--){
 322               		.loc 1 96 0
 323 0082 D9E0      		ldi r29,lo8(9)
  95:ds18b20.c     **** 	uint8_t i=8, n=0;
 324               		.loc 1 95 0
 325 0084 C0E0      		ldi r28,0
 326               		.loc 1 96 0
 327 0086 00C0      		rjmp .L12
 328               	.LVL28:
 329               	.L13:
  97:ds18b20.c     **** 		n >>= 1;
  98:ds18b20.c     **** 		n |= (ds18b20_readbit()<<7);
 330               		.loc 1 98 0
 331 0088 0E94 0000 		call ds18b20_readbit
 332               	.LVL29:
 333 008c 20E8      		ldi r18,lo8(-128)
 334 008e 829F      		mul r24,r18
 335 0090 C001      		movw r24,r0
 336 0092 1124      		clr __zero_reg__
  97:ds18b20.c     **** 		n >>= 1;
 337               		.loc 1 97 0
 338 0094 C695      		lsr r28
 339               	.LVL30:
 340               		.loc 1 98 0
 341 0096 C82B      		or r28,r24
 342               	.LVL31:
 343               	.L12:
 344 0098 D150      		subi r29,lo8(-(-1))
  96:ds18b20.c     **** 	while(i--){
 345               		.loc 1 96 0 discriminator 1
 346 009a 01F4      		brne .L13
  99:ds18b20.c     **** 	}
 100:ds18b20.c     **** 	return n;
 101:ds18b20.c     **** }
 347               		.loc 1 101 0
 348 009c 8C2F      		mov r24,r28
 349               	/* epilogue start */
 350 009e DF91      		pop r29
 351 00a0 CF91      		pop r28
 352               	.LVL32:
 353 00a2 0895      		ret
 354               		.cfi_endproc
 355               	.LFE11:
 357               	.global	__floatsisf
 358               	.global	__floatunsisf
 359               	.global	__mulsf3
 360               	.global	__addsf3
 361               	.global	ds18b20_gettemp
 363               	ds18b20_gettemp:
 364               	.LFB12:
 102:ds18b20.c     **** 
 103:ds18b20.c     **** /*
 104:ds18b20.c     ****  * get temperature
 105:ds18b20.c     ****  */
 106:ds18b20.c     **** double ds18b20_gettemp(void) {
 365               		.loc 1 106 0
 366               		.cfi_startproc
 367 00a4 CF92      		push r12
 368               	.LCFI4:
 369               		.cfi_def_cfa_offset 3
 370               		.cfi_offset 12, -2
 371 00a6 DF92      		push r13
 372               	.LCFI5:
 373               		.cfi_def_cfa_offset 4
 374               		.cfi_offset 13, -3
 375 00a8 EF92      		push r14
 376               	.LCFI6:
 377               		.cfi_def_cfa_offset 5
 378               		.cfi_offset 14, -4
 379 00aa FF92      		push r15
 380               	.LCFI7:
 381               		.cfi_def_cfa_offset 6
 382               		.cfi_offset 15, -5
 383 00ac 1F93      		push r17
 384               	.LCFI8:
 385               		.cfi_def_cfa_offset 7
 386               		.cfi_offset 17, -6
 387 00ae CF93      		push r28
 388               	.LCFI9:
 389               		.cfi_def_cfa_offset 8
 390               		.cfi_offset 28, -7
 391 00b0 DF93      		push r29
 392               	.LCFI10:
 393               		.cfi_def_cfa_offset 9
 394               		.cfi_offset 29, -8
 395               	/* prologue: function */
 396               	/* frame size = 0 */
 397               	/* stack size = 7 */
 398               	.L__stack_usage = 7
 399               	.LVL33:
 107:ds18b20.c     **** 	uint8_t temperature[2];
 108:ds18b20.c     **** 	int8_t digit;
 109:ds18b20.c     **** 	uint16_t decimal;
 110:ds18b20.c     **** 	double retd = 0;
 111:ds18b20.c     **** 
 112:ds18b20.c     **** 	ds18b20_reset(); //reset
 400               		.loc 1 112 0
 401 00b2 0E94 0000 		call ds18b20_reset
 402               	.LVL34:
 113:ds18b20.c     **** 	ds18b20_writebyte(DS18B20_CMD_SKIPROM); //skip ROM
 403               		.loc 1 113 0
 404 00b6 8CEC      		ldi r24,lo8(-52)
 405 00b8 0E94 0000 		call ds18b20_writebyte
 406               	.LVL35:
 114:ds18b20.c     **** 	ds18b20_writebyte(DS18B20_CMD_CONVERTTEMP); //start temperature conversion
 407               		.loc 1 114 0
 408 00bc 84E4      		ldi r24,lo8(68)
 409 00be 0E94 0000 		call ds18b20_writebyte
 410               	.LVL36:
 411               	.L15:
 115:ds18b20.c     **** 
 116:ds18b20.c     **** 	while(!ds18b20_readbit()); //wait until conversion is complete
 412               		.loc 1 116 0 discriminator 1
 413 00c2 0E94 0000 		call ds18b20_readbit
 414               	.LVL37:
 415 00c6 8823      		tst r24
 416 00c8 01F0      		breq .L15
 117:ds18b20.c     **** 
 118:ds18b20.c     **** 	ds18b20_reset(); //reset
 417               		.loc 1 118 0
 418 00ca 0E94 0000 		call ds18b20_reset
 419               	.LVL38:
 119:ds18b20.c     **** 	ds18b20_writebyte(DS18B20_CMD_SKIPROM); //skip ROM
 420               		.loc 1 119 0
 421 00ce 8CEC      		ldi r24,lo8(-52)
 422 00d0 0E94 0000 		call ds18b20_writebyte
 423               	.LVL39:
 120:ds18b20.c     **** 	ds18b20_writebyte(DS18B20_CMD_RSCRATCHPAD); //read scratchpad
 424               		.loc 1 120 0
 425 00d4 8EEB      		ldi r24,lo8(-66)
 426 00d6 0E94 0000 		call ds18b20_writebyte
 427               	.LVL40:
 121:ds18b20.c     **** 
 122:ds18b20.c     **** 	//read 2 byte from scratchpad
 123:ds18b20.c     **** 	temperature[0] = ds18b20_readbyte();
 428               		.loc 1 123 0
 429 00da 0E94 0000 		call ds18b20_readbyte
 430               	.LVL41:
 431 00de C82F      		mov r28,r24
 432               	.LVL42:
 124:ds18b20.c     **** 	temperature[1] = ds18b20_readbyte();
 433               		.loc 1 124 0
 434 00e0 0E94 0000 		call ds18b20_readbyte
 435               	.LVL43:
 436 00e4 182F      		mov r17,r24
 437               	.LVL44:
 125:ds18b20.c     **** 
 126:ds18b20.c     **** 	ds18b20_reset(); //reset
 438               		.loc 1 126 0
 439 00e6 0E94 0000 		call ds18b20_reset
 440               	.LVL45:
 127:ds18b20.c     **** 
 128:ds18b20.c     **** 	//store temperature integer digits
 129:ds18b20.c     **** 	digit = temperature[0]>>4;
 441               		.loc 1 129 0
 442 00ea 6C2F      		mov r22,r28
 443 00ec 6295      		swap r22
 444 00ee 6F70      		andi r22,lo8(15)
 445               	.LVL46:
 130:ds18b20.c     **** 	digit |= (temperature[1]&0x7)<<4;
 131:ds18b20.c     **** 
 132:ds18b20.c     **** 	//store temperature decimal digits
 133:ds18b20.c     **** 	decimal = temperature[0]&0xf;
 446               		.loc 1 133 0
 447 00f0 CF70      		andi r28,lo8(15)
 448               	.LVL47:
 449 00f2 D0E0      		ldi r29,0
 450               	.LVL48:
 130:ds18b20.c     **** 	digit |= (temperature[1]&0x7)<<4;
 451               		.loc 1 130 0
 452 00f4 1770      		andi r17,lo8(7)
 453               	.LVL49:
 454 00f6 20E1      		ldi r18,lo8(16)
 455 00f8 129F      		mul r17,r18
 456 00fa C001      		movw r24,r0
 457 00fc 1124      		clr __zero_reg__
 458 00fe 682B      		or r22,r24
 134:ds18b20.c     **** 	decimal *= DS18B20_DECIMALSTEPS;
 135:ds18b20.c     **** 
 136:ds18b20.c     **** 	//compose the double temperature value and return it
 137:ds18b20.c     **** 	retd = digit + decimal * 0.0001;
 459               		.loc 1 137 0
 460 0100 7727      		clr r23
 461 0102 67FD      		sbrc r22,7
 462 0104 7095      		com r23
 463 0106 872F      		mov r24,r23
 464 0108 972F      		mov r25,r23
 465 010a 0E94 0000 		call __floatsisf
 466               	.LVL50:
 467 010e 6B01      		movw r12,r22
 468 0110 7C01      		movw r14,r24
 134:ds18b20.c     **** 	decimal *= DS18B20_DECIMALSTEPS;
 469               		.loc 1 134 0
 470 0112 81E7      		ldi r24,lo8(113)
 471 0114 92E0      		ldi r25,lo8(2)
 472 0116 C89F      		mul r28,r24
 473 0118 B001      		movw r22,r0
 474 011a C99F      		mul r28,r25
 475 011c 700D      		add r23,r0
 476 011e D89F      		mul r29,r24
 477 0120 700D      		add r23,r0
 478 0122 1124      		clr r1
 479               	.LVL51:
 480               		.loc 1 137 0
 481 0124 80E0      		ldi r24,0
 482 0126 90E0      		ldi r25,0
 483 0128 0E94 0000 		call __floatunsisf
 484               	.LVL52:
 485 012c 27E1      		ldi r18,lo8(23)
 486 012e 37EB      		ldi r19,lo8(-73)
 487 0130 41ED      		ldi r20,lo8(-47)
 488 0132 58E3      		ldi r21,lo8(56)
 489 0134 0E94 0000 		call __mulsf3
 490               	.LVL53:
 491 0138 9B01      		movw r18,r22
 492 013a AC01      		movw r20,r24
 493 013c C701      		movw r24,r14
 494 013e B601      		movw r22,r12
 495 0140 0E94 0000 		call __addsf3
 496               	.LVL54:
 497               	/* epilogue start */
 138:ds18b20.c     **** 
 139:ds18b20.c     **** 	return retd;
 140:ds18b20.c     **** }
 498               		.loc 1 140 0
 499 0144 DF91      		pop r29
 500 0146 CF91      		pop r28
 501               	.LVL55:
 502 0148 1F91      		pop r17
 503 014a FF90      		pop r15
 504 014c EF90      		pop r14
 505 014e DF90      		pop r13
 506 0150 CF90      		pop r12
 507 0152 0895      		ret
 508               		.cfi_endproc
 509               	.LFE12:
 511               	.global	ioInit
 513               	ioInit:
 514               	.LFB14:
 515               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  ~~~~~~~~~~~~~~~~~~~******************** Program Description ********************~~~~~~~~~~~~~~~~~~
   3:main.c        ****  
   4:main.c        **** 	Program Title:	Nixie Clock
   5:main.c        **** 	Author:			Pete Mills
   6:main.c        **** 	Email:			mills.pete@gmail.com
   7:main.c        ****     Website:        petemills.blogspot.com
   8:main.c        **** 	Version:		1.0
   9:main.c        **** 	Filename:		main.c
  10:main.c        **** 	License:		CC BY-NC-SA 3.0 ( Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported )
  11:main.c        ****  
  12:main.c        ****     Clock Description:
  13:main.c        ****     
  14:main.c        ****     This clock is settable using a USB serial interface.  
  15:main.c        ****     It has 12/24 Hr format - set miltime=1 via serial interface for 24 hour format, miltime=0 for 1
  16:main.c        ****     There is a temperature display. - set showtherm to 1 to display the temperature, set to 0 for n
  17:main.c        ****     The temperature can be displayed in celsius of fahrenheit.  Set celsius to 1 for C, set to 0 fo
  18:main.c        ****  
  19:main.c        ****     Software:
  20:main.c        ****     This software may borrow from some of the example code listed below:
  21:main.c        ****     http://homepage.hispeed.ch/peterfleury/doxygen/avr-gcc-libraries/group__pfleury__uart.html
  22:main.c        ****     http://teslabs.com/openplayer/docs/docs/other/ds18b20_pre1.pdf
  23:main.c        ****     https://github.com/ColinBrosseau/AVR-UART-Parse-exemple
  24:main.c        ****  
  25:main.c        **** 	Hardware Description:
  26:main.c        **** 	
  27:main.c        **** 	Processor:	ATMega328
  28:main.c        **** 	F_CPU:		16384000 Hz
  29:main.c        **** 	
  30:main.c        ****  ~~~~~~~~~~~~~~~~~~~******************** Program Description ********************~~~~~~~~~~~~~~~~~~
  31:main.c        ****  
  32:main.c        ****  
  33:main.c        ****  
  34:main.c        ****  
  35:main.c        ****  
  36:main.c        ****  ~~~~~~~~~~~~~~~~~~~~~******************** Fuse Settings ********************~~~~~~~~~~~~~~~~~~~~~~
  37:main.c        ****  
  38:main.c        **** 	Default		Description												Fuse Name / Setting
  39:main.c        **** 	
  40:main.c        **** 	CHANGED		External Crystal Osc.; 16K CK / 14 CK + 65 mS;			[ CKSEL = 1111 SUT = 11 ]
  41:main.c        **** 	UNCHANGED	Clock output on PORTB0; 								[ CKOUT = 0 ]
  42:main.c        **** 	CHANGED		Divide clock by 8 internally; 							[ CKDIV8 = 0 ]
  43:main.c        **** 	UNCHANGED	Boot Reset vector Enabled (default address=$0000); 		[ BOOTRST = 0 ]
  44:main.c        **** 	UNCHANGED	Boot Flash section size = 2048 words;					[ BOOTSZ = 00 ]
  45:main.c        **** 	UNCHANGED	Preserve EEPROM memory through the Chip Erase cycle;	[ EESAVE=0 ]
  46:main.c        **** 	UNCHANGED	Watch-dog Timer always on; 								[ WDTON = 0 ]
  47:main.c        **** 	UNCHANGED	Serial program downloading (SPI) enabled; 				[ SPIEN = 0 ]
  48:main.c        **** 	UNCHANGED	Debug Wire enable; 										[ DWEN = 0 ]
  49:main.c        **** 	UNCHANGED	Reset Disabled (Enable PC6 as i/o pin); 				[ RSTDISBL = 0 ]
  50:main.c        **** 	CHANGED		Brown-out detection level at VCC = 2.7v					[ BODLEVEL = 101 ]
  51:main.c        **** 	
  52:main.c        **** 	AVRDUDE_FUSES = -U lfuse:w:0xff:m -U hfuse:w:0xd9:m -U efuse:w:0xfd:m
  53:main.c        ****  
  54:main.c        ****  ~~~~~~~~~~~~~~~~~~~~~******************** Fuse Settings ********************~~~~~~~~~~~~~~~~~~~~~~
  55:main.c        ****  */
  56:main.c        **** 
  57:main.c        **** 
  58:main.c        **** 
  59:main.c        **** 
  60:main.c        **** 
  61:main.c        **** //~~~~~~~~~~~~~~~~~~~~~~******************** Includes ********************~~~~~~~~~~~~~~~~~~~~~~~~~
  62:main.c        **** 
  63:main.c        **** #include <stdlib.h>
  64:main.c        **** #include <avr/io.h>
  65:main.c        **** #define __DELAY_BACKWARD_COMPATIBLE__	// To allow passing of variables into delay functions.
  66:main.c        **** #include <util/delay.h>
  67:main.c        **** #include <avr/interrupt.h>
  68:main.c        **** #include <avr/pgmspace.h>
  69:main.c        **** #include <avr/eeprom.h>
  70:main.c        **** #include <string.h>
  71:main.c        **** 
  72:main.c        **** #include "uart.h"
  73:main.c        **** #include "main.h"
  74:main.c        **** #include "ds18b20.h"
  75:main.c        **** #include "ds18b20.c"
  76:main.c        **** 
  77:main.c        **** //~~~~~~~~~~~~~~~~~~~~~~******************** Includes ********************~~~~~~~~~~~~~~~~~~~~~~~~~
  78:main.c        **** 
  79:main.c        **** 
  80:main.c        **** 
  81:main.c        **** 
  82:main.c        **** 
  83:main.c        **** //~~~~~~~~~~~~~~~~~~~~~******************** Definitions ********************~~~~~~~~~~~~~~~~~~~~~~~
  84:main.c        **** 
  85:main.c        **** #define SW_1 			PD2		// Generic pushbutton switch.
  86:main.c        **** #define SER				PD3		// Shift registers.
  87:main.c        **** #define SRCLK			PD4		// Shift registers.
  88:main.c        **** #define RCLK			PD5		// Shift registers.
  89:main.c        **** #define F_BOOST			PD6		// Boost converter drive signal.
  90:main.c        **** #define LED 			PD7		// An LED for indication.
  91:main.c        **** 
  92:main.c        **** 
  93:main.c        **** 
  94:main.c        **** #define	AC_FREQ			PB0
  95:main.c        **** 
  96:main.c        **** // Analog inputs.
  97:main.c        **** #define PWR_OK			PC0		// adc_raw[0]
  98:main.c        **** #define HV_FEEDBACK		PC1		// adc_raw[1]
  99:main.c        **** #define BATT_VOLTAGE 	PC2		// adc_raw[2]
 100:main.c        **** #define	RECTIFIED_AC	PC3		// adc_raw[3]
 101:main.c        **** 
 102:main.c        **** #define TEMPERATURE_ARRAY_SIZE  6
 103:main.c        **** 
 104:main.c        **** #define UART_BAUD_RATE  57600
 105:main.c        **** 
 106:main.c        **** #define STRING_LENGTH   100		// UART parsing.
 107:main.c        **** #define CHAR_NEWLINE    '\n'
 108:main.c        **** #define CHAR_RETURN     '\r'
 109:main.c        **** #define RETURN_NEWLINE  "\r\n"
 110:main.c        **** 
 111:main.c        **** #define FIRST_ADC_INPUT 0		// lowest ADC channel to sample
 112:main.c        **** #define ADC_CHANNELS 	4		// number of ADC channels to sample
 113:main.c        **** #define ADC_VREF_TYPE 	64		// AVCC with external capacitor at AREF pin
 114:main.c        **** 
 115:main.c        **** #define AC_FRQ_FILT_SEC	60		// Number of seconds to collect zero crossings.  These zero crossings
 116:main.c        **** 								// will then be averaged anc computed to a frequency stored in acFrequency.
 117:main.c        **** 								
 118:main.c        **** #define AC_HERTZ		60		// number of AC cycles per second.  60 Hz (typ) North America, 50 Hz (typ) Eu
 119:main.c        **** 
 120:main.c        **** //~~~~~~~~~~~~~~~~~~~~~******************** Definitions ********************~~~~~~~~~~~~~~~~~~~~~~~
 121:main.c        **** 
 122:main.c        **** 
 123:main.c        **** 
 124:main.c        **** 
 125:main.c        **** 
 126:main.c        **** //~~~~~~~~~~~~~~~~~~~******************** Global Variables ********************~~~~~~~~~~~~~~~~~~~~
 127:main.c        **** 
 128:main.c        **** const int SERIAL_NUMBER = 100;  // Start at 100.
 129:main.c        **** 
 130:main.c        **** 
 131:main.c        **** uint8_t uartStringIndex = 0; 
 132:main.c        **** unsigned char uartString[STRING_LENGTH];
 133:main.c        **** 
 134:main.c        **** char myUartString[STRING_LENGTH];   // A working copy of uartString.
 135:main.c        **** 
 136:main.c        **** char printBuffer[ 100 ];            // For UART print
 137:main.c        **** 
 138:main.c        **** uint16_t serialInInteger = 0;       // The parsed value of an serial input command.
 139:main.c        **** 
 140:main.c        **** uint8_t hours   = 10;				// these keep track of the current date and time.
 141:main.c        **** uint8_t minutes = 10;
 142:main.c        **** uint8_t day     = 1;
 143:main.c        **** uint8_t month   = 2;
 144:main.c        **** uint16_t year   = 2015;
 145:main.c        **** volatile uint8_t seconds = 30;
 146:main.c        **** 
 147:main.c        **** volatile uint32_t mscal = 0;		// F_CPU / (F_CPU * PPM_ERROR); if mscal == 0, disable adjustment
 148:main.c        **** uint32_t EEMEM ee_mscal = 0;		// For storing to eeprom.
 149:main.c        **** 
 150:main.c        **** 
 151:main.c        **** uint8_t prevSeconds = 0;			// For firing a function every x minutes/seconds.
 152:main.c        **** uint8_t prevMinutes = 0;
 153:main.c        **** 
 154:main.c        **** uint8_t miltime = 1;        		// '1' to display 24-hour format, '0' to display 12-hour format
 155:main.c        **** uint8_t EEMEM ee_miltime = 1;		// for storing miltime to eeprom.
 156:main.c        **** uint8_t showtherm = 0;      		// '1' to display the temperature, '0' to have no temperature display
 157:main.c        **** uint8_t EEMEM ee_showtherm = 0;		// For eeprom storage.
 158:main.c        **** uint8_t showfreq = 0;      			// '1' to display the AC line frequency, '0' to have no frequency dis
 159:main.c        **** uint8_t EEMEM ee_showfreq = 0;		// For eeprom storage.
 160:main.c        **** uint8_t showdate = 0;				// '1' to show the date on the nixies every so often.  '0' to disable.
 161:main.c        **** uint8_t EEMEM ee_showdate = 0;		// For eeprom storage.
 162:main.c        **** uint8_t celsius = 1;        		// '1' to display temperature on the celsius scale, '0' for fahrenhei
 163:main.c        **** uint8_t EEMEM ee_celsius = 1;		// For eeprom storage.
 164:main.c        **** uint8_t doecho = 1;        			// '1' to echo back on the UART
 165:main.c        **** uint8_t EEMEM ee_doecho = 1;		// For eeprom storage.
 166:main.c        **** volatile uint8_t acclock = 1;       // '1' to use the AC power line frequency as a timebase.  '0' t
 167:main.c        **** uint8_t EEMEM ee_acclock = 1;		// For eeprom storage.
 168:main.c        **** uint8_t xtalisfast = 1;     		// '1' if the crystal is running faster than "real time", 0 if slower
 169:main.c        **** uint8_t EEMEM ee_xtalisfast = 1;	// For eeprom Storage.
 170:main.c        **** uint8_t toggleled = 1;     			// '1' to toggle the onboard LED at 1 Hz. "0" for LED OFF
 171:main.c        **** uint8_t EEMEM ee_toggleled = 1;		// For eeprom Storage.
 172:main.c        **** 
 173:main.c        **** uint32_t nixiesleepstart = 0;			// Value for shutting down the display on weekday nights.  24 hour 
 174:main.c        **** 										// Setting to 0 disables the feature.  A value of 1300 means 1:00 PM
 175:main.c        **** uint32_t EEMEM ee_nixiesleepstart = 0;	// For eeprom storage.
 176:main.c        **** uint32_t nixiesleepend = 0;				// This sets the time to turn on the nixies after being off since ni
 177:main.c        **** 										// The same 24 hr, no colon time format applies.  
 178:main.c        **** 										// Does not verify that the end time is after the start time.  You do.
 179:main.c        **** uint32_t EEMEM ee_nixiesleepend = 0;	// Storing to eeprom.
 180:main.c        **** 
 181:main.c        **** 
 182:main.c        **** double celsiusTemperature = 99.0;    		// The temperature read from the DS18b20 in celsius
 183:main.c        **** double averageCelsiusTemperature = 99.0;	// FIR filter for temperature.
 184:main.c        **** double arraySum = 0;						// FIR filter for temperature.
 185:main.c        **** 
 186:main.c        **** double movingAverageArray[ TEMPERATURE_ARRAY_SIZE ];	// 
 187:main.c        **** 
 188:main.c        **** volatile uint8_t boostConverterPwm = 0;		// Current PWM value for the boost converter.
 189:main.c        **** volatile uint8_t boostHighPwm = 80;			// High PWM value for the boost converter.
 190:main.c        **** volatile uint8_t boostLowPwm = 30;			// Low PWM value for the boost converter.
 191:main.c        **** 
 192:main.c        **** volatile uint8_t adc_raw[ADC_CHANNELS];		// For storing the raw ADC counts of conversions.
 193:main.c        **** 
 194:main.c        **** volatile uint16_t acZeroCrossCounter = 0;	// For calculating the AC power line frequency.
 195:main.c        **** volatile uint16_t acZeroCrossSnapshot = 0;	// For evaluating the contents at a specific time point.
 196:main.c        **** volatile double acFrequency = 0.0;			// For calculating the AC power line frequency.
 197:main.c        **** volatile uint8_t acFreqFlag = 0;			// When set to "1" the contents of acFrequency contain the 
 198:main.c        **** 											// total number of zero crossings since the last measure.
 199:main.c        **** 
 200:main.c        **** uint8_t cathodePoisonFlag = 0;				// Flag to tell the app to run the anti-poison routine.
 201:main.c        **** 
 202:main.c        **** //~~~~~~~~~~~~~~~~~~~******************** Global Variables ********************~~~~~~~~~~~~~~~~~~~~
 203:main.c        **** 
 204:main.c        **** 
 205:main.c        **** 
 206:main.c        **** 
 207:main.c        **** //~~~~~~~~~~~~~~~~~~~~~~~~~******************** MAIN ********************~~~~~~~~~~~~~~~~~~~~~~~~~~
 208:main.c        **** 
 209:main.c        **** int main(void)
 210:main.c        **** {
 211:main.c        ****     cli();
 212:main.c        ****     ioInit();
 213:main.c        ****     adcInit();
 214:main.c        ****     boostConverterInit();
 215:main.c        ****     rtcInit();
 216:main.c        ****     uartInit();
 217:main.c        ****     extInterruptInit();
 218:main.c        ****     readEepromToVars();  
 219:main.c        ****     sei();
 220:main.c        ****     
 221:main.c        ****     uartWelcome();
 222:main.c        **** 
 223:main.c        **** 
 224:main.c        ****     while( 1 )
 225:main.c        ****     {
 226:main.c        ****     	
 227:main.c        ****     	updateAcFrequency();			// Every AC_FRQ_FILT_SEC seconds, compute the average.
 228:main.c        ****     	updateTemperatureFilter( 20 );	// FIR averaging filter for the DS18b20.
 229:main.c        ****         updateNixieOutputState();		// Turns ON or OFF the nixie tubes based on input power and slee
 230:main.c        ****       	checkSerialIn();				// Is there new serial data available?
 231:main.c        **** 		updateDateTime();				// Keep track of the current date and time.
 232:main.c        ****       
 233:main.c        ****         // If the time has changed, update the display.
 234:main.c        ****         if( seconds != prevSeconds)
 235:main.c        ****         {
 236:main.c        ****             nixiePrintTime( 1 );	// Display the current time on the nixie tubes and toggle the deci
 237:main.c        ****             prevSeconds = seconds;
 238:main.c        ****             
 239:main.c        ****             //serialPrintDateTime();
 240:main.c        ****             //uart_puts(RETURN_NEWLINE);
 241:main.c        ****              
 242:main.c        ****             //print_value("Day of the week", dayOfWeek( day, month, year ) );
 243:main.c        ****             //uart_puts(RETURN_NEWLINE);
 244:main.c        **** 
 245:main.c        ****         }
 246:main.c        **** 
 247:main.c        **** 
 248:main.c        ****         if( minutes != prevMinutes)
 249:main.c        ****         {
 250:main.c        ****         	cathodePoisonFlag = 1;		// Set every minute.  Cleared in checkCathodePoison(). 
 251:main.c        ****             
 252:main.c        ****             serialPrintDateTime();
 253:main.c        ****             serialPrintTemperature();
 254:main.c        ****             serialPrintAcFrequency();
 255:main.c        ****             uart_puts(RETURN_NEWLINE);
 256:main.c        **** 
 257:main.c        ****             
 258:main.c        ****             // On the nixie.
 259:main.c        ****             if( showdate ){
 260:main.c        ****             	nixiePrintDate();
 261:main.c        ****             	_delay_ms( 5000 );
 262:main.c        ****             }
 263:main.c        ****             
 264:main.c        ****             // On the nixie.
 265:main.c        ****            	if( showtherm ){
 266:main.c        ****            		nixiePrintTemperature();
 267:main.c        ****            		_delay_ms( 5000 );
 268:main.c        ****            	}
 269:main.c        ****            	
 270:main.c        ****            	// On the nixie.
 271:main.c        ****            	if( showfreq ){
 272:main.c        ****            		nixiePrintAcFrequency();
 273:main.c        ****            		_delay_ms( 5000 );
 274:main.c        ****            	}
 275:main.c        ****            
 276:main.c        ****             prevMinutes = minutes;   
 277:main.c        ****         }
 278:main.c        ****         
 279:main.c        ****         checkCathodePoison();			// do the antipoison routine if ready.
 280:main.c        ****         
 281:main.c        ****     }
 282:main.c        **** }
 283:main.c        **** //~~~~~~~~~~~~~~~~~~~~~~~~~******************** MAIN ********************~~~~~~~~~~~~~~~~~~~~~~~~~~
 284:main.c        **** 
 285:main.c        **** 
 286:main.c        **** 
 287:main.c        **** 
 288:main.c        **** void ioInit(void)
 289:main.c        **** {
 516               		.loc 3 289 0
 517               		.cfi_startproc
 518               	/* prologue: function */
 519               	/* frame size = 0 */
 520               	/* stack size = 0 */
 521               	.L__stack_usage = 0
 290:main.c        ****     //~~~~~~~~~~~~~~~~~~******************** Pin Configuration ********************~~~~~~~~~~~~~~~~
 291:main.c        ****     
 292:main.c        ****     // outputs
 293:main.c        ****     
 294:main.c        ****     DDRD |= ( ( 1 << SW_1 ) | ( 1 << SER ) | ( 1 << SRCLK ) | ( 1 << RCLK ) | ( 1 << F_BOOST ) | ( 
 522               		.loc 3 294 0
 523 0154 8AB1      		in r24,0xa
 524 0156 8C6F      		ori r24,lo8(-4)
 525 0158 8AB9      		out 0xa,r24
 295:main.c        ****     PORTD &= ~( ( 1 << SW_1 ) | ( 1 << SER ) | ( 1 << SRCLK ) | ( 1 << RCLK ) |( 1 << F_BOOST ) | (
 526               		.loc 3 295 0
 527 015a 8BB1      		in r24,0xb
 528 015c 8370      		andi r24,lo8(3)
 529 015e 8BB9      		out 0xb,r24
 296:main.c        ****     
 297:main.c        ****     
 298:main.c        ****     // inputs
 299:main.c        ****     
 300:main.c        ****     DDRD &= ~( 1 << SW_1 );	// set pin to 0 for input
 530               		.loc 3 300 0
 531 0160 5298      		cbi 0xa,2
 301:main.c        ****     PORTD |= ( 1 << SW_1 );	// enable internal pullup
 532               		.loc 3 301 0
 533 0162 5A9A      		sbi 0xb,2
 302:main.c        ****     
 303:main.c        ****     DDRB &= ~( 1 << AC_FREQ );	// set pin to 0 for input
 534               		.loc 3 303 0
 535 0164 2098      		cbi 0x4,0
 304:main.c        ****     PORTB |= ( 1 << AC_FREQ );	// enable internal pullup
 536               		.loc 3 304 0
 537 0166 289A      		sbi 0x5,0
 305:main.c        ****     
 306:main.c        ****     DDRC &= ~( ( 1 << PWR_OK ) | ( 1 << HV_FEEDBACK ) | ( 1 << BATT_VOLTAGE ) | ( 1 << RECTIFIED_AC
 538               		.loc 3 306 0
 539 0168 87B1      		in r24,0x7
 540 016a 807F      		andi r24,lo8(-16)
 541 016c 87B9      		out 0x7,r24
 542 016e 0895      		ret
 543               		.cfi_endproc
 544               	.LFE14:
 546               	.global	extInterruptInit
 548               	extInterruptInit:
 549               	.LFB15:
 307:main.c        ****     
 308:main.c        ****     //~~~~~~~~~~~~~~~~~~******************** Pin Configuration ********************~~~~~~~~~~~~~~~~
 309:main.c        **** }
 310:main.c        **** 
 311:main.c        **** 
 312:main.c        **** 
 313:main.c        **** 
 314:main.c        **** 
 315:main.c        **** void extInterruptInit( void )
 316:main.c        **** {
 550               		.loc 3 316 0
 551               		.cfi_startproc
 552               	/* prologue: function */
 553               	/* frame size = 0 */
 554               	/* stack size = 0 */
 555               	.L__stack_usage = 0
 317:main.c        **** 	//~~~~~~~~~~~~~~~~~~************** External Interrupt Configuration ************~~~~~~~~~~~~~~~~~~
 318:main.c        **** 
 319:main.c        ****     PCICR = 0x01; 	// Allow pin change interrupts.
 556               		.loc 3 319 0
 557 0170 81E0      		ldi r24,lo8(1)
 558 0172 8093 6800 		sts 104,r24
 320:main.c        ****     PCMSK0 = 0x01; 	// Enable interrupts specifically for pin PCINT0 
 559               		.loc 3 320 0
 560 0176 8093 6B00 		sts 107,r24
 561 017a 0895      		ret
 562               		.cfi_endproc
 563               	.LFE15:
 565               	.global	rtcInit
 567               	rtcInit:
 568               	.LFB16:
 321:main.c        ****     
 322:main.c        ****     //~~~~~~~~~~~~~~~~~~************** External Interrupt Configuration ************~~~~~~~~~~~~~~~
 323:main.c        **** }
 324:main.c        **** 
 325:main.c        **** 
 326:main.c        **** 
 327:main.c        **** 
 328:main.c        **** 
 329:main.c        **** void rtcInit( void )
 330:main.c        **** {
 569               		.loc 3 330 0
 570               		.cfi_startproc
 571               	/* prologue: function */
 572               	/* frame size = 0 */
 573               	/* stack size = 0 */
 574               	.L__stack_usage = 0
 331:main.c        **** 	//~~~~~~~~~~~~~~~~~~***************** RTC Timer Configuration *****************~~~~~~~~~~~~~~~~~~~
 332:main.c        **** 
 333:main.c        ****     OCR1AH = 0;                 // Interrupt at 1.000 kHz, 0.001 S.
 575               		.loc 3 333 0
 576 017c 1092 8900 		sts 137,__zero_reg__
 334:main.c        ****     OCR1AL = 63;                // Decimal 63, one less than 64000/1000 because 0 and top are count
 577               		.loc 3 334 0
 578 0180 8FE3      		ldi r24,lo8(63)
 579 0182 8093 8800 		sts 136,r24
 335:main.c        ****     TIMSK1 |= ( 1 << OCIE1A );  // enable OCR1A match interrupt
 580               		.loc 3 335 0
 581 0186 EFE6      		ldi r30,lo8(111)
 582 0188 F0E0      		ldi r31,0
 583 018a 8081      		ld r24,Z
 584 018c 8260      		ori r24,lo8(2)
 585 018e 8083      		st Z,r24
 336:main.c        ****     TCCR1B |= (( 1 << WGM12 ) | ( 1 << CS12 ));	// start timer, CTC mode OCR1A match, ck/div by 256
 586               		.loc 3 336 0
 587 0190 E1E8      		ldi r30,lo8(-127)
 588 0192 F0E0      		ldi r31,0
 589 0194 8081      		ld r24,Z
 590 0196 8C60      		ori r24,lo8(12)
 591 0198 8083      		st Z,r24
 592 019a 0895      		ret
 593               		.cfi_endproc
 594               	.LFE16:
 596               	.global	adcInit
 598               	adcInit:
 599               	.LFB17:
 337:main.c        ****     
 338:main.c        ****     //~~~~~~~~~~~~~~~~~~***************** RTC Timer Configuration *****************~~~~~~~~~~~~~~~~
 339:main.c        **** }
 340:main.c        **** 
 341:main.c        **** 
 342:main.c        **** 
 343:main.c        **** 
 344:main.c        **** 
 345:main.c        **** void adcInit( void )
 346:main.c        **** {
 600               		.loc 3 346 0
 601               		.cfi_startproc
 602               	/* prologue: function */
 603               	/* frame size = 0 */
 604               	/* stack size = 0 */
 605               	.L__stack_usage = 0
 347:main.c        **** 	//~~~~~~~~~~~~~~~~~~******************** ADC Configuration ********************~~~~~~~~~~~~~~~~~~~
 348:main.c        **** 
 349:main.c        ****   	// ADC clock prescale of 1/128 for 128 kHz
 350:main.c        ****   	ADCSRA = ( ( 1 << ADEN ) | ( 1 << ADATE ) | ( 1 << ADIE ) | ( 1 << ADPS2 ) | ( 1 << ADPS1 ) | ( 
 606               		.loc 3 350 0
 607 019c 8FEA      		ldi r24,lo8(-81)
 608 019e 8093 7A00 		sts 122,r24
 351:main.c        ****   	
 352:main.c        ****   	ADCSRB |= (1<<ADTS2);
 609               		.loc 3 352 0
 610 01a2 EBE7      		ldi r30,lo8(123)
 611 01a4 F0E0      		ldi r31,0
 612 01a6 8081      		ld r24,Z
 613 01a8 8460      		ori r24,lo8(4)
 614 01aa 8083      		st Z,r24
 353:main.c        ****   	
 354:main.c        ****   	// Disable digital input buffers to save power.
 355:main.c        ****   	DIDR0 = ( ( 1 << ADC0D ) | ( 1 << ADC1D ) | ( 1 << ADC2D ) | ( 1 << ADC3D ) );
 615               		.loc 3 355 0
 616 01ac 8FE0      		ldi r24,lo8(15)
 617 01ae 8093 7E00 		sts 126,r24
 618 01b2 0895      		ret
 619               		.cfi_endproc
 620               	.LFE17:
 622               	.global	boostConverterInit
 624               	boostConverterInit:
 625               	.LFB18:
 356:main.c        **** 
 357:main.c        ****     //~~~~~~~~~~~~~~~~~~******************** ADC Configuration ********************~~~~~~~~~~~~~~~~
 358:main.c        **** }
 359:main.c        **** 
 360:main.c        **** 
 361:main.c        **** 
 362:main.c        **** 
 363:main.c        **** void boostConverterInit( void )
 364:main.c        **** {
 626               		.loc 3 364 0
 627               		.cfi_startproc
 628               	/* prologue: function */
 629               	/* frame size = 0 */
 630               	/* stack size = 0 */
 631               	.L__stack_usage = 0
 365:main.c        **** 	//~~~~~~~~~~~~~~~~~~************** Boost Converter Configuration **************~~~~~~~~~~~~~~~~~~~
 366:main.c        **** 
 367:main.c        **** 	// PWM Frequency: 64 kHz
 368:main.c        **** 	
 369:main.c        **** 	// Timer/Counter0: channel: A, clear on compare match ( non-inverting ), Fast PWM, TOP = 0xFF
 370:main.c        **** 	TCCR0A |= ((1<<COM0A1) | (1<<WGM01) | (1<<WGM00));
 632               		.loc 3 370 0
 633 01b4 84B5      		in r24,0x24
 634 01b6 8368      		ori r24,lo8(-125)
 635 01b8 84BD      		out 0x24,r24
 371:main.c        **** 	TCCR0B |= ( 1 << CS00 );	// internal clock as source, no prescale, start the timer
 636               		.loc 3 371 0
 637 01ba 85B5      		in r24,0x25
 638 01bc 8160      		ori r24,lo8(1)
 639 01be 85BD      		out 0x25,r24
 640 01c0 0895      		ret
 641               		.cfi_endproc
 642               	.LFE18:
 644               	.global	__vector_21
 646               	__vector_21:
 647               	.LFB19:
 372:main.c        **** 
 373:main.c        ****     //~~~~~~~~~~~~~~~~~~************** Boost Converter Configuration **************~~~~~~~~~~~~~~~~
 374:main.c        **** }
 375:main.c        **** 
 376:main.c        **** 
 377:main.c        **** 
 378:main.c        **** 
 379:main.c        **** 
 380:main.c        **** //~~~~~~~~~~~~~~~~~~~~~~******************** Functions ********************~~~~~~~~~~~~~~~~~~~~~~~~
 381:main.c        **** 
 382:main.c        **** // ADC interrupt service routine.
 383:main.c        **** // This is called at the completion of each ADC read cycle.
 384:main.c        **** // At the end of the ISR, the next conversion is started and we exit.
 385:main.c        **** ISR(ADC_vect) 
 386:main.c        **** {
 648               		.loc 3 386 0
 649               		.cfi_startproc
 650 01c2 1F92      		push r1
 651               	.LCFI11:
 652               		.cfi_def_cfa_offset 3
 653               		.cfi_offset 1, -2
 654 01c4 0F92      		push r0
 655               	.LCFI12:
 656               		.cfi_def_cfa_offset 4
 657               		.cfi_offset 0, -3
 658 01c6 0FB6      		in r0,__SREG__
 659 01c8 0F92      		push r0
 660 01ca 1124      		clr __zero_reg__
 661 01cc 8F93      		push r24
 662               	.LCFI13:
 663               		.cfi_def_cfa_offset 5
 664               		.cfi_offset 24, -4
 665 01ce 9F93      		push r25
 666               	.LCFI14:
 667               		.cfi_def_cfa_offset 6
 668               		.cfi_offset 25, -5
 669 01d0 EF93      		push r30
 670               	.LCFI15:
 671               		.cfi_def_cfa_offset 7
 672               		.cfi_offset 30, -6
 673 01d2 FF93      		push r31
 674               	.LCFI16:
 675               		.cfi_def_cfa_offset 8
 676               		.cfi_offset 31, -7
 677               	/* prologue: Signal */
 678               	/* frame size = 0 */
 679               	/* stack size = 7 */
 680               	.L__stack_usage = 7
 387:main.c        **** static unsigned char input_index=0;
 388:main.c        **** 
 389:main.c        **** // Read the AD conversion result
 390:main.c        ****    adc_raw[input_index]=ADCH;
 681               		.loc 3 390 0
 682 01d4 8091 0000 		lds r24,input_index.2181
 683 01d8 E82F      		mov r30,r24
 684 01da F0E0      		ldi r31,0
 685 01dc 9091 7900 		lds r25,121
 686 01e0 E050      		subi r30,lo8(-(adc_raw))
 687 01e2 F040      		sbci r31,hi8(-(adc_raw))
 688 01e4 9083      		st Z,r25
 391:main.c        ****    
 392:main.c        **** // Select next ADC input
 393:main.c        ****    if (++input_index >= ADC_CHANNELS)
 689               		.loc 3 393 0
 690 01e6 8F5F      		subi r24,lo8(-(1))
 691 01e8 8430      		cpi r24,lo8(4)
 692 01ea 00F4      		brsh .L26
 693 01ec 8093 0000 		sts input_index.2181,r24
 694 01f0 00C0      		rjmp .L27
 695               	.L26:
 394:main.c        ****       {
 395:main.c        ****       input_index=0;
 696               		.loc 3 395 0
 697 01f2 1092 0000 		sts input_index.2181,__zero_reg__
 698               	.L27:
 396:main.c        ****       }
 397:main.c        **** 
 398:main.c        ****    ADMUX=(FIRST_ADC_INPUT | ADC_VREF_TYPE | ( 1 << ADLAR ) ) + input_index; //and left adjust
 699               		.loc 3 398 0
 700 01f6 8091 0000 		lds r24,input_index.2181
 701 01fa 805A      		subi r24,lo8(-(96))
 702 01fc 8093 7C00 		sts 124,r24
 399:main.c        **** 
 400:main.c        **** // Start the AD conversion
 401:main.c        ****    ADCSRA |= (1<<ADSC);
 703               		.loc 3 401 0
 704 0200 8091 7A00 		lds r24,122
 705 0204 8064      		ori r24,lo8(64)
 706 0206 8093 7A00 		sts 122,r24
 707               	/* epilogue start */
 402:main.c        **** 
 403:main.c        **** } 
 708               		.loc 3 403 0
 709 020a FF91      		pop r31
 710 020c EF91      		pop r30
 711 020e 9F91      		pop r25
 712 0210 8F91      		pop r24
 713 0212 0F90      		pop r0
 714 0214 0FBE      		out __SREG__,r0
 715 0216 0F90      		pop r0
 716 0218 1F90      		pop r1
 717 021a 1895      		reti
 718               		.cfi_endproc
 719               	.LFE19:
 721               	.global	__vector_3
 723               	__vector_3:
 724               	.LFB20:
 404:main.c        **** 
 405:main.c        **** 
 406:main.c        **** 
 407:main.c        **** // External interrupt connected to the AC optocoupler.
 408:main.c        **** // Interrupt triggers on rising and falling edges, so double your AC_HERTZ.
 409:main.c        **** // This function will only be called so long as there is an AC input waveform.
 410:main.c        **** // For that reason, we do not need to code for when we lose AC power.  We just have
 411:main.c        **** // to say, if this function is called and we want to use the AC frequency as a timebase
 412:main.c        **** // then increment our seconds.  In ISR( TIMER1_COMPA_vect ) we have to have a bit more logic.
 413:main.c        **** ISR (PCINT0_vect)
 414:main.c        **** {
 725               		.loc 3 414 0
 726               		.cfi_startproc
 727 021c 1F92      		push r1
 728               	.LCFI17:
 729               		.cfi_def_cfa_offset 3
 730               		.cfi_offset 1, -2
 731 021e 0F92      		push r0
 732               	.LCFI18:
 733               		.cfi_def_cfa_offset 4
 734               		.cfi_offset 0, -3
 735 0220 0FB6      		in r0,__SREG__
 736 0222 0F92      		push r0
 737 0224 1124      		clr __zero_reg__
 738 0226 8F93      		push r24
 739               	.LCFI19:
 740               		.cfi_def_cfa_offset 5
 741               		.cfi_offset 24, -4
 742 0228 9F93      		push r25
 743               	.LCFI20:
 744               		.cfi_def_cfa_offset 6
 745               		.cfi_offset 25, -5
 746               	/* prologue: Signal */
 747               	/* frame size = 0 */
 748               	/* stack size = 5 */
 749               	.L__stack_usage = 5
 415:main.c        **** 	static uint8_t timebaseCounter = 0;		// For timekeeping
 416:main.c        **** 	
 417:main.c        **** 	timebaseCounter++;	// Counting AC cycles.
 750               		.loc 3 417 0
 751 022a 8091 0000 		lds r24,timebaseCounter.2187
 752 022e 8F5F      		subi r24,lo8(-(1))
 753 0230 8093 0000 		sts timebaseCounter.2187,r24
 418:main.c        **** 	
 419:main.c        **** 	if( acclock == 1 ){
 754               		.loc 3 419 0
 755 0234 9091 0000 		lds r25,acclock
 756 0238 9130      		cpi r25,lo8(1)
 757 023a 01F4      		brne .L29
 420:main.c        **** 	
 421:main.c        **** 		if( timebaseCounter > ( AC_HERTZ * 2 ) - 1 ){
 758               		.loc 3 421 0
 759 023c 8837      		cpi r24,lo8(120)
 760 023e 00F0      		brlo .L29
 422:main.c        **** 		
 423:main.c        **** 			seconds++;	// Increment the main seconds counter.
 761               		.loc 3 423 0
 762 0240 8091 0000 		lds r24,seconds
 763 0244 8F5F      		subi r24,lo8(-(1))
 764 0246 8093 0000 		sts seconds,r24
 424:main.c        **** 			
 425:main.c        **** 			timebaseCounter = 0;
 765               		.loc 3 425 0
 766 024a 1092 0000 		sts timebaseCounter.2187,__zero_reg__
 767               	.L29:
 426:main.c        **** 		}
 427:main.c        **** 		
 428:main.c        **** 	}
 429:main.c        **** 	
 430:main.c        **** 	acZeroCrossCounter++;	// For measuring the AC frequency - not used for timekeeping
 768               		.loc 3 430 0
 769 024e 8091 0000 		lds r24,acZeroCrossCounter
 770 0252 9091 0000 		lds r25,acZeroCrossCounter+1
 771 0256 0196      		adiw r24,1
 772 0258 9093 0000 		sts acZeroCrossCounter+1,r25
 773 025c 8093 0000 		sts acZeroCrossCounter,r24
 774               	/* epilogue start */
 431:main.c        **** 	
 432:main.c        **** }
 775               		.loc 3 432 0
 776 0260 9F91      		pop r25
 777 0262 8F91      		pop r24
 778 0264 0F90      		pop r0
 779 0266 0FBE      		out __SREG__,r0
 780 0268 0F90      		pop r0
 781 026a 1F90      		pop r1
 782 026c 1895      		reti
 783               		.cfi_endproc
 784               	.LFE20:
 786               	.global	toggle_led
 788               	toggle_led:
 789               	.LFB21:
 433:main.c        **** 
 434:main.c        **** 
 435:main.c        **** 
 436:main.c        **** 
 437:main.c        **** 
 438:main.c        **** void toggle_led()
 439:main.c        **** {
 790               		.loc 3 439 0
 791               		.cfi_startproc
 792               	/* prologue: function */
 793               	/* frame size = 0 */
 794               	/* stack size = 0 */
 795               	.L__stack_usage = 0
 440:main.c        ****     PORTD ^= ( 1 << LED );
 796               		.loc 3 440 0
 797 026e 8BB1      		in r24,0xb
 798 0270 8058      		subi r24,lo8(-(-128))
 799 0272 8BB9      		out 0xb,r24
 800 0274 0895      		ret
 801               		.cfi_endproc
 802               	.LFE21:
 804               	.global	blip_led
 806               	blip_led:
 807               	.LFB22:
 441:main.c        **** }
 442:main.c        **** 
 443:main.c        **** 
 444:main.c        **** 
 445:main.c        **** 
 446:main.c        **** 
 447:main.c        **** void blip_led()
 448:main.c        **** {
 808               		.loc 3 448 0
 809               		.cfi_startproc
 810               	/* prologue: function */
 811               	/* frame size = 0 */
 812               	/* stack size = 0 */
 813               	.L__stack_usage = 0
 449:main.c        ****     PORTD |= ( 1 << LED );	// on
 814               		.loc 3 449 0
 815 0276 5F9A      		sbi 0xb,7
 816               	.LVL56:
 817               	.LBB215:
 818               	.LBB216:
 819               	.LBB217:
 820               	.LBB218:
 821               		.loc 2 105 0
 822 0278 80E0      		ldi r24,0
 823 027a 90E3      		ldi r25,lo8(48)
 824               	/* #APP */
 825               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 826 027c 0197      		1: sbiw r24,1
 827 027e 01F4      		brne 1b
 828               	 ;  0 "" 2
 829               	.LVL57:
 830               	/* #NOAPP */
 831               	.LBE218:
 832               	.LBE217:
 833               	.LBE216:
 834               	.LBE215:
 450:main.c        ****     _delay_ms(3);
 451:main.c        ****     PORTD &= ~( 1 << LED );	// off
 835               		.loc 3 451 0
 836 0280 5F98      		cbi 0xb,7
 837 0282 0895      		ret
 838               		.cfi_endproc
 839               	.LFE22:
 841               	.global	is_switch_pressed
 843               	is_switch_pressed:
 844               	.LFB23:
 452:main.c        **** }
 453:main.c        **** 
 454:main.c        **** 
 455:main.c        **** 
 456:main.c        **** 
 457:main.c        **** 
 458:main.c        **** int is_switch_pressed( char port, char pin, int ms_debounce, int ms_block )
 459:main.c        **** {
 845               		.loc 3 459 0
 846               		.cfi_startproc
 847               	.LVL58:
 848               	/* prologue: function */
 849               	/* frame size = 0 */
 850               	/* stack size = 0 */
 851               	.L__stack_usage = 0
 460:main.c        ****     
 461:main.c        ****     if ( !( port & ( 1 << pin ) ) )
 852               		.loc 3 461 0
 853 0284 282F      		mov r18,r24
 854               	.LVL59:
 855 0286 30E0      		ldi r19,0
 856 0288 00C0      		rjmp 2f
 857               		1:
 858 028a 3595      		asr r19
 859 028c 2795      		ror r18
 860               		2:
 861 028e 6A95      		dec r22
 862 0290 02F4      		brpl 1b
 863 0292 2170      		andi r18,1
 864 0294 3327      		clr r19
 462:main.c        ****     {
 463:main.c        ****         //_delay_ms( ms_debounce );
 464:main.c        ****         if ( !( port & ( 1 << pin ) ) ) return 1;
 865               		.loc 3 464 0
 866 0296 81E0      		ldi r24,1
 867 0298 2827      		eor r18,r24
 868               	.LVL60:
 465:main.c        ****     }
 466:main.c        ****     
 467:main.c        ****     return 0;
 468:main.c        **** }
 869               		.loc 3 468 0
 870 029a C901      		movw r24,r18
 871 029c 0895      		ret
 872               		.cfi_endproc
 873               	.LFE23:
 875               	.global	splitString
 877               	splitString:
 878               	.LFB24:
 469:main.c        **** 
 470:main.c        **** 
 471:main.c        **** 
 472:main.c        **** 
 473:main.c        **** uint32_t splitString(char aString[100])
 474:main.c        **** {
 879               		.loc 3 474 0
 880               		.cfi_startproc
 881               	.LVL61:
 882 029e CF93      		push r28
 883               	.LCFI21:
 884               		.cfi_def_cfa_offset 3
 885               		.cfi_offset 28, -2
 886 02a0 DF93      		push r29
 887               	.LCFI22:
 888               		.cfi_def_cfa_offset 4
 889               		.cfi_offset 29, -3
 890 02a2 CDB7      		in r28,__SP_L__
 891 02a4 DEB7      		in r29,__SP_H__
 892               	.LCFI23:
 893               		.cfi_def_cfa_register 28
 894 02a6 C456      		subi r28,100
 895 02a8 D109      		sbc r29,__zero_reg__
 896               	.LCFI24:
 897               		.cfi_def_cfa_offset 104
 898 02aa 0FB6      		in __tmp_reg__,__SREG__
 899 02ac F894      		cli
 900 02ae DEBF      		out __SP_H__,r29
 901 02b0 0FBE      		out __SREG__,__tmp_reg__
 902 02b2 CDBF      		out __SP_L__,r28
 903               	/* prologue: function */
 904               	/* frame size = 100 */
 905               	/* stack size = 102 */
 906               	.L__stack_usage = 102
 475:main.c        ****     
 476:main.c        ****     char *splitChar;
 477:main.c        ****     char subString[100];
 478:main.c        ****     
 479:main.c        ****     // find the equal symbol.  Var to the left, value to the right
 480:main.c        ****     splitChar = strchr( aString, '=');
 907               		.loc 3 480 0
 908 02b4 6DE3      		ldi r22,lo8(61)
 909 02b6 70E0      		ldi r23,0
 910 02b8 0E94 0000 		call strchr
 911               	.LVL62:
 481:main.c        ****     
 482:main.c        ****     strcpy(subString, splitChar + 1);
 912               		.loc 3 482 0
 913 02bc BC01      		movw r22,r24
 914 02be 6F5F      		subi r22,-1
 915 02c0 7F4F      		sbci r23,-1
 916 02c2 CE01      		movw r24,r28
 917               	.LVL63:
 918 02c4 0196      		adiw r24,1
 919 02c6 0E94 0000 		call strcpy
 920               	.LVL64:
 483:main.c        ****     
 484:main.c        ****     return atol( subString );
 921               		.loc 3 484 0
 922 02ca CE01      		movw r24,r28
 923 02cc 0196      		adiw r24,1
 924 02ce 0E94 0000 		call atol
 925               	.LVL65:
 926               	/* epilogue start */
 485:main.c        **** }
 927               		.loc 3 485 0
 928 02d2 CC59      		subi r28,-100
 929 02d4 DF4F      		sbci r29,-1
 930 02d6 0FB6      		in __tmp_reg__,__SREG__
 931 02d8 F894      		cli
 932 02da DEBF      		out __SP_H__,r29
 933 02dc 0FBE      		out __SREG__,__tmp_reg__
 934 02de CDBF      		out __SP_L__,r28
 935 02e0 DF91      		pop r29
 936 02e2 CF91      		pop r28
 937 02e4 0895      		ret
 938               		.cfi_endproc
 939               	.LFE24:
 941               	.global	copy_command
 943               	copy_command:
 944               	.LFB25:
 486:main.c        **** 
 487:main.c        **** 
 488:main.c        **** 
 489:main.c        **** 
 490:main.c        **** void copy_command ()
 491:main.c        **** {
 945               		.loc 3 491 0
 946               		.cfi_startproc
 947               	/* prologue: function */
 948               	/* frame size = 0 */
 949               	/* stack size = 0 */
 950               	.L__stack_usage = 0
 492:main.c        ****     // Move a copy of uartString to myuartString
 493:main.c        ****     memmove(myUartString, uartString, sizeof( myUartString ) );
 951               		.loc 3 493 0
 952 02e6 84E6      		ldi r24,lo8(100)
 953 02e8 E0E0      		ldi r30,lo8(uartString)
 954 02ea F0E0      		ldi r31,hi8(uartString)
 955 02ec A0E0      		ldi r26,lo8(myUartString)
 956 02ee B0E0      		ldi r27,hi8(myUartString)
 957               		0:
 958 02f0 0190      		ld r0,Z+
 959 02f2 0D92      		st X+,r0
 960 02f4 8A95      		dec r24
 961 02f6 01F4      		brne 0b
 494:main.c        ****     // Empty the uartString.
 495:main.c        ****     memset(uartString, 0, sizeof( myUartString ) );
 962               		.loc 3 495 0
 963 02f8 84E6      		ldi r24,lo8(100)
 964 02fa E0E0      		ldi r30,lo8(uartString)
 965 02fc F0E0      		ldi r31,hi8(uartString)
 966 02fe DF01      		movw r26,r30
 967               		0:
 968 0300 1D92      		st X+,__zero_reg__
 969 0302 8A95      		dec r24
 970 0304 01F4      		brne 0b
 971 0306 0895      		ret
 972               		.cfi_endproc
 973               	.LFE25:
 975               	.global	inRange
 977               	inRange:
 978               	.LFB26:
 496:main.c        **** }
 497:main.c        **** 
 498:main.c        **** 
 499:main.c        **** 
 500:main.c        **** 
 501:main.c        **** uint8_t inRange( uint32_t inputValue, uint32_t upperBound, uint32_t lowerBound )
 502:main.c        **** {
 979               		.loc 3 502 0
 980               		.cfi_startproc
 981               	.LVL66:
 982 0308 EF92      		push r14
 983               	.LCFI25:
 984               		.cfi_def_cfa_offset 3
 985               		.cfi_offset 14, -2
 986 030a FF92      		push r15
 987               	.LCFI26:
 988               		.cfi_def_cfa_offset 4
 989               		.cfi_offset 15, -3
 990 030c 0F93      		push r16
 991               	.LCFI27:
 992               		.cfi_def_cfa_offset 5
 993               		.cfi_offset 16, -4
 994 030e 1F93      		push r17
 995               	.LCFI28:
 996               		.cfi_def_cfa_offset 6
 997               		.cfi_offset 17, -5
 998               	/* prologue: function */
 999               	/* frame size = 0 */
 1000               	/* stack size = 4 */
 1001               	.L__stack_usage = 4
 503:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 1002               		.loc 3 503 0
 1003 0310 6E15      		cp r22,r14
 1004 0312 7F05      		cpc r23,r15
 1005 0314 8007      		cpc r24,r16
 1006 0316 9107      		cpc r25,r17
 1007 0318 00F0      		brlo .L38
 1008               		.loc 3 503 0 is_stmt 0 discriminator 1
 1009 031a E1E0      		ldi r30,lo8(1)
 1010 031c 2617      		cp r18,r22
 1011 031e 3707      		cpc r19,r23
 1012 0320 4807      		cpc r20,r24
 1013 0322 5907      		cpc r21,r25
 1014 0324 00F4      		brsh .L36
 1015               	.L38:
 504:main.c        **** 	{
 505:main.c        **** 		return 1;
 506:main.c        **** 	}
 507:main.c        **** 	
 508:main.c        **** 	return 0;
 1016               		.loc 3 508 0 is_stmt 1
 1017 0326 E0E0      		ldi r30,0
 1018               	.L36:
 509:main.c        **** }
 1019               		.loc 3 509 0
 1020 0328 8E2F      		mov r24,r30
 1021               	/* epilogue start */
 1022 032a 1F91      		pop r17
 1023 032c 0F91      		pop r16
 1024 032e FF90      		pop r15
 1025 0330 EF90      		pop r14
 1026               	.LVL67:
 1027 0332 0895      		ret
 1028               		.cfi_endproc
 1029               	.LFE26:
 1031               		.section	.rodata.str1.1,"aMS",@progbits,1
 1032               	.LC1:
 1033 0000 3A20 00   		.string	": "
 1034               		.text
 1035               	.global	print_value
 1037               	print_value:
 1038               	.LFB28:
 510:main.c        **** 
 511:main.c        **** 
 512:main.c        **** 
 513:main.c        **** 
 514:main.c        **** 
 515:main.c        **** void process_command()
 516:main.c        **** {
 517:main.c        ****     if(strcasestr(myUartString,"hours") != NULL){
 518:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 519:main.c        ****             print_value("Hours", hours);
 520:main.c        ****         }else{
 521:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 522:main.c        ****         		if( inRange( splitString(myUartString), 23, 0 ) )
 523:main.c        ****             		hours = splitString(myUartString);
 524:main.c        ****             }
 525:main.c        ****         }
 526:main.c        ****     }
 527:main.c        ****     
 528:main.c        ****     else if(strcasestr(myUartString,"minutes") != NULL){
 529:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 530:main.c        ****             print_value("Minutes", minutes);
 531:main.c        ****         }else{
 532:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 533:main.c        ****         		if( inRange( splitString(myUartString), 59, 0 ) )
 534:main.c        ****             		minutes = splitString(myUartString);
 535:main.c        ****             }
 536:main.c        ****         }
 537:main.c        ****     }
 538:main.c        ****     
 539:main.c        ****     else if(strcasestr(myUartString,"seconds") != NULL){
 540:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 541:main.c        ****             print_value("Seconds", seconds);
 542:main.c        ****         }else{
 543:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 544:main.c        ****         		if( inRange( splitString(myUartString), 59, 0 ) )
 545:main.c        ****             		seconds = splitString(myUartString);
 546:main.c        ****             }
 547:main.c        ****         }
 548:main.c        ****     }
 549:main.c        ****     
 550:main.c        ****     else if(strcasestr(myUartString,"mscal") != NULL){
 551:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 552:main.c        ****             print_value("mS Calibration", mscal);
 553:main.c        ****         }else{
 554:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 555:main.c        ****         		if( inRange( splitString(myUartString), 4294967295, 0 ) )
 556:main.c        ****             		mscal = splitString(myUartString);
 557:main.c        ****             }
 558:main.c        ****         }
 559:main.c        ****     }
 560:main.c        ****     
 561:main.c        ****     else if(strcasestr(myUartString,"miltime") != NULL){
 562:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 563:main.c        ****             print_value("MIL Time", miltime);
 564:main.c        ****         }else{
 565:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 566:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 567:main.c        ****             		miltime = splitString(myUartString);
 568:main.c        ****             }
 569:main.c        ****         }
 570:main.c        ****     }
 571:main.c        ****     
 572:main.c        ****     else if(strcasestr(myUartString,"year") != NULL){
 573:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 574:main.c        ****             print_value("Year", year);
 575:main.c        ****         }else{
 576:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 577:main.c        ****         		if( inRange( splitString(myUartString), 2525, 0 ) )
 578:main.c        ****             		year = splitString(myUartString);
 579:main.c        ****             }
 580:main.c        ****         }
 581:main.c        ****     }
 582:main.c        ****     
 583:main.c        ****     else if(strcasestr(myUartString,"month") != NULL){
 584:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 585:main.c        ****             print_value("Month", month);
 586:main.c        ****         }else{
 587:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 588:main.c        ****         		if( inRange( splitString(myUartString), 12, 0 ) )
 589:main.c        ****             		month = splitString(myUartString);
 590:main.c        ****             }
 591:main.c        ****         }
 592:main.c        ****     }
 593:main.c        ****     
 594:main.c        ****     else if(strcasestr(myUartString,"day") != NULL){
 595:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 596:main.c        ****             print_value("Day", day);
 597:main.c        ****         }else{
 598:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 599:main.c        ****         		if( inRange( splitString(myUartString), 31, 0 ) )
 600:main.c        ****             		day = splitString(myUartString);
 601:main.c        ****             }
 602:main.c        ****         }
 603:main.c        ****     }
 604:main.c        ****     
 605:main.c        ****     else if(strcasestr(myUartString,"celsius") != NULL){
 606:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 607:main.c        ****             print_value("Celsius", celsius);
 608:main.c        ****         }else{
 609:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 610:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 611:main.c        ****             		celsius = splitString(myUartString);
 612:main.c        ****             }
 613:main.c        ****         }
 614:main.c        ****     }
 615:main.c        ****     
 616:main.c        ****     else if(strcasestr(myUartString,"doecho") != NULL){
 617:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 618:main.c        ****             print_value("Do Echo", doecho);
 619:main.c        ****         }else{
 620:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 621:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 622:main.c        ****             		doecho = splitString(myUartString);
 623:main.c        ****             }
 624:main.c        ****         }
 625:main.c        ****     }
 626:main.c        ****     
 627:main.c        ****     else if(strcasestr(myUartString,"acclock") != NULL){
 628:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 629:main.c        ****             print_value("AC Clock", acclock);
 630:main.c        ****         }else{
 631:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 632:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 633:main.c        ****             		acclock = splitString(myUartString);
 634:main.c        ****             }
 635:main.c        ****         }
 636:main.c        ****     }
 637:main.c        ****     
 638:main.c        ****     else if(strcasestr(myUartString,"xtalisfast") != NULL){
 639:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 640:main.c        ****             print_value("xtalisfast", xtalisfast);
 641:main.c        ****         }else{
 642:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 643:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 644:main.c        ****             		xtalisfast = splitString(myUartString);
 645:main.c        ****             }
 646:main.c        ****         }
 647:main.c        ****     }
 648:main.c        ****     
 649:main.c        **** 	else if(strcasestr(myUartString,"showtherm") != NULL){
 650:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 651:main.c        ****             print_value("Show Therm", showtherm);
 652:main.c        ****         }else{
 653:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 654:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 655:main.c        ****             		showtherm = splitString(myUartString);
 656:main.c        ****             }
 657:main.c        ****         }
 658:main.c        ****     }
 659:main.c        ****     
 660:main.c        ****     else if(strcasestr(myUartString,"showfreq") != NULL){
 661:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 662:main.c        ****             print_value("Show Freq", showfreq);
 663:main.c        ****         }else{
 664:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 665:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 666:main.c        ****             		showfreq = splitString(myUartString);
 667:main.c        ****             }
 668:main.c        ****         }
 669:main.c        ****     }
 670:main.c        **** 	
 671:main.c        **** 	else if(strcasestr(myUartString,"showdate") != NULL){
 672:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 673:main.c        ****             print_value("Show Date", showdate);
 674:main.c        ****         }else{
 675:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 676:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 677:main.c        ****             		showdate = splitString(myUartString);
 678:main.c        ****             }
 679:main.c        ****         }
 680:main.c        ****     }
 681:main.c        ****     
 682:main.c        ****     else if(strcasestr(myUartString,"toggleled")!= NULL){
 683:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 684:main.c        ****             print_value("Toggle LED", toggleled);
 685:main.c        ****         }else{
 686:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 687:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 688:main.c        ****             		toggleled = splitString(myUartString);
 689:main.c        ****             }
 690:main.c        ****         }
 691:main.c        ****     }
 692:main.c        ****     
 693:main.c        ****     else if(strcasestr(myUartString,"nixiesleepstart") != NULL){
 694:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 695:main.c        ****             print_value("Nixie Sleep Start Time", nixiesleepstart);
 696:main.c        ****         }else{
 697:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 698:main.c        ****         		if( inRange( splitString(myUartString), 2358, 0 ) )
 699:main.c        ****             		nixiesleepstart = splitString(myUartString);
 700:main.c        ****             }
 701:main.c        ****         }
 702:main.c        ****     }
 703:main.c        ****     
 704:main.c        ****     else if(strcasestr(myUartString,"nixiesleepend") != NULL){
 705:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 706:main.c        ****             print_value("Nixie Sleep End Time", nixiesleepend);
 707:main.c        ****         }else{
 708:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 709:main.c        ****         		if( inRange( splitString(myUartString), 2359, nixiesleepstart + 1 ) )
 710:main.c        ****             		nixiesleepend = splitString(myUartString);
 711:main.c        ****             }
 712:main.c        ****         }
 713:main.c        ****     }
 714:main.c        ****     
 715:main.c        ****     
 716:main.c        ****     else if(strcasestr(myUartString,"getall") != NULL){
 717:main.c        ****     	
 718:main.c        ****     	print_csv( ",", hours );					
 719:main.c        ****     	print_csv( ",", minutes );					
 720:main.c        ****     	print_csv( ",", seconds );					
 721:main.c        ****     	print_csv( ",", mscal );					
 722:main.c        ****     	print_csv( ",", miltime );					
 723:main.c        ****     	print_csv( ",", year );						
 724:main.c        ****     	print_csv( ",", month );					
 725:main.c        ****     	print_csv( ",", day );						
 726:main.c        ****     	print_csv( ",", celsius );					
 727:main.c        ****     	print_csv( ",", doecho );					
 728:main.c        ****     	print_csv( ",", xtalisfast );				
 729:main.c        ****     	print_csv( ",", showtherm );				
 730:main.c        ****     	print_csv( ",", showdate );					
 731:main.c        ****     	print_csv( ",", toggleled );				
 732:main.c        ****     	print_csv( ",", nixiesleepstart );			
 733:main.c        ****     	print_csv( ",", nixiesleepend );				
 734:main.c        ****     	print_csv( ",", SERIAL_NUMBER );			
 735:main.c        ****     	
 736:main.c        ****     	// PWR_OK
 737:main.c        ****     	double Volts = adc_raw[0] * 0.019375;
 738:main.c        ****         dtostrf(Volts , 10, 2, printBuffer);
 739:main.c        ****         uart_puts(printBuffer);
 740:main.c        ****         uart_puts(",");
 741:main.c        ****         
 742:main.c        ****         // HV_Feedback
 743:main.c        ****         Volts = adc_raw[1] * 1.9375;
 744:main.c        ****         dtostrf(Volts , 10, 2, printBuffer);
 745:main.c        ****         uart_puts(printBuffer);
 746:main.c        ****         uart_puts(",");
 747:main.c        ****         
 748:main.c        ****         // Battery Voltage
 749:main.c        ****         Volts = adc_raw[2] * 0.019375;
 750:main.c        ****         dtostrf(Volts , 10, 2, printBuffer);
 751:main.c        ****         uart_puts(printBuffer);
 752:main.c        ****         uart_puts(",");
 753:main.c        ****         
 754:main.c        ****         // Rectified AC voltage
 755:main.c        ****         Volts = adc_raw[3] * 0.11;
 756:main.c        ****         dtostrf(Volts , 10, 2, printBuffer);
 757:main.c        ****         uart_puts(printBuffer);
 758:main.c        ****     	
 759:main.c        ****     }
 760:main.c        ****     
 761:main.c        ****     else if(strcasestr(myUartString,"ramtoeeprom") != NULL){
 762:main.c        ****     	updateVarsToEeprom();   
 763:main.c        **** 		uart_puts( "EEPROM Storage Complete");
 764:main.c        ****     }
 765:main.c        ****     
 766:main.c        ****     else if(strstr(myUartString,"poke") != NULL){
 767:main.c        ****         
 768:main.c        ****         uart_puts( "Hello!");
 769:main.c        ****         uart_puts( RETURN_NEWLINE );
 770:main.c        ****         uart_puts( "I'm Serial Number: ");
 771:main.c        ****         uart_puts( itoa( SERIAL_NUMBER, printBuffer, 10 ) );
 772:main.c        ****         
 773:main.c        ****     }
 774:main.c        ****     
 775:main.c        ****     else if(strstr(myUartString,"pwrok") != NULL){
 776:main.c        ****         // ~0.019375 V/count
 777:main.c        ****         double pwrokVolts = adc_raw[0] * 0.019375;
 778:main.c        ****         dtostrf(pwrokVolts , 10, 2, printBuffer);
 779:main.c        ****         uart_puts(printBuffer);
 780:main.c        ****     }
 781:main.c        ****     
 782:main.c        ****     else if(strstr(myUartString,"hvfeedback") != NULL){
 783:main.c        ****         // ~1.9375 V/count
 784:main.c        ****         double hvVolts = adc_raw[1] * 1.9375;
 785:main.c        ****         dtostrf(hvVolts , 10, 2, printBuffer);
 786:main.c        ****         uart_puts(printBuffer);
 787:main.c        ****     }
 788:main.c        ****     
 789:main.c        ****     else if(strstr(myUartString,"battvoltage") != NULL){
 790:main.c        ****         // ~0.019375 V/count
 791:main.c        ****         double battVolts = adc_raw[2] * 0.019375;
 792:main.c        ****         dtostrf(battVolts , 10, 2, printBuffer);
 793:main.c        ****         uart_puts(printBuffer);
 794:main.c        ****     }
 795:main.c        ****     
 796:main.c        ****     else if(strstr(myUartString,"rectifiedac") != NULL){
 797:main.c        ****     	// 1K / 1K + 4K7 = 1K / 5K7 = ~0.175438 
 798:main.c        ****     	// 0.175 ^-1 = 5.7 
 799:main.c        ****         // ~0.11 V/count
 800:main.c        ****         double rectVolts = adc_raw[3] * 0.11;
 801:main.c        ****         dtostrf(rectVolts , 10, 2, printBuffer);
 802:main.c        ****         uart_puts(printBuffer);
 803:main.c        ****     }
 804:main.c        ****     uart_puts( RETURN_NEWLINE );
 805:main.c        **** }
 806:main.c        **** 
 807:main.c        **** // PWR_OK 			PC0		// adc_raw[0]
 808:main.c        **** // HV_FEEDBACK		PC1		// adc_raw[1]
 809:main.c        **** // BATT_VOLTAGE 	PC2		// adc_raw[2]
 810:main.c        **** // RECTIFIED_AC	    PC3		// adc_raw[3]
 811:main.c        **** 
 812:main.c        **** 
 813:main.c        **** 
 814:main.c        **** void print_value (char *id, uint32_t value)
 815:main.c        **** {
 1039               		.loc 3 815 0
 1040               		.cfi_startproc
 1041               	.LVL68:
 1042 0334 CF93      		push r28
 1043               	.LCFI29:
 1044               		.cfi_def_cfa_offset 3
 1045               		.cfi_offset 28, -2
 1046 0336 DF93      		push r29
 1047               	.LCFI30:
 1048               		.cfi_def_cfa_offset 4
 1049               		.cfi_offset 29, -3
 1050               	/* prologue: function */
 1051               	/* frame size = 0 */
 1052               	/* stack size = 2 */
 1053               	.L__stack_usage = 2
 1054 0338 EC01      		movw r28,r24
 1055 033a CB01      		movw r24,r22
 1056 033c BA01      		movw r22,r20
 816:main.c        ****     ultoa(value, printBuffer, 10);
 1057               		.loc 3 816 0
 1058 033e 2AE0      		ldi r18,lo8(10)
 1059 0340 30E0      		ldi r19,0
 1060 0342 40E0      		ldi r20,lo8(printBuffer)
 1061 0344 50E0      		ldi r21,hi8(printBuffer)
 1062               	.LVL69:
 1063 0346 0E94 0000 		call ultoa
 1064               	.LVL70:
 817:main.c        ****     uart_puts(id);
 1065               		.loc 3 817 0
 1066 034a CE01      		movw r24,r28
 1067 034c 0E94 0000 		call uart_puts
 1068               	.LVL71:
 818:main.c        ****     uart_puts(": ");
 1069               		.loc 3 818 0
 1070 0350 80E0      		ldi r24,lo8(.LC1)
 1071 0352 90E0      		ldi r25,hi8(.LC1)
 1072 0354 0E94 0000 		call uart_puts
 1073               	.LVL72:
 819:main.c        ****     uart_puts(printBuffer);
 1074               		.loc 3 819 0
 1075 0358 80E0      		ldi r24,lo8(printBuffer)
 1076 035a 90E0      		ldi r25,hi8(printBuffer)
 1077               	/* epilogue start */
 820:main.c        ****     //uart_puts(RETURN_NEWLINE);
 821:main.c        **** }
 1078               		.loc 3 821 0
 1079 035c DF91      		pop r29
 1080 035e CF91      		pop r28
 1081               	.LVL73:
 819:main.c        ****     uart_puts(printBuffer);
 1082               		.loc 3 819 0
 1083 0360 0C94 0000 		jmp uart_puts
 1084               	.LVL74:
 1085               		.cfi_endproc
 1086               	.LFE28:
 1088               	.global	print_csv
 1090               	print_csv:
 1091               	.LFB29:
 822:main.c        **** 
 823:main.c        **** 
 824:main.c        **** 
 825:main.c        **** void print_csv( char *id, uint32_t value )
 826:main.c        **** {
 1092               		.loc 3 826 0
 1093               		.cfi_startproc
 1094               	.LVL75:
 1095 0364 CF93      		push r28
 1096               	.LCFI31:
 1097               		.cfi_def_cfa_offset 3
 1098               		.cfi_offset 28, -2
 1099 0366 DF93      		push r29
 1100               	.LCFI32:
 1101               		.cfi_def_cfa_offset 4
 1102               		.cfi_offset 29, -3
 1103               	/* prologue: function */
 1104               	/* frame size = 0 */
 1105               	/* stack size = 2 */
 1106               	.L__stack_usage = 2
 1107 0368 EC01      		movw r28,r24
 1108 036a CB01      		movw r24,r22
 1109 036c BA01      		movw r22,r20
 827:main.c        ****     ultoa(value, printBuffer, 10);
 1110               		.loc 3 827 0
 1111 036e 2AE0      		ldi r18,lo8(10)
 1112 0370 30E0      		ldi r19,0
 1113 0372 40E0      		ldi r20,lo8(printBuffer)
 1114 0374 50E0      		ldi r21,hi8(printBuffer)
 1115               	.LVL76:
 1116 0376 0E94 0000 		call ultoa
 1117               	.LVL77:
 828:main.c        **** 
 829:main.c        ****     //uart_puts(": ");
 830:main.c        ****     uart_puts(printBuffer);
 1118               		.loc 3 830 0
 1119 037a 80E0      		ldi r24,lo8(printBuffer)
 1120 037c 90E0      		ldi r25,hi8(printBuffer)
 1121 037e 0E94 0000 		call uart_puts
 1122               	.LVL78:
 831:main.c        ****         uart_puts(id);
 1123               		.loc 3 831 0
 1124 0382 CE01      		movw r24,r28
 1125               	/* epilogue start */
 832:main.c        ****     //uart_puts(RETURN_NEWLINE);
 833:main.c        **** }
 1126               		.loc 3 833 0
 1127 0384 DF91      		pop r29
 1128 0386 CF91      		pop r28
 1129               	.LVL79:
 831:main.c        ****         uart_puts(id);
 1130               		.loc 3 831 0
 1131 0388 0C94 0000 		jmp uart_puts
 1132               	.LVL80:
 1133               		.cfi_endproc
 1134               	.LFE29:
 1136               		.section	.rodata.str1.1
 1137               	.LC2:
 1138 0003 4F4B 00   		.string	"OK"
 1139               	.LC3:
 1140 0006 0D0A 00   		.string	"\r\n"
 1141               		.text
 1142               	.global	uart_ok
 1144               	uart_ok:
 1145               	.LFB30:
 834:main.c        **** 
 835:main.c        **** 
 836:main.c        **** 
 837:main.c        **** 
 838:main.c        **** void uart_ok()
 839:main.c        **** {
 1146               		.loc 3 839 0
 1147               		.cfi_startproc
 1148               	/* prologue: function */
 1149               	/* frame size = 0 */
 1150               	/* stack size = 0 */
 1151               	.L__stack_usage = 0
 840:main.c        ****     uart_puts("OK");
 1152               		.loc 3 840 0
 1153 038c 80E0      		ldi r24,lo8(.LC2)
 1154 038e 90E0      		ldi r25,hi8(.LC2)
 1155 0390 0E94 0000 		call uart_puts
 1156               	.LVL81:
 841:main.c        ****     uart_puts(RETURN_NEWLINE);
 1157               		.loc 3 841 0
 1158 0394 80E0      		ldi r24,lo8(.LC3)
 1159 0396 90E0      		ldi r25,hi8(.LC3)
 1160 0398 0C94 0000 		jmp uart_puts
 1161               	.LVL82:
 1162               		.cfi_endproc
 1163               	.LFE30:
 1165               		.section	.rodata.str1.1
 1166               	.LC4:
 1167 0009 2F2F 7E7E 		.string	"//~~~~~~~~~~~~************ Nixie Clock Instructions ************~~~~~~~~~~~~~~"
 1167      7E7E 7E7E 
 1167      7E7E 7E7E 
 1167      7E7E 2A2A 
 1167      2A2A 2A2A 
 1168               	.LC5:
 1169 0058 4154 4D65 		.string	"ATMega328 Nixie Clock"
 1169      6761 3332 
 1169      3820 4E69 
 1169      7869 6520 
 1169      436C 6F63 
 1170               	.LC6:
 1171 006e 4368 6563 		.string	"Check petemills.blogspot.com for more info"
 1171      6B20 7065 
 1171      7465 6D69 
 1171      6C6C 732E 
 1171      626C 6F67 
 1172               	.LC7:
 1173 0099 5479 7065 		.string	"Type 'HOURS=10' to set the hours to '10'."
 1173      2027 484F 
 1173      5552 533D 
 1173      3130 2720 
 1173      746F 2073 
 1174               	.LC8:
 1175 00c3 5479 7065 		.string	"Type 'MINUTES=26' to set the minutes to '26'."
 1175      2027 4D49 
 1175      4E55 5445 
 1175      533D 3236 
 1175      2720 746F 
 1176               	.LC9:
 1177 00f1 5669 7369 		.string	"Visit the URL above to download a clock calibration app."
 1177      7420 7468 
 1177      6520 5552 
 1177      4C20 6162 
 1177      6F76 6520 
 1178               		.text
 1179               	.global	uartWelcome
 1181               	uartWelcome:
 1182               	.LFB32:
 842:main.c        **** }
 843:main.c        **** 
 844:main.c        **** 
 845:main.c        **** 
 846:main.c        **** 
 847:main.c        **** void checkSerialIn()
 848:main.c        **** {
 849:main.c        ****     
 850:main.c        ****     unsigned int aChar = uart_getc();
 851:main.c        ****     
 852:main.c        ****     if ( aChar & UART_NO_DATA )
 853:main.c        ****     {
 854:main.c        ****         
 855:main.c        ****          // No data available from UART
 856:main.c        **** 
 857:main.c        ****     }
 858:main.c        ****     else
 859:main.c        ****     {
 860:main.c        **** 
 861:main.c        ****         /*
 862:main.c        ****          * new data available from UART
 863:main.c        ****          * check for Frame or Overrun error
 864:main.c        ****          */
 865:main.c        ****         if ( aChar & UART_FRAME_ERROR )
 866:main.c        ****         {
 867:main.c        ****             /* Framing Error detected, i.e no stop bit detected */
 868:main.c        ****             uart_puts_P("UART Frame Error: ");
 869:main.c        ****         }
 870:main.c        ****         if ( aChar & UART_OVERRUN_ERROR )
 871:main.c        ****         {
 872:main.c        ****             /*
 873:main.c        ****              * Overrun, a character already present in the UART UDR register was
 874:main.c        ****              * not read by the interrupt handler before the next character arrived,
 875:main.c        ****              * one or more received characters have been dropped
 876:main.c        ****              */
 877:main.c        ****             uart_puts_P("UART Overrun Error: ");
 878:main.c        ****         }
 879:main.c        ****         if ( aChar & UART_BUFFER_OVERFLOW )
 880:main.c        ****         {
 881:main.c        ****             /*
 882:main.c        ****              * We are not reading the receive buffer fast enough,
 883:main.c        ****              * one or more received character have been dropped
 884:main.c        ****              */
 885:main.c        ****             uart_puts_P("Buffer overflow error: ");
 886:main.c        ****         }
 887:main.c        ****         /*
 888:main.c        ****          * send received character back
 889:main.c        ****          */
 890:main.c        ****         
 891:main.c        ****     // Add aChar to the growing string.
 892:main.c        ****     uartString[uartStringIndex] = aChar;
 893:main.c        ****     
 894:main.c        ****     // Keep going until we see a CHAR_RETURN.
 895:main.c        ****     if (uartString[uartStringIndex] == CHAR_RETURN) {
 896:main.c        ****         // Reset to 0, ready to go again
 897:main.c        ****         uartStringIndex = 0;
 898:main.c        ****         uart_puts(RETURN_NEWLINE);
 899:main.c        ****         
 900:main.c        ****         copy_command();
 901:main.c        ****         process_command();
 902:main.c        ****         }
 903:main.c        ****     else {
 904:main.c        ****         uartStringIndex++;
 905:main.c        ****     }
 906:main.c        ****     
 907:main.c        ****     if( doecho ){
 908:main.c        ****     	uart_putc( (unsigned char)aChar ); //echo
 909:main.c        ****     }
 910:main.c        ****         
 911:main.c        ****     }
 912:main.c        **** }
 913:main.c        **** 
 914:main.c        **** 
 915:main.c        **** 
 916:main.c        **** 
 917:main.c        **** void uartWelcome( void )
 918:main.c        **** {
 1183               		.loc 3 918 0
 1184               		.cfi_startproc
 1185               	/* prologue: function */
 1186               	/* frame size = 0 */
 1187               	/* stack size = 0 */
 1188               	.L__stack_usage = 0
 919:main.c        **** 
 920:main.c        ****     uart_puts("//~~~~~~~~~~~~************ Nixie Clock Instructions ************~~~~~~~~~~~~~~");
 1189               		.loc 3 920 0
 1190 039c 80E0      		ldi r24,lo8(.LC4)
 1191 039e 90E0      		ldi r25,hi8(.LC4)
 1192 03a0 0E94 0000 		call uart_puts
 1193               	.LVL83:
 921:main.c        ****     uart_puts(RETURN_NEWLINE);
 1194               		.loc 3 921 0
 1195 03a4 80E0      		ldi r24,lo8(.LC3)
 1196 03a6 90E0      		ldi r25,hi8(.LC3)
 1197 03a8 0E94 0000 		call uart_puts
 1198               	.LVL84:
 922:main.c        ****     uart_puts("ATMega328 Nixie Clock");
 1199               		.loc 3 922 0
 1200 03ac 80E0      		ldi r24,lo8(.LC5)
 1201 03ae 90E0      		ldi r25,hi8(.LC5)
 1202 03b0 0E94 0000 		call uart_puts
 1203               	.LVL85:
 923:main.c        ****     uart_puts(RETURN_NEWLINE);
 1204               		.loc 3 923 0
 1205 03b4 80E0      		ldi r24,lo8(.LC3)
 1206 03b6 90E0      		ldi r25,hi8(.LC3)
 1207 03b8 0E94 0000 		call uart_puts
 1208               	.LVL86:
 924:main.c        ****     uart_puts("Check petemills.blogspot.com for more info");
 1209               		.loc 3 924 0
 1210 03bc 80E0      		ldi r24,lo8(.LC6)
 1211 03be 90E0      		ldi r25,hi8(.LC6)
 1212 03c0 0E94 0000 		call uart_puts
 1213               	.LVL87:
 925:main.c        ****     uart_puts(RETURN_NEWLINE);
 1214               		.loc 3 925 0
 1215 03c4 80E0      		ldi r24,lo8(.LC3)
 1216 03c6 90E0      		ldi r25,hi8(.LC3)
 1217 03c8 0E94 0000 		call uart_puts
 1218               	.LVL88:
 926:main.c        ****     uart_puts(RETURN_NEWLINE);
 1219               		.loc 3 926 0
 1220 03cc 80E0      		ldi r24,lo8(.LC3)
 1221 03ce 90E0      		ldi r25,hi8(.LC3)
 1222 03d0 0E94 0000 		call uart_puts
 1223               	.LVL89:
 927:main.c        ****     uart_puts("Type 'HOURS=10' to set the hours to '10'.");
 1224               		.loc 3 927 0
 1225 03d4 80E0      		ldi r24,lo8(.LC7)
 1226 03d6 90E0      		ldi r25,hi8(.LC7)
 1227 03d8 0E94 0000 		call uart_puts
 1228               	.LVL90:
 928:main.c        ****     uart_puts(RETURN_NEWLINE);
 1229               		.loc 3 928 0
 1230 03dc 80E0      		ldi r24,lo8(.LC3)
 1231 03de 90E0      		ldi r25,hi8(.LC3)
 1232 03e0 0E94 0000 		call uart_puts
 1233               	.LVL91:
 929:main.c        ****     uart_puts("Type 'MINUTES=26' to set the minutes to '26'.");
 1234               		.loc 3 929 0
 1235 03e4 80E0      		ldi r24,lo8(.LC8)
 1236 03e6 90E0      		ldi r25,hi8(.LC8)
 1237 03e8 0E94 0000 		call uart_puts
 1238               	.LVL92:
 930:main.c        ****     uart_puts(RETURN_NEWLINE);
 1239               		.loc 3 930 0
 1240 03ec 80E0      		ldi r24,lo8(.LC3)
 1241 03ee 90E0      		ldi r25,hi8(.LC3)
 1242 03f0 0E94 0000 		call uart_puts
 1243               	.LVL93:
 931:main.c        ****     uart_puts("Visit the URL above to download a clock calibration app.");
 1244               		.loc 3 931 0
 1245 03f4 80E0      		ldi r24,lo8(.LC9)
 1246 03f6 90E0      		ldi r25,hi8(.LC9)
 1247 03f8 0E94 0000 		call uart_puts
 1248               	.LVL94:
 932:main.c        ****     uart_puts(RETURN_NEWLINE);
 1249               		.loc 3 932 0
 1250 03fc 80E0      		ldi r24,lo8(.LC3)
 1251 03fe 90E0      		ldi r25,hi8(.LC3)
 1252 0400 0E94 0000 		call uart_puts
 1253               	.LVL95:
 933:main.c        ****     uart_puts("//~~~~~~~~~~~~************ Nixie Clock Instructions ************~~~~~~~~~~~~~~");
 1254               		.loc 3 933 0
 1255 0404 80E0      		ldi r24,lo8(.LC4)
 1256 0406 90E0      		ldi r25,hi8(.LC4)
 1257 0408 0C94 0000 		jmp uart_puts
 1258               	.LVL96:
 1259               		.cfi_endproc
 1260               	.LFE32:
 1262               	.global	uartInit
 1264               	uartInit:
 1265               	.LFB33:
 934:main.c        **** }
 935:main.c        **** 
 936:main.c        **** 
 937:main.c        **** 
 938:main.c        **** 
 939:main.c        **** void uartInit( void )
 940:main.c        **** {
 1266               		.loc 3 940 0
 1267               		.cfi_startproc
 1268               	/* prologue: function */
 1269               	/* frame size = 0 */
 1270               	/* stack size = 0 */
 1271               	.L__stack_usage = 0
 941:main.c        ****         uart_init( UART_BAUD_SELECT(UART_BAUD_RATE,F_CPU) );
 1272               		.loc 3 941 0
 1273 040c 80E1      		ldi r24,lo8(16)
 1274 040e 90E0      		ldi r25,0
 1275 0410 0C94 0000 		jmp uart_init
 1276               	.LVL97:
 1277               		.cfi_endproc
 1278               	.LFE33:
 1280               		.section	.rodata.str1.1
 1281               	.LC10:
 1282 012a 2C20 00   		.string	", "
 1283               		.text
 1284               	.global	serialPrintDateTime
 1286               	serialPrintDateTime:
 1287               	.LFB36:
 942:main.c        **** }
 943:main.c        **** 
 944:main.c        **** 
 945:main.c        **** 
 946:main.c        **** 
 947:main.c        **** 
 948:main.c        **** // This interrupt is called at 1kHz
 949:main.c        **** // Here we are keeping track of milliseconds and adjusting them slightly to get 1 clock second
 950:main.c        **** // to equal 1 real world second very closely.
 951:main.c        **** // Set via serial comms,  mscal = F_CPU / (F_CPU * PPM_ERROR), then set fast or slow.
 952:main.c        **** ISR( TIMER1_COMPA_vect )
 953:main.c        **** {
 954:main.c        ****     static uint16_t milliSeconds = 0;		// mS value for timekeeping 1000mS/1S
 955:main.c        ****     static uint32_t clockCalCounter = 0;	// counting up the milliseconds to mscal
 956:main.c        ****     const uint16_t MS_IN_SEC = 1000;		// 1000mS/1S
 957:main.c        ****     static uint16_t acFreqFiltCtr = 0;		// this is incremented until it == AC_FRQ_FILT_SEC
 958:main.c        ****     milliSeconds++;
 959:main.c        ****     clockCalCounter++;
 960:main.c        ****     
 961:main.c        ****     
 962:main.c        ****     if( milliSeconds >= MS_IN_SEC )
 963:main.c        ****     {
 964:main.c        ****     	if( acclock == 0 || acPowerOk() == 0 ){	// If we are meant to use the internal xtal, not power
 965:main.c        ****     											// Or, if we loose AC power, and we are in AC clock mode we should step in and keep 
 966:main.c        ****         	seconds++;          // increment seconds
 967:main.c        ****         }
 968:main.c        ****         
 969:main.c        ****         	milliSeconds = 0;   // reset milliseconds
 970:main.c        ****         
 971:main.c        ****         	if( toggleled )		// Clearly toggling the LED is only available when using the internal xta
 972:main.c        ****         		toggle_led();	// Toggle the LED if allowed.
 973:main.c        ****         	acFreqFiltCtr++;	// Increment the frequency filter counter.	
 974:main.c        ****     }
 975:main.c        ****     
 976:main.c        ****     // For measuring the power line frequency.
 977:main.c        **** 	if( acFreqFiltCtr >= AC_FRQ_FILT_SEC )
 978:main.c        **** 	{
 979:main.c        **** 		acZeroCrossSnapshot = acZeroCrossCounter;	// Grab the current number of zero crossings since the 
 980:main.c        **** 		acZeroCrossCounter = 0;				// Reset the number of zero crossings.
 981:main.c        **** 		acFreqFlag = 1;						// Signal that a computation is ready to be made.
 982:main.c        **** 		acFreqFiltCtr = 0;					// Reset the measurement interval counter.
 983:main.c        **** 	}
 984:main.c        **** 
 985:main.c        ****     
 986:main.c        **** 
 987:main.c        ****     // Only adjust the time if mscal is not 0, this way we can disable the
 988:main.c        ****     // adjustment during the calibration procedure.
 989:main.c        ****     if( mscal != 0 )
 990:main.c        ****     {
 991:main.c        ****         if( xtalisfast == 1 )
 992:main.c        ****         {
 993:main.c        ****             if( ( clockCalCounter >= mscal ) && ( milliSeconds > 1 ))
 994:main.c        ****             {
 995:main.c        ****                 milliSeconds--;
 996:main.c        ****                 clockCalCounter = clockCalCounter - mscal;
 997:main.c        ****             }
 998:main.c        ****         }
 999:main.c        ****         else
1000:main.c        ****         {
1001:main.c        ****             // milliseconds must be less than 999 to avoid missing an adjustment.
1002:main.c        ****             // eg if milliseconds were to be 999 and we increment it here to 1000
1003:main.c        ****             // the next ISR call will make it 1001 and reset to zero just as if it
1004:main.c        ****             // would for 1000 and the adjustment would be effectively canceled out.
1005:main.c        ****             if( ( clockCalCounter >= mscal ) && ( milliSeconds < MS_IN_SEC - 1 ) )
1006:main.c        ****             {
1007:main.c        ****                 milliSeconds++;
1008:main.c        ****          
1009:main.c        ****                 // it may be that clock_cal_counter > than mscal in which case
1010:main.c        ****                 // I want to count the tick towards the next adjustment
1011:main.c        ****                 // should always be 1 or 0
1012:main.c        ****                 clockCalCounter = clockCalCounter - mscal;
1013:main.c        ****             }
1014:main.c        ****         }
1015:main.c        ****     }
1016:main.c        ****     
1017:main.c        ****     updateBoostConverter();	// Updated here for determinism.
1018:main.c        **** }
1019:main.c        **** 
1020:main.c        **** 
1021:main.c        **** 
1022:main.c        **** 
1023:main.c        **** void updateDateTime( void )
1024:main.c        **** {
1025:main.c        ****     uint8_t numDaysInMonth[] = {0,31,28,31,30,31,30,31,31,30,31,30,31};
1026:main.c        ****     
1027:main.c        ****     if( numDaysInMonth[2] == 28 && isLeapYear() )
1028:main.c        ****     {
1029:main.c        ****         numDaysInMonth[2] = 29;
1030:main.c        ****     }
1031:main.c        ****     else if( numDaysInMonth[2] == 29 )
1032:main.c        ****     {
1033:main.c        ****         numDaysInMonth[2] = 28;
1034:main.c        ****     }
1035:main.c        ****     
1036:main.c        ****     
1037:main.c        ****     if( seconds > 59 )
1038:main.c        ****     {
1039:main.c        ****         minutes++;		// increment minutes
1040:main.c        ****         seconds = 0;	// reset seconds
1041:main.c        ****     }
1042:main.c        ****     
1043:main.c        ****     if( minutes > 59 )
1044:main.c        ****     {
1045:main.c        ****         hours++;		// increment hours
1046:main.c        ****         minutes = 0; 	// reset minutes
1047:main.c        ****     }
1048:main.c        ****     
1049:main.c        ****     if( hours > 23 )
1050:main.c        ****     {
1051:main.c        ****         day++;          // increment day
1052:main.c        ****         hours = 0;		// reset hours
1053:main.c        ****     }
1054:main.c        ****     
1055:main.c        ****     if( day > numDaysInMonth[ month ] )
1056:main.c        ****     {
1057:main.c        ****         month++;        // increment the month
1058:main.c        ****         day = 1;        // reset the day counter to the first
1059:main.c        ****     }
1060:main.c        ****     
1061:main.c        ****     if( month > 12 )
1062:main.c        ****     {
1063:main.c        ****         year++;         // increment the year
1064:main.c        ****         month = 1;      // reset the month to january
1065:main.c        ****     }
1066:main.c        ****     
1067:main.c        ****     
1068:main.c        **** }
1069:main.c        **** 
1070:main.c        **** 
1071:main.c        **** 
1072:main.c        **** 
1073:main.c        **** void serialPrintDateTime( void )
1074:main.c        **** {
 1288               		.loc 3 1074 0
 1289               		.cfi_startproc
 1290               	/* prologue: function */
 1291               	/* frame size = 0 */
 1292               	/* stack size = 0 */
 1293               	.L__stack_usage = 0
1075:main.c        ****     //if( isLeapYear() )
1076:main.c        ****     //    uart_puts("L ");
1077:main.c        ****     // Print the date in YYYY.MM.DD format
1078:main.c        ****     uart_puts( itoa( year, printBuffer, 10 ) );
 1294               		.loc 3 1078 0
 1295 0414 4AE0      		ldi r20,lo8(10)
 1296 0416 50E0      		ldi r21,0
 1297 0418 60E0      		ldi r22,lo8(printBuffer)
 1298 041a 70E0      		ldi r23,hi8(printBuffer)
 1299 041c 8091 0000 		lds r24,year
 1300 0420 9091 0000 		lds r25,year+1
 1301 0424 0E94 0000 		call itoa
 1302               	.LVL98:
 1303 0428 0E94 0000 		call uart_puts
 1304               	.LVL99:
1079:main.c        ****     uart_putc('-');
 1305               		.loc 3 1079 0
 1306 042c 8DE2      		ldi r24,lo8(45)
 1307 042e 0E94 0000 		call uart_putc
 1308               	.LVL100:
1080:main.c        ****     
1081:main.c        ****     uart_puts( itoa( month, printBuffer, 10 ) );
 1309               		.loc 3 1081 0
 1310 0432 4AE0      		ldi r20,lo8(10)
 1311 0434 50E0      		ldi r21,0
 1312 0436 60E0      		ldi r22,lo8(printBuffer)
 1313 0438 70E0      		ldi r23,hi8(printBuffer)
 1314 043a 8091 0000 		lds r24,month
 1315 043e 90E0      		ldi r25,0
 1316 0440 0E94 0000 		call itoa
 1317               	.LVL101:
 1318 0444 0E94 0000 		call uart_puts
 1319               	.LVL102:
1082:main.c        ****     uart_putc('-');
 1320               		.loc 3 1082 0
 1321 0448 8DE2      		ldi r24,lo8(45)
 1322 044a 0E94 0000 		call uart_putc
 1323               	.LVL103:
1083:main.c        ****     
1084:main.c        ****     uart_puts( itoa( day, printBuffer, 10 ) );
 1324               		.loc 3 1084 0
 1325 044e 4AE0      		ldi r20,lo8(10)
 1326 0450 50E0      		ldi r21,0
 1327 0452 60E0      		ldi r22,lo8(printBuffer)
 1328 0454 70E0      		ldi r23,hi8(printBuffer)
 1329 0456 8091 0000 		lds r24,day
 1330 045a 90E0      		ldi r25,0
 1331 045c 0E94 0000 		call itoa
 1332               	.LVL104:
 1333 0460 0E94 0000 		call uart_puts
 1334               	.LVL105:
1085:main.c        ****     
1086:main.c        ****     uart_puts(", ");
 1335               		.loc 3 1086 0
 1336 0464 80E0      		ldi r24,lo8(.LC10)
 1337 0466 90E0      		ldi r25,hi8(.LC10)
 1338 0468 0E94 0000 		call uart_puts
 1339               	.LVL106:
1087:main.c        ****     
1088:main.c        ****     
1089:main.c        ****     if( miltime == 0  && hours > 12 )
 1340               		.loc 3 1089 0
 1341 046c 8091 0000 		lds r24,miltime
 1342 0470 8111      		cpse r24,__zero_reg__
 1343 0472 00C0      		rjmp .L45
 1344               		.loc 3 1089 0 is_stmt 0 discriminator 1
 1345 0474 8091 0000 		lds r24,hours
 1346 0478 8D30      		cpi r24,lo8(13)
 1347 047a 00F0      		brlo .L46
1090:main.c        ****     {
1091:main.c        ****         // Display the hours in 12 hour format.
1092:main.c        ****         uart_puts( itoa( hours - 12, printBuffer, 10 ) );
 1348               		.loc 3 1092 0 is_stmt 1
 1349 047c 90E0      		ldi r25,0
 1350 047e 4AE0      		ldi r20,lo8(10)
 1351 0480 50E0      		ldi r21,0
 1352 0482 60E0      		ldi r22,lo8(printBuffer)
 1353 0484 70E0      		ldi r23,hi8(printBuffer)
 1354 0486 0C97      		sbiw r24,12
 1355 0488 00C0      		rjmp .L48
 1356               	.L46:
1093:main.c        ****     }
1094:main.c        ****     else if( miltime == 0 && hours == 0 )
 1357               		.loc 3 1094 0 discriminator 1
 1358 048a 8111      		cpse r24,__zero_reg__
 1359 048c 00C0      		rjmp .L45
1095:main.c        ****     {
1096:main.c        ****         // Don't display '0' hours in 12-hour format, display "12" instead.
1097:main.c        ****         uart_puts( itoa( 12, printBuffer, 10 ) );
 1360               		.loc 3 1097 0
 1361 048e 4AE0      		ldi r20,lo8(10)
 1362 0490 50E0      		ldi r21,0
 1363 0492 60E0      		ldi r22,lo8(printBuffer)
 1364 0494 70E0      		ldi r23,hi8(printBuffer)
 1365 0496 8CE0      		ldi r24,lo8(12)
 1366 0498 90E0      		ldi r25,0
 1367 049a 00C0      		rjmp .L48
 1368               	.L45:
1098:main.c        ****     }
1099:main.c        ****     else
1100:main.c        ****     {
1101:main.c        ****         // Otherwise, everything is cool, just print the hours.
1102:main.c        ****         uart_puts( itoa( hours, printBuffer, 10 ) );
 1369               		.loc 3 1102 0
 1370 049c 4AE0      		ldi r20,lo8(10)
 1371 049e 50E0      		ldi r21,0
 1372 04a0 60E0      		ldi r22,lo8(printBuffer)
 1373 04a2 70E0      		ldi r23,hi8(printBuffer)
 1374 04a4 8091 0000 		lds r24,hours
 1375 04a8 90E0      		ldi r25,0
 1376               	.L48:
 1377 04aa 0E94 0000 		call itoa
 1378               	.LVL107:
 1379 04ae 0E94 0000 		call uart_puts
 1380               	.LVL108:
1103:main.c        ****     }
1104:main.c        ****     uart_putc(':');
 1381               		.loc 3 1104 0
 1382 04b2 8AE3      		ldi r24,lo8(58)
 1383 04b4 0E94 0000 		call uart_putc
 1384               	.LVL109:
1105:main.c        ****         
1106:main.c        ****     uart_puts( itoa( minutes, printBuffer, 10 ) );
 1385               		.loc 3 1106 0
 1386 04b8 4AE0      		ldi r20,lo8(10)
 1387 04ba 50E0      		ldi r21,0
 1388 04bc 60E0      		ldi r22,lo8(printBuffer)
 1389 04be 70E0      		ldi r23,hi8(printBuffer)
 1390 04c0 8091 0000 		lds r24,minutes
 1391 04c4 90E0      		ldi r25,0
 1392 04c6 0E94 0000 		call itoa
 1393               	.LVL110:
 1394 04ca 0E94 0000 		call uart_puts
 1395               	.LVL111:
1107:main.c        ****     uart_putc(':');
 1396               		.loc 3 1107 0
 1397 04ce 8AE3      		ldi r24,lo8(58)
 1398 04d0 0E94 0000 		call uart_putc
 1399               	.LVL112:
1108:main.c        ****         
1109:main.c        ****     uart_puts( itoa( seconds, printBuffer, 10 ) );
 1400               		.loc 3 1109 0
 1401 04d4 8091 0000 		lds r24,seconds
 1402 04d8 4AE0      		ldi r20,lo8(10)
 1403 04da 50E0      		ldi r21,0
 1404 04dc 60E0      		ldi r22,lo8(printBuffer)
 1405 04de 70E0      		ldi r23,hi8(printBuffer)
 1406 04e0 90E0      		ldi r25,0
 1407 04e2 0E94 0000 		call itoa
 1408               	.LVL113:
 1409 04e6 0E94 0000 		call uart_puts
 1410               	.LVL114:
1110:main.c        ****         
1111:main.c        ****     //uart_puts(RETURN_NEWLINE);
1112:main.c        ****     uart_putc( ',');
 1411               		.loc 3 1112 0
 1412 04ea 8CE2      		ldi r24,lo8(44)
 1413 04ec 0C94 0000 		jmp uart_putc
 1414               	.LVL115:
 1415               		.cfi_endproc
 1416               	.LFE36:
 1418               	.global	isLeapYear
 1420               	isLeapYear:
 1421               	.LFB37:
1113:main.c        **** 
1114:main.c        **** }
1115:main.c        **** 
1116:main.c        **** 
1117:main.c        **** 
1118:main.c        **** 
1119:main.c        **** uint8_t isLeapYear( void )
1120:main.c        **** {
 1422               		.loc 3 1120 0
 1423               		.cfi_startproc
 1424               	/* prologue: function */
 1425               	/* frame size = 0 */
 1426               	/* stack size = 0 */
 1427               	.L__stack_usage = 0
1121:main.c        ****     if( year % 4 != 0 )
 1428               		.loc 3 1121 0
 1429 04f0 2091 0000 		lds r18,year
 1430 04f4 3091 0000 		lds r19,year+1
 1431 04f8 C901      		movw r24,r18
 1432 04fa 8370      		andi r24,3
 1433 04fc 9927      		clr r25
 1434 04fe 892B      		or r24,r25
 1435 0500 01F4      		brne .L52
1122:main.c        ****     {
1123:main.c        ****         return 0;   // not a leap year
1124:main.c        ****     }
1125:main.c        ****     else if( year % 100 != 0 )
 1436               		.loc 3 1125 0
 1437 0502 C901      		movw r24,r18
 1438 0504 64E6      		ldi r22,lo8(100)
 1439 0506 70E0      		ldi r23,0
 1440 0508 0E94 0000 		call __udivmodhi4
 1441 050c 892B      		or r24,r25
 1442 050e 01F4      		brne .L53
1126:main.c        ****     {
1127:main.c        ****         return 1;   // it is a leap year
1128:main.c        ****     }
1129:main.c        ****     else if( year % 400 )
 1443               		.loc 3 1129 0
 1444 0510 C901      		movw r24,r18
 1445 0512 60E9      		ldi r22,lo8(-112)
 1446 0514 71E0      		ldi r23,lo8(1)
 1447 0516 0E94 0000 		call __udivmodhi4
 1448 051a 21E0      		ldi r18,lo8(1)
 1449 051c 892B      		or r24,r25
 1450 051e 01F0      		breq .L50
 1451               	.L52:
1123:main.c        ****         return 0;   // not a leap year
 1452               		.loc 3 1123 0
 1453 0520 20E0      		ldi r18,0
 1454 0522 00C0      		rjmp .L50
 1455               	.L53:
1127:main.c        ****         return 1;   // it is a leap year
 1456               		.loc 3 1127 0
 1457 0524 21E0      		ldi r18,lo8(1)
 1458               	.L50:
1130:main.c        ****     {
1131:main.c        ****         return 0;   // it is not a leap year
1132:main.c        ****     }
1133:main.c        ****     else
1134:main.c        ****     {
1135:main.c        ****         return 1;   // it is a leap year
1136:main.c        ****     }
1137:main.c        **** }
 1459               		.loc 3 1137 0
 1460 0526 822F      		mov r24,r18
 1461 0528 0895      		ret
 1462               		.cfi_endproc
 1463               	.LFE37:
 1465               		.section	.rodata
 1466               	.LC0:
 1467 0000 00        		.byte	0
 1468 0001 1F        		.byte	31
 1469 0002 1C        		.byte	28
 1470 0003 1F        		.byte	31
 1471 0004 1E        		.byte	30
 1472 0005 1F        		.byte	31
 1473 0006 1E        		.byte	30
 1474 0007 1F        		.byte	31
 1475 0008 1F        		.byte	31
 1476 0009 1E        		.byte	30
 1477 000a 1F        		.byte	31
 1478 000b 1E        		.byte	30
 1479 000c 1F        		.byte	31
 1480               		.text
 1481               	.global	updateDateTime
 1483               	updateDateTime:
 1484               	.LFB35:
1024:main.c        **** {
 1485               		.loc 3 1024 0
 1486               		.cfi_startproc
 1487 052a CF93      		push r28
 1488               	.LCFI33:
 1489               		.cfi_def_cfa_offset 3
 1490               		.cfi_offset 28, -2
 1491 052c DF93      		push r29
 1492               	.LCFI34:
 1493               		.cfi_def_cfa_offset 4
 1494               		.cfi_offset 29, -3
 1495 052e CDB7      		in r28,__SP_L__
 1496 0530 DEB7      		in r29,__SP_H__
 1497               	.LCFI35:
 1498               		.cfi_def_cfa_register 28
 1499 0532 2D97      		sbiw r28,13
 1500               	.LCFI36:
 1501               		.cfi_def_cfa_offset 17
 1502 0534 0FB6      		in __tmp_reg__,__SREG__
 1503 0536 F894      		cli
 1504 0538 DEBF      		out __SP_H__,r29
 1505 053a 0FBE      		out __SREG__,__tmp_reg__
 1506 053c CDBF      		out __SP_L__,r28
 1507               	/* prologue: function */
 1508               	/* frame size = 13 */
 1509               	/* stack size = 15 */
 1510               	.L__stack_usage = 15
1025:main.c        ****     uint8_t numDaysInMonth[] = {0,31,28,31,30,31,30,31,31,30,31,30,31};
 1511               		.loc 3 1025 0
 1512 053e 8DE0      		ldi r24,lo8(13)
 1513 0540 E0E0      		ldi r30,lo8(.LC0)
 1514 0542 F0E0      		ldi r31,hi8(.LC0)
 1515 0544 DE01      		movw r26,r28
 1516 0546 1196      		adiw r26,1
 1517               		0:
 1518 0548 0190      		ld r0,Z+
 1519 054a 0D92      		st X+,r0
 1520 054c 8A95      		dec r24
 1521 054e 01F4      		brne 0b
1027:main.c        ****     if( numDaysInMonth[2] == 28 && isLeapYear() )
 1522               		.loc 3 1027 0
 1523 0550 8B81      		ldd r24,Y+3
 1524 0552 8C31      		cpi r24,lo8(28)
 1525 0554 01F4      		brne .L58
1027:main.c        ****     if( numDaysInMonth[2] == 28 && isLeapYear() )
 1526               		.loc 3 1027 0 is_stmt 0 discriminator 1
 1527 0556 0E94 0000 		call isLeapYear
 1528               	.LVL116:
 1529 055a 8823      		tst r24
 1530 055c 01F0      		breq .L59
1029:main.c        ****         numDaysInMonth[2] = 29;
 1531               		.loc 3 1029 0 is_stmt 1
 1532 055e 8DE1      		ldi r24,lo8(29)
 1533 0560 00C0      		rjmp .L68
 1534               	.L58:
1031:main.c        ****     else if( numDaysInMonth[2] == 29 )
 1535               		.loc 3 1031 0
 1536 0562 8D31      		cpi r24,lo8(29)
 1537 0564 01F4      		brne .L59
1033:main.c        ****         numDaysInMonth[2] = 28;
 1538               		.loc 3 1033 0
 1539 0566 8CE1      		ldi r24,lo8(28)
 1540               	.L68:
 1541 0568 8B83      		std Y+3,r24
 1542               	.L59:
1037:main.c        ****     if( seconds > 59 )
 1543               		.loc 3 1037 0
 1544 056a 8091 0000 		lds r24,seconds
 1545 056e 8C33      		cpi r24,lo8(60)
 1546 0570 00F0      		brlo .L60
1039:main.c        ****         minutes++;		// increment minutes
 1547               		.loc 3 1039 0
 1548 0572 8091 0000 		lds r24,minutes
 1549 0576 8F5F      		subi r24,lo8(-(1))
 1550 0578 8093 0000 		sts minutes,r24
1040:main.c        ****         seconds = 0;	// reset seconds
 1551               		.loc 3 1040 0
 1552 057c 1092 0000 		sts seconds,__zero_reg__
 1553               	.L60:
1043:main.c        ****     if( minutes > 59 )
 1554               		.loc 3 1043 0
 1555 0580 8091 0000 		lds r24,minutes
 1556 0584 8C33      		cpi r24,lo8(60)
 1557 0586 00F0      		brlo .L61
1045:main.c        ****         hours++;		// increment hours
 1558               		.loc 3 1045 0
 1559 0588 8091 0000 		lds r24,hours
 1560 058c 8F5F      		subi r24,lo8(-(1))
 1561 058e 8093 0000 		sts hours,r24
1046:main.c        ****         minutes = 0; 	// reset minutes
 1562               		.loc 3 1046 0
 1563 0592 1092 0000 		sts minutes,__zero_reg__
 1564               	.L61:
1049:main.c        ****     if( hours > 23 )
 1565               		.loc 3 1049 0
 1566 0596 8091 0000 		lds r24,hours
 1567 059a 8831      		cpi r24,lo8(24)
 1568 059c 00F0      		brlo .L62
1051:main.c        ****         day++;          // increment day
 1569               		.loc 3 1051 0
 1570 059e 8091 0000 		lds r24,day
 1571 05a2 8F5F      		subi r24,lo8(-(1))
 1572 05a4 8093 0000 		sts day,r24
1052:main.c        ****         hours = 0;		// reset hours
 1573               		.loc 3 1052 0
 1574 05a8 1092 0000 		sts hours,__zero_reg__
 1575               	.L62:
1055:main.c        ****     if( day > numDaysInMonth[ month ] )
 1576               		.loc 3 1055 0
 1577 05ac 8091 0000 		lds r24,month
 1578 05b0 FE01      		movw r30,r28
 1579 05b2 E80F      		add r30,r24
 1580 05b4 F11D      		adc r31,__zero_reg__
 1581 05b6 2091 0000 		lds r18,day
 1582 05ba 9181      		ldd r25,Z+1
 1583 05bc 9217      		cp r25,r18
 1584 05be 00F4      		brsh .L63
1057:main.c        ****         month++;        // increment the month
 1585               		.loc 3 1057 0
 1586 05c0 8F5F      		subi r24,lo8(-(1))
 1587 05c2 8093 0000 		sts month,r24
1058:main.c        ****         day = 1;        // reset the day counter to the first
 1588               		.loc 3 1058 0
 1589 05c6 81E0      		ldi r24,lo8(1)
 1590 05c8 8093 0000 		sts day,r24
 1591               	.L63:
1061:main.c        ****     if( month > 12 )
 1592               		.loc 3 1061 0
 1593 05cc 8091 0000 		lds r24,month
 1594 05d0 8D30      		cpi r24,lo8(13)
 1595 05d2 00F0      		brlo .L57
1063:main.c        ****         year++;         // increment the year
 1596               		.loc 3 1063 0
 1597 05d4 8091 0000 		lds r24,year
 1598 05d8 9091 0000 		lds r25,year+1
 1599 05dc 0196      		adiw r24,1
 1600 05de 9093 0000 		sts year+1,r25
 1601 05e2 8093 0000 		sts year,r24
1064:main.c        ****         month = 1;      // reset the month to january
 1602               		.loc 3 1064 0
 1603 05e6 81E0      		ldi r24,lo8(1)
 1604 05e8 8093 0000 		sts month,r24
 1605               	.L57:
 1606               	/* epilogue start */
1068:main.c        **** }
 1607               		.loc 3 1068 0
 1608 05ec 2D96      		adiw r28,13
 1609 05ee 0FB6      		in __tmp_reg__,__SREG__
 1610 05f0 F894      		cli
 1611 05f2 DEBF      		out __SP_H__,r29
 1612 05f4 0FBE      		out __SREG__,__tmp_reg__
 1613 05f6 CDBF      		out __SP_L__,r28
 1614 05f8 DF91      		pop r29
 1615 05fa CF91      		pop r28
 1616 05fc 0895      		ret
 1617               		.cfi_endproc
 1618               	.LFE35:
 1620               	.global	dayOfWeek
 1622               	dayOfWeek:
 1623               	.LFB38:
1138:main.c        **** 
1139:main.c        **** 
1140:main.c        **** 
1141:main.c        **** 
1142:main.c        **** uint8_t dayOfWeek(uint8_t day, uint8_t month, uint16_t year)
1143:main.c        **** {
 1624               		.loc 3 1143 0
 1625               		.cfi_startproc
 1626               	.LVL117:
 1627 05fe CF93      		push r28
 1628               	.LCFI37:
 1629               		.cfi_def_cfa_offset 3
 1630               		.cfi_offset 28, -2
 1631 0600 DF93      		push r29
 1632               	.LCFI38:
 1633               		.cfi_def_cfa_offset 4
 1634               		.cfi_offset 29, -3
 1635               	/* prologue: function */
 1636               	/* frame size = 0 */
 1637               	/* stack size = 2 */
 1638               	.L__stack_usage = 2
 1639 0602 D82F      		mov r29,r24
 1640 0604 C62F      		mov r28,r22
 1641 0606 FA01      		movw r30,r20
1144:main.c        ****    // http://en.wikipedia.org/wiki/Zeller%27s_congruence
1145:main.c        ****    // returns 0 for monday thru 6 for sunday.
1146:main.c        ****    
1147:main.c        **** 	if( month < 3 ){
 1642               		.loc 3 1147 0
 1643 0608 6330      		cpi r22,lo8(3)
 1644 060a 00F4      		brsh .L70
1148:main.c        **** 		month += 12;
 1645               		.loc 3 1148 0
 1646 060c C45F      		subi r28,lo8(-(12))
 1647               	.LVL118:
1149:main.c        **** 		year--;
 1648               		.loc 3 1149 0
 1649 060e 3197      		sbiw r30,1
 1650               	.LVL119:
 1651               	.L70:
1150:main.c        ****    }
1151:main.c        ****    return ( ( 13 * month + 3 ) / 5 + day + year + ( year / 4 ) - ( year / 100 ) + ( year / 400 ) ) 
 1652               		.loc 3 1151 0
 1653 0610 9F01      		movw r18,r30
 1654 0612 3695      		lsr r19
 1655 0614 2795      		ror r18
 1656 0616 3695      		lsr r19
 1657 0618 2795      		ror r18
 1658               	.LVL120:
 1659 061a CF01      		movw r24,r30
 1660 061c 60E9      		ldi r22,lo8(-112)
 1661 061e 71E0      		ldi r23,lo8(1)
 1662 0620 0E94 0000 		call __udivmodhi4
 1663 0624 260F      		add r18,r22
 1664 0626 371F      		adc r19,r23
 1665 0628 2E0F      		add r18,r30
 1666 062a 3F1F      		adc r19,r31
 1667 062c CF01      		movw r24,r30
 1668 062e 64E6      		ldi r22,lo8(100)
 1669 0630 70E0      		ldi r23,0
 1670 0632 0E94 0000 		call __udivmodhi4
 1671 0636 261B      		sub r18,r22
 1672 0638 370B      		sbc r19,r23
 1673 063a 4DE0      		ldi r20,lo8(13)
 1674 063c C49F      		mul r28,r20
 1675 063e C001      		movw r24,r0
 1676 0640 1124      		clr __zero_reg__
 1677 0642 0396      		adiw r24,3
 1678 0644 65E0      		ldi r22,lo8(5)
 1679 0646 70E0      		ldi r23,0
 1680 0648 0E94 0000 		call __divmodhi4
 1681 064c 6D0F      		add r22,r29
 1682 064e 711D      		adc r23,__zero_reg__
 1683 0650 260F      		add r18,r22
 1684 0652 371F      		adc r19,r23
 1685 0654 C901      		movw r24,r18
 1686 0656 67E0      		ldi r22,lo8(7)
 1687 0658 70E0      		ldi r23,0
 1688 065a 0E94 0000 		call __udivmodhi4
 1689               	/* epilogue start */
1152:main.c        **** }
 1690               		.loc 3 1152 0
 1691 065e DF91      		pop r29
 1692               	.LVL121:
 1693 0660 CF91      		pop r28
 1694               	.LVL122:
 1695 0662 0895      		ret
 1696               		.cfi_endproc
 1697               	.LFE38:
 1699               	.global	readTemperature
 1701               	readTemperature:
 1702               	.LFB39:
1153:main.c        **** 
1154:main.c        **** 
1155:main.c        **** 
1156:main.c        **** 
1157:main.c        **** double readTemperature( void )
1158:main.c        **** {
 1703               		.loc 3 1158 0
 1704               		.cfi_startproc
 1705               	/* prologue: function */
 1706               	/* frame size = 0 */
 1707               	/* stack size = 0 */
 1708               	.L__stack_usage = 0
1159:main.c        ****     celsiusTemperature = ds18b20_gettemp();
 1709               		.loc 3 1159 0
 1710 0664 0E94 0000 		call ds18b20_gettemp
 1711               	.LVL123:
 1712 0668 9B01      		movw r18,r22
 1713 066a 462F      		mov r20,r22
 1714 066c 532F      		mov r21,r19
 1715 066e 682F      		mov r22,r24
 1716 0670 792F      		mov r23,r25
 1717 0672 4093 0000 		sts celsiusTemperature,r20
 1718 0676 5093 0000 		sts celsiusTemperature+1,r21
 1719 067a 6093 0000 		sts celsiusTemperature+2,r22
 1720 067e 7093 0000 		sts celsiusTemperature+3,r23
1160:main.c        ****     
1161:main.c        ****     return celsiusTemperature;
1162:main.c        **** }
 1721               		.loc 3 1162 0
 1722 0682 622F      		mov r22,r18
 1723 0684 732F      		mov r23,r19
 1724 0686 0895      		ret
 1725               		.cfi_endproc
 1726               	.LFE39:
 1728               	.global	updateBoostConverter
 1730               	updateBoostConverter:
 1731               	.LFB40:
1163:main.c        **** 
1164:main.c        **** 
1165:main.c        **** 
1166:main.c        **** 
1167:main.c        **** void updateBoostConverter( void )
1168:main.c        **** {
 1732               		.loc 3 1168 0
 1733               		.cfi_startproc
 1734               	/* prologue: function */
 1735               	/* frame size = 0 */
 1736               	/* stack size = 0 */
 1737               	.L__stack_usage = 0
1169:main.c        **** 
1170:main.c        ****     // The input to HV_FEEDBACK is a voltage divider with 470k0 and 4k7 resistors.
1171:main.c        ****     // Therefore the voltage present will be about 10% of the boost converter output.
1172:main.c        ****     // 175 V DC on the boost converter will be about 1.75 V DC input to the ADC
1173:main.c        ****     
1174:main.c        ****     // The ADC results are continuously stored as 8-bit results in array location adc_raw[1]
1175:main.c        ****     // 5 v / 8 bits = ~0.019685 V/count, or 50.8 counts/V
1176:main.c        ****     
1177:main.c        ****     // ex. 50 V on the boost converter is 0.5 V to the ADC.  0.5 V in counts is 25.4
1178:main.c        ****     //    175 V on the boost converter is 1.75V to the ADC.  1.75V in counts is 88.9
1179:main.c        ****     
1180:main.c        ****     uint16_t myVoltage = adc_raw[1];	// HV_FEEDBACK
 1738               		.loc 3 1180 0
 1739 0688 8091 0000 		lds r24,adc_raw+1
 1740               	.LVL124:
1181:main.c        ****     
1182:main.c        **** 	if( myVoltage > 89 )
 1741               		.loc 3 1182 0
 1742 068c 8A35      		cpi r24,lo8(90)
 1743 068e 00F0      		brlo .L73
1183:main.c        **** 	{
1184:main.c        **** 		boostConverterPwm = boostLowPwm;
 1744               		.loc 3 1184 0
 1745 0690 8091 0000 		lds r24,boostLowPwm
 1746               	.LVL125:
 1747 0694 00C0      		rjmp .L75
 1748               	.LVL126:
 1749               	.L73:
1185:main.c        **** 		//boostConverterPwm--;
1186:main.c        **** 	}
1187:main.c        **** 	else 
1188:main.c        **** 	{
1189:main.c        **** 		boostConverterPwm = boostHighPwm;
 1750               		.loc 3 1189 0
 1751 0696 8091 0000 		lds r24,boostHighPwm
 1752               	.LVL127:
 1753               	.L75:
 1754 069a 8093 0000 		sts boostConverterPwm,r24
1190:main.c        **** 		//boostConverterPwm++;
1191:main.c        **** 	}
1192:main.c        **** 	
1193:main.c        **** 	OCR0A = boostConverterPwm;        
 1755               		.loc 3 1193 0
 1756 069e 8091 0000 		lds r24,boostConverterPwm
 1757 06a2 87BD      		out 0x27,r24
 1758 06a4 0895      		ret
 1759               		.cfi_endproc
 1760               	.LFE40:
 1762               	.global	__divsf3
 1763               	.global	updateTemperatureFilter
 1765               	updateTemperatureFilter:
 1766               	.LFB41:
1194:main.c        **** 
1195:main.c        **** }
1196:main.c        **** 
1197:main.c        **** 
1198:main.c        **** 
1199:main.c        **** 
1200:main.c        **** 
1201:main.c        **** 
1202:main.c        **** void updateTemperatureFilter( uint8_t moduloSeconds )
1203:main.c        **** {
 1767               		.loc 3 1203 0
 1768               		.cfi_startproc
 1769               	.LVL128:
 1770 06a6 0F93      		push r16
 1771               	.LCFI39:
 1772               		.cfi_def_cfa_offset 3
 1773               		.cfi_offset 16, -2
 1774 06a8 1F93      		push r17
 1775               	.LCFI40:
 1776               		.cfi_def_cfa_offset 4
 1777               		.cfi_offset 17, -3
 1778 06aa CF93      		push r28
 1779               	.LCFI41:
 1780               		.cfi_def_cfa_offset 5
 1781               		.cfi_offset 28, -4
 1782 06ac DF93      		push r29
 1783               	.LCFI42:
 1784               		.cfi_def_cfa_offset 6
 1785               		.cfi_offset 29, -5
 1786               	/* prologue: function */
 1787               	/* frame size = 0 */
 1788               	/* stack size = 4 */
 1789               	.L__stack_usage = 4
 1790 06ae 682F      		mov r22,r24
1204:main.c        **** 	if( seconds % moduloSeconds == 0 )
 1791               		.loc 3 1204 0
 1792 06b0 8091 0000 		lds r24,seconds
 1793               	.LVL129:
 1794 06b4 0E94 0000 		call __udivmodqi4
 1795 06b8 9111      		cpse r25,__zero_reg__
 1796 06ba 00C0      		rjmp .L76
 1797 06bc 00E0      		ldi r16,lo8(movingAverageArray)
 1798 06be 10E0      		ldi r17,hi8(movingAverageArray)
 1799 06c0 C0E0      		ldi r28,0
 1800 06c2 D0E0      		ldi r29,0
 1801               	.LVL130:
 1802               	.L80:
 1803               	.LBB219:
1205:main.c        ****     {
1206:main.c        ****             
1207:main.c        ****         // FIR
1208:main.c        ****             
1209:main.c        ****         for( int i = 0; i < TEMPERATURE_ARRAY_SIZE; i++ )
1210:main.c        ****         {
1211:main.c        ****             if( i < TEMPERATURE_ARRAY_SIZE - 1 )
 1804               		.loc 3 1211 0
 1805 06c4 C530      		cpi r28,5
 1806 06c6 D105      		cpc r29,__zero_reg__
 1807 06c8 01F0      		breq .L78
1212:main.c        ****             {
1213:main.c        ****                 movingAverageArray[ i ] = movingAverageArray[ i + 1 ];
 1808               		.loc 3 1213 0
 1809 06ca F801      		movw r30,r16
 1810 06cc 8481      		ldd r24,Z+4
 1811 06ce 9581      		ldd r25,Z+5
 1812 06d0 A681      		ldd r26,Z+6
 1813 06d2 B781      		ldd r27,Z+7
 1814 06d4 8083      		st Z,r24
 1815 06d6 9183      		std Z+1,r25
 1816 06d8 A283      		std Z+2,r26
 1817 06da B383      		std Z+3,r27
 1818 06dc 00C0      		rjmp .L79
 1819               	.L78:
1214:main.c        ****             }
1215:main.c        ****             else
1216:main.c        ****             {
1217:main.c        ****                 movingAverageArray[ i ] = readTemperature();
 1820               		.loc 3 1217 0
 1821 06de 0E94 0000 		call readTemperature
 1822               	.LVL131:
 1823 06e2 6093 0000 		sts movingAverageArray+20,r22
 1824 06e6 7093 0000 		sts movingAverageArray+20+1,r23
 1825 06ea 8093 0000 		sts movingAverageArray+20+2,r24
 1826 06ee 9093 0000 		sts movingAverageArray+20+3,r25
 1827               	.L79:
1209:main.c        ****         for( int i = 0; i < TEMPERATURE_ARRAY_SIZE; i++ )
 1828               		.loc 3 1209 0
 1829 06f2 2196      		adiw r28,1
 1830               	.LVL132:
 1831 06f4 0C5F      		subi r16,-4
 1832 06f6 1F4F      		sbci r17,-1
 1833 06f8 C630      		cpi r28,6
 1834 06fa D105      		cpc r29,__zero_reg__
 1835 06fc 01F4      		brne .L80
 1836               	.LVL133:
 1837 06fe C0E0      		ldi r28,lo8(movingAverageArray)
 1838 0700 D0E0      		ldi r29,hi8(movingAverageArray)
 1839               	.LVL134:
 1840               	.LBE219:
1202:main.c        **** void updateTemperatureFilter( uint8_t moduloSeconds )
 1841               		.loc 3 1202 0
 1842 0702 F0E0      		ldi r31,0
 1843 0704 E0E0      		ldi r30,0
 1844 0706 80E0      		ldi r24,0
 1845 0708 90E0      		ldi r25,0
 1846               	.LVL135:
 1847               	.L81:
 1848               	.LBB220:
1218:main.c        ****             }
1219:main.c        ****                 
1220:main.c        ****         }
1221:main.c        ****             
1222:main.c        ****         arraySum = 0;
1223:main.c        ****             
1224:main.c        ****         for( int i = 0; i < TEMPERATURE_ARRAY_SIZE; i++ )
1225:main.c        ****         {
1226:main.c        ****             arraySum += movingAverageArray[ i ];
 1849               		.loc 3 1226 0 discriminator 2
 1850 070a 2991      		ld r18,Y+
 1851 070c 3991      		ld r19,Y+
 1852 070e 4991      		ld r20,Y+
 1853 0710 5991      		ld r21,Y+
 1854 0712 0F2F      		mov r16,r31
 1855 0714 1E2F      		mov r17,r30
 1856 0716 B801      		movw r22,r16
 1857 0718 0E94 0000 		call __addsf3
 1858               	.LVL136:
 1859 071c F62F      		mov r31,r22
 1860 071e E72F      		mov r30,r23
1224:main.c        ****         for( int i = 0; i < TEMPERATURE_ARRAY_SIZE; i++ )
 1861               		.loc 3 1224 0 discriminator 2
 1862 0720 20E0      		ldi r18,hi8(movingAverageArray+24)
 1863 0722 C030      		cpi r28,lo8(movingAverageArray+24)
 1864 0724 D207      		cpc r29,r18
 1865 0726 01F4      		brne .L81
 1866 0728 DF01      		movw r26,r30
 1867 072a 4B2F      		mov r20,r27
 1868 072c 5A2F      		mov r21,r26
 1869 072e 682F      		mov r22,r24
 1870 0730 792F      		mov r23,r25
 1871 0732 4093 0000 		sts arraySum,r20
 1872 0736 5093 0000 		sts arraySum+1,r21
 1873 073a 6093 0000 		sts arraySum+2,r22
 1874 073e 7093 0000 		sts arraySum+3,r23
 1875               	.LBE220:
1227:main.c        ****         }
1228:main.c        ****             
1229:main.c        **** 		averageCelsiusTemperature = arraySum / TEMPERATURE_ARRAY_SIZE;       
 1876               		.loc 3 1229 0
 1877 0742 20E0      		ldi r18,0
 1878 0744 30E0      		ldi r19,0
 1879 0746 40EC      		ldi r20,lo8(-64)
 1880 0748 50E4      		ldi r21,lo8(64)
 1881 074a EF01      		movw r28,r30
 1882 074c 6D2F      		mov r22,r29
 1883 074e 7C2F      		mov r23,r28
 1884 0750 0E94 0000 		call __divsf3
 1885               	.LVL137:
 1886 0754 6093 0000 		sts averageCelsiusTemperature,r22
 1887 0758 7093 0000 		sts averageCelsiusTemperature+1,r23
 1888 075c 8093 0000 		sts averageCelsiusTemperature+2,r24
 1889 0760 9093 0000 		sts averageCelsiusTemperature+3,r25
 1890               	.L76:
 1891               	/* epilogue start */
1230:main.c        ****     }
1231:main.c        **** }
 1892               		.loc 3 1231 0
 1893 0764 DF91      		pop r29
 1894 0766 CF91      		pop r28
 1895 0768 1F91      		pop r17
 1896 076a 0F91      		pop r16
 1897 076c 0895      		ret
 1898               		.cfi_endproc
 1899               	.LFE41:
 1901               	.global	serialPrintTemperature
 1903               	serialPrintTemperature:
 1904               	.LFB42:
1232:main.c        **** 
1233:main.c        **** 
1234:main.c        **** 
1235:main.c        **** 
1236:main.c        **** void serialPrintTemperature( void )
1237:main.c        **** {
 1905               		.loc 3 1237 0
 1906               		.cfi_startproc
 1907 076e 0F93      		push r16
 1908               	.LCFI43:
 1909               		.cfi_def_cfa_offset 3
 1910               		.cfi_offset 16, -2
 1911 0770 1F93      		push r17
 1912               	.LCFI44:
 1913               		.cfi_def_cfa_offset 4
 1914               		.cfi_offset 17, -3
 1915               	/* prologue: function */
 1916               	/* frame size = 0 */
 1917               	/* stack size = 2 */
 1918               	.L__stack_usage = 2
1238:main.c        **** 	if( celsius == 1 )
 1919               		.loc 3 1238 0
 1920 0772 8091 0000 		lds r24,celsius
 1921 0776 8130      		cpi r24,lo8(1)
 1922 0778 01F4      		brne .L85
1239:main.c        ****         {
1240:main.c        ****             //dtostrf(readTemperature(), 10, 3, printBuffer);
1241:main.c        ****             dtostrf(averageCelsiusTemperature, 10, 3, printBuffer);
 1923               		.loc 3 1241 0
 1924 077a 6091 0000 		lds r22,averageCelsiusTemperature
 1925 077e 7091 0000 		lds r23,averageCelsiusTemperature+1
 1926 0782 8091 0000 		lds r24,averageCelsiusTemperature+2
 1927 0786 9091 0000 		lds r25,averageCelsiusTemperature+3
 1928 078a 00C0      		rjmp .L87
 1929               	.L85:
 1930               	.LVL138:
 1931               	.LBB221:
1242:main.c        **** 
1243:main.c        ****             //uart_puts(", Temperature: ");
1244:main.c        ****             //uart_putc( ',');
1245:main.c        ****             uart_puts(printBuffer); //uart_puts( RETURN_NEWLINE );
1246:main.c        ****         }
1247:main.c        ****         else
1248:main.c        ****         {
1249:main.c        ****             //double tempF = ( readTemperature() * 1.8 ) + 32;
1250:main.c        ****             double tempF = ( averageCelsiusTemperature * 1.8 ) + 32;
 1932               		.loc 3 1250 0
 1933 078c 26E6      		ldi r18,lo8(102)
 1934 078e 36E6      		ldi r19,lo8(102)
 1935 0790 46EE      		ldi r20,lo8(-26)
 1936 0792 5FE3      		ldi r21,lo8(63)
 1937 0794 6091 0000 		lds r22,averageCelsiusTemperature
 1938 0798 7091 0000 		lds r23,averageCelsiusTemperature+1
 1939 079c 8091 0000 		lds r24,averageCelsiusTemperature+2
 1940 07a0 9091 0000 		lds r25,averageCelsiusTemperature+3
 1941 07a4 0E94 0000 		call __mulsf3
 1942               	.LVL139:
 1943 07a8 20E0      		ldi r18,0
 1944 07aa 30E0      		ldi r19,0
 1945 07ac 40E0      		ldi r20,0
 1946 07ae 52E4      		ldi r21,lo8(66)
 1947 07b0 0E94 0000 		call __addsf3
 1948               	.LVL140:
 1949               	.L87:
1251:main.c        ****             dtostrf(tempF , 10, 3, printBuffer);
 1950               		.loc 3 1251 0
 1951 07b4 00E0      		ldi r16,lo8(printBuffer)
 1952 07b6 10E0      		ldi r17,hi8(printBuffer)
 1953 07b8 23E0      		ldi r18,lo8(3)
 1954 07ba 4AE0      		ldi r20,lo8(10)
 1955 07bc 0E94 0000 		call dtostrf
 1956               	.LVL141:
1252:main.c        ****             //uart_puts(", Temperature: ");
1253:main.c        ****             //uart_putc(',');
1254:main.c        ****             uart_puts(printBuffer); //uart_puts( RETURN_NEWLINE );
 1957               		.loc 3 1254 0
 1958 07c0 C801      		movw r24,r16
 1959 07c2 0E94 0000 		call uart_puts
 1960               	.LVL142:
 1961               	.LBE221:
1255:main.c        ****     }
1256:main.c        ****     
1257:main.c        ****     uart_putc( ',');
 1962               		.loc 3 1257 0
 1963 07c6 8CE2      		ldi r24,lo8(44)
 1964               	/* epilogue start */
1258:main.c        **** }
 1965               		.loc 3 1258 0
 1966 07c8 1F91      		pop r17
 1967 07ca 0F91      		pop r16
1257:main.c        ****     uart_putc( ',');
 1968               		.loc 3 1257 0
 1969 07cc 0C94 0000 		jmp uart_putc
 1970               	.LVL143:
 1971               		.cfi_endproc
 1972               	.LFE42:
 1974               	.global	serialPrintAcFrequency
 1976               	serialPrintAcFrequency:
 1977               	.LFB43:
1259:main.c        **** 
1260:main.c        **** 
1261:main.c        **** 
1262:main.c        **** 
1263:main.c        **** 
1264:main.c        **** void serialPrintAcFrequency( void )
1265:main.c        **** {
 1978               		.loc 3 1265 0
 1979               		.cfi_startproc
 1980 07d0 0F93      		push r16
 1981               	.LCFI45:
 1982               		.cfi_def_cfa_offset 3
 1983               		.cfi_offset 16, -2
 1984 07d2 1F93      		push r17
 1985               	.LCFI46:
 1986               		.cfi_def_cfa_offset 4
 1987               		.cfi_offset 17, -3
 1988               	/* prologue: function */
 1989               	/* frame size = 0 */
 1990               	/* stack size = 2 */
 1991               	.L__stack_usage = 2
1266:main.c        **** 	dtostrf(acFrequency, 10, 3, printBuffer);
 1992               		.loc 3 1266 0
 1993 07d4 6091 0000 		lds r22,acFrequency
 1994 07d8 7091 0000 		lds r23,acFrequency+1
 1995 07dc 8091 0000 		lds r24,acFrequency+2
 1996 07e0 9091 0000 		lds r25,acFrequency+3
 1997 07e4 00E0      		ldi r16,lo8(printBuffer)
 1998 07e6 10E0      		ldi r17,hi8(printBuffer)
 1999 07e8 23E0      		ldi r18,lo8(3)
 2000 07ea 4AE0      		ldi r20,lo8(10)
 2001 07ec 0E94 0000 		call dtostrf
 2002               	.LVL144:
1267:main.c        **** 	uart_puts(printBuffer); //uart_puts( RETURN_NEWLINE );
 2003               		.loc 3 1267 0
 2004 07f0 C801      		movw r24,r16
 2005 07f2 0E94 0000 		call uart_puts
 2006               	.LVL145:
1268:main.c        **** 	uart_putc( ',');	
 2007               		.loc 3 1268 0
 2008 07f6 8CE2      		ldi r24,lo8(44)
 2009               	/* epilogue start */
1269:main.c        **** }
 2010               		.loc 3 1269 0
 2011 07f8 1F91      		pop r17
 2012 07fa 0F91      		pop r16
1268:main.c        **** 	uart_putc( ',');	
 2013               		.loc 3 1268 0
 2014 07fc 0C94 0000 		jmp uart_putc
 2015               	.LVL146:
 2016               		.cfi_endproc
 2017               	.LFE43:
 2019               	.global	readEepromToVars
 2021               	readEepromToVars:
 2022               	.LFB44:
1270:main.c        **** 
1271:main.c        **** 
1272:main.c        **** 
1273:main.c        **** 
1274:main.c        **** 
1275:main.c        **** 
1276:main.c        **** 
1277:main.c        **** void readEepromToVars( void )
1278:main.c        **** {
 2023               		.loc 3 1278 0
 2024               		.cfi_startproc
 2025               	/* prologue: function */
 2026               	/* frame size = 0 */
 2027               	/* stack size = 0 */
 2028               	.L__stack_usage = 0
1279:main.c        **** 	
1280:main.c        **** 	mscal = eeprom_read_dword( &ee_mscal );	
 2029               		.loc 3 1280 0
 2030 0800 80E0      		ldi r24,lo8(ee_mscal)
 2031 0802 90E0      		ldi r25,hi8(ee_mscal)
 2032 0804 0E94 0000 		call __eerd_dword_m328p
 2033               	.LVL147:
 2034 0808 6093 0000 		sts mscal,r22
 2035 080c 7093 0000 		sts mscal+1,r23
 2036 0810 8093 0000 		sts mscal+2,r24
 2037 0814 9093 0000 		sts mscal+3,r25
1281:main.c        **** 	nixiesleepstart = eeprom_read_dword( &ee_nixiesleepstart );
 2038               		.loc 3 1281 0
 2039 0818 80E0      		ldi r24,lo8(ee_nixiesleepstart)
 2040 081a 90E0      		ldi r25,hi8(ee_nixiesleepstart)
 2041 081c 0E94 0000 		call __eerd_dword_m328p
 2042               	.LVL148:
 2043 0820 6093 0000 		sts nixiesleepstart,r22
 2044 0824 7093 0000 		sts nixiesleepstart+1,r23
 2045 0828 8093 0000 		sts nixiesleepstart+2,r24
 2046 082c 9093 0000 		sts nixiesleepstart+3,r25
1282:main.c        **** 	nixiesleepend = eeprom_read_dword( &ee_nixiesleepend );
 2047               		.loc 3 1282 0
 2048 0830 80E0      		ldi r24,lo8(ee_nixiesleepend)
 2049 0832 90E0      		ldi r25,hi8(ee_nixiesleepend)
 2050 0834 0E94 0000 		call __eerd_dword_m328p
 2051               	.LVL149:
 2052 0838 6093 0000 		sts nixiesleepend,r22
 2053 083c 7093 0000 		sts nixiesleepend+1,r23
 2054 0840 8093 0000 		sts nixiesleepend+2,r24
 2055 0844 9093 0000 		sts nixiesleepend+3,r25
1283:main.c        **** 	
1284:main.c        **** 	miltime = eeprom_read_byte( &ee_miltime );
 2056               		.loc 3 1284 0
 2057 0848 80E0      		ldi r24,lo8(ee_miltime)
 2058 084a 90E0      		ldi r25,hi8(ee_miltime)
 2059 084c 0E94 0000 		call __eerd_byte_m328p
 2060               	.LVL150:
 2061 0850 8093 0000 		sts miltime,r24
1285:main.c        **** 	showtherm = eeprom_read_byte( &ee_showtherm );
 2062               		.loc 3 1285 0
 2063 0854 80E0      		ldi r24,lo8(ee_showtherm)
 2064 0856 90E0      		ldi r25,hi8(ee_showtherm)
 2065 0858 0E94 0000 		call __eerd_byte_m328p
 2066               	.LVL151:
 2067 085c 8093 0000 		sts showtherm,r24
1286:main.c        **** 	showfreq = eeprom_read_byte( &ee_showfreq );
 2068               		.loc 3 1286 0
 2069 0860 80E0      		ldi r24,lo8(ee_showfreq)
 2070 0862 90E0      		ldi r25,hi8(ee_showfreq)
 2071 0864 0E94 0000 		call __eerd_byte_m328p
 2072               	.LVL152:
 2073 0868 8093 0000 		sts showfreq,r24
1287:main.c        **** 	showdate = eeprom_read_byte( &ee_showdate );
 2074               		.loc 3 1287 0
 2075 086c 80E0      		ldi r24,lo8(ee_showdate)
 2076 086e 90E0      		ldi r25,hi8(ee_showdate)
 2077 0870 0E94 0000 		call __eerd_byte_m328p
 2078               	.LVL153:
 2079 0874 8093 0000 		sts showdate,r24
1288:main.c        **** 	celsius = eeprom_read_byte( &ee_celsius );
 2080               		.loc 3 1288 0
 2081 0878 80E0      		ldi r24,lo8(ee_celsius)
 2082 087a 90E0      		ldi r25,hi8(ee_celsius)
 2083 087c 0E94 0000 		call __eerd_byte_m328p
 2084               	.LVL154:
 2085 0880 8093 0000 		sts celsius,r24
1289:main.c        **** 	doecho = eeprom_read_byte( &ee_doecho );
 2086               		.loc 3 1289 0
 2087 0884 80E0      		ldi r24,lo8(ee_doecho)
 2088 0886 90E0      		ldi r25,hi8(ee_doecho)
 2089 0888 0E94 0000 		call __eerd_byte_m328p
 2090               	.LVL155:
 2091 088c 8093 0000 		sts doecho,r24
1290:main.c        **** 	acclock = eeprom_read_byte( &ee_acclock );
 2092               		.loc 3 1290 0
 2093 0890 80E0      		ldi r24,lo8(ee_acclock)
 2094 0892 90E0      		ldi r25,hi8(ee_acclock)
 2095 0894 0E94 0000 		call __eerd_byte_m328p
 2096               	.LVL156:
 2097 0898 8093 0000 		sts acclock,r24
1291:main.c        **** 	xtalisfast = eeprom_read_byte( &ee_xtalisfast );
 2098               		.loc 3 1291 0
 2099 089c 80E0      		ldi r24,lo8(ee_xtalisfast)
 2100 089e 90E0      		ldi r25,hi8(ee_xtalisfast)
 2101 08a0 0E94 0000 		call __eerd_byte_m328p
 2102               	.LVL157:
 2103 08a4 8093 0000 		sts xtalisfast,r24
1292:main.c        **** 	toggleled = eeprom_read_byte( &ee_toggleled );
 2104               		.loc 3 1292 0
 2105 08a8 80E0      		ldi r24,lo8(ee_toggleled)
 2106 08aa 90E0      		ldi r25,hi8(ee_toggleled)
 2107 08ac 0E94 0000 		call __eerd_byte_m328p
 2108               	.LVL158:
 2109 08b0 8093 0000 		sts toggleled,r24
 2110 08b4 0895      		ret
 2111               		.cfi_endproc
 2112               	.LFE44:
 2114               	.global	updateVarsToEeprom
 2116               	updateVarsToEeprom:
 2117               	.LFB45:
1293:main.c        **** 
1294:main.c        **** }
1295:main.c        **** 
1296:main.c        **** 
1297:main.c        **** 
1298:main.c        **** 
1299:main.c        **** 
1300:main.c        **** // Update will only write data to eeprom if the new value is different from the stored value.
1301:main.c        **** void updateVarsToEeprom( void )
1302:main.c        **** {
 2118               		.loc 3 1302 0
 2119               		.cfi_startproc
 2120               	/* prologue: function */
 2121               	/* frame size = 0 */
 2122               	/* stack size = 0 */
 2123               	.L__stack_usage = 0
1303:main.c        **** 
1304:main.c        **** 	eeprom_update_dword( &ee_mscal, mscal );
 2124               		.loc 3 1304 0
 2125 08b6 4091 0000 		lds r20,mscal
 2126 08ba 5091 0000 		lds r21,mscal+1
 2127 08be 6091 0000 		lds r22,mscal+2
 2128 08c2 7091 0000 		lds r23,mscal+3
 2129 08c6 80E0      		ldi r24,lo8(ee_mscal)
 2130 08c8 90E0      		ldi r25,hi8(ee_mscal)
 2131 08ca 0E94 0000 		call __eeupd_dword_m328p
 2132               	.LVL159:
1305:main.c        **** 	eeprom_update_dword( &ee_nixiesleepstart, nixiesleepstart );
 2133               		.loc 3 1305 0
 2134 08ce 4091 0000 		lds r20,nixiesleepstart
 2135 08d2 5091 0000 		lds r21,nixiesleepstart+1
 2136 08d6 6091 0000 		lds r22,nixiesleepstart+2
 2137 08da 7091 0000 		lds r23,nixiesleepstart+3
 2138 08de 80E0      		ldi r24,lo8(ee_nixiesleepstart)
 2139 08e0 90E0      		ldi r25,hi8(ee_nixiesleepstart)
 2140 08e2 0E94 0000 		call __eeupd_dword_m328p
 2141               	.LVL160:
1306:main.c        **** 	eeprom_update_dword( &ee_nixiesleepend, nixiesleepend );
 2142               		.loc 3 1306 0
 2143 08e6 4091 0000 		lds r20,nixiesleepend
 2144 08ea 5091 0000 		lds r21,nixiesleepend+1
 2145 08ee 6091 0000 		lds r22,nixiesleepend+2
 2146 08f2 7091 0000 		lds r23,nixiesleepend+3
 2147 08f6 80E0      		ldi r24,lo8(ee_nixiesleepend)
 2148 08f8 90E0      		ldi r25,hi8(ee_nixiesleepend)
 2149 08fa 0E94 0000 		call __eeupd_dword_m328p
 2150               	.LVL161:
1307:main.c        **** 	
1308:main.c        **** 	eeprom_update_byte( &ee_miltime, miltime );
 2151               		.loc 3 1308 0
 2152 08fe 6091 0000 		lds r22,miltime
 2153 0902 80E0      		ldi r24,lo8(ee_miltime)
 2154 0904 90E0      		ldi r25,hi8(ee_miltime)
 2155 0906 0E94 0000 		call __eeupd_byte_m328p
 2156               	.LVL162:
1309:main.c        **** 	eeprom_update_byte( &ee_showtherm, showtherm );
 2157               		.loc 3 1309 0
 2158 090a 6091 0000 		lds r22,showtherm
 2159 090e 80E0      		ldi r24,lo8(ee_showtherm)
 2160 0910 90E0      		ldi r25,hi8(ee_showtherm)
 2161 0912 0E94 0000 		call __eeupd_byte_m328p
 2162               	.LVL163:
1310:main.c        **** 	eeprom_update_byte( &ee_showfreq, showfreq );
 2163               		.loc 3 1310 0
 2164 0916 6091 0000 		lds r22,showfreq
 2165 091a 80E0      		ldi r24,lo8(ee_showfreq)
 2166 091c 90E0      		ldi r25,hi8(ee_showfreq)
 2167 091e 0E94 0000 		call __eeupd_byte_m328p
 2168               	.LVL164:
1311:main.c        **** 	eeprom_update_byte( &ee_showdate, showdate );
 2169               		.loc 3 1311 0
 2170 0922 6091 0000 		lds r22,showdate
 2171 0926 80E0      		ldi r24,lo8(ee_showdate)
 2172 0928 90E0      		ldi r25,hi8(ee_showdate)
 2173 092a 0E94 0000 		call __eeupd_byte_m328p
 2174               	.LVL165:
1312:main.c        **** 	eeprom_update_byte( &ee_celsius, celsius );
 2175               		.loc 3 1312 0
 2176 092e 6091 0000 		lds r22,celsius
 2177 0932 80E0      		ldi r24,lo8(ee_celsius)
 2178 0934 90E0      		ldi r25,hi8(ee_celsius)
 2179 0936 0E94 0000 		call __eeupd_byte_m328p
 2180               	.LVL166:
1313:main.c        **** 	eeprom_update_byte( &ee_doecho, doecho );
 2181               		.loc 3 1313 0
 2182 093a 6091 0000 		lds r22,doecho
 2183 093e 80E0      		ldi r24,lo8(ee_doecho)
 2184 0940 90E0      		ldi r25,hi8(ee_doecho)
 2185 0942 0E94 0000 		call __eeupd_byte_m328p
 2186               	.LVL167:
1314:main.c        **** 	eeprom_update_byte( &ee_acclock, acclock );
 2187               		.loc 3 1314 0
 2188 0946 6091 0000 		lds r22,acclock
 2189 094a 80E0      		ldi r24,lo8(ee_acclock)
 2190 094c 90E0      		ldi r25,hi8(ee_acclock)
 2191 094e 0E94 0000 		call __eeupd_byte_m328p
 2192               	.LVL168:
1315:main.c        **** 	eeprom_update_byte( &ee_xtalisfast, xtalisfast );
 2193               		.loc 3 1315 0
 2194 0952 6091 0000 		lds r22,xtalisfast
 2195 0956 80E0      		ldi r24,lo8(ee_xtalisfast)
 2196 0958 90E0      		ldi r25,hi8(ee_xtalisfast)
 2197 095a 0E94 0000 		call __eeupd_byte_m328p
 2198               	.LVL169:
1316:main.c        **** 	eeprom_update_byte( &ee_toggleled, toggleled );
 2199               		.loc 3 1316 0
 2200 095e 6091 0000 		lds r22,toggleled
 2201 0962 80E0      		ldi r24,lo8(ee_toggleled)
 2202 0964 90E0      		ldi r25,hi8(ee_toggleled)
 2203 0966 0C94 0000 		jmp __eeupd_byte_m328p
 2204               	.LVL170:
 2205               		.cfi_endproc
 2206               	.LFE45:
 2208               		.section	.rodata.str1.1
 2209               	.LC11:
 2210 012d 686F 7572 		.string	"hours"
 2210      7300 
 2211               	.LC12:
 2212 0133 3F00      		.string	"?"
 2213               	.LC13:
 2214 0135 486F 7572 		.string	"Hours"
 2214      7300 
 2215               	.LC14:
 2216 013b 3D00      		.string	"="
 2217               	.LC15:
 2218 013d 6D69 6E75 		.string	"minutes"
 2218      7465 7300 
 2219               	.LC16:
 2220 0145 4D69 6E75 		.string	"Minutes"
 2220      7465 7300 
 2221               	.LC17:
 2222 014d 7365 636F 		.string	"seconds"
 2222      6E64 7300 
 2223               	.LC18:
 2224 0155 5365 636F 		.string	"Seconds"
 2224      6E64 7300 
 2225               	.LC19:
 2226 015d 6D73 6361 		.string	"mscal"
 2226      6C00 
 2227               	.LC20:
 2228 0163 6D53 2043 		.string	"mS Calibration"
 2228      616C 6962 
 2228      7261 7469 
 2228      6F6E 00
 2229               	.LC21:
 2230 0172 6D69 6C74 		.string	"miltime"
 2230      696D 6500 
 2231               	.LC22:
 2232 017a 4D49 4C20 		.string	"MIL Time"
 2232      5469 6D65 
 2232      00
 2233               	.LC23:
 2234 0183 7965 6172 		.string	"year"
 2234      00
 2235               	.LC24:
 2236 0188 5965 6172 		.string	"Year"
 2236      00
 2237               	.LC25:
 2238 018d 6D6F 6E74 		.string	"month"
 2238      6800 
 2239               	.LC26:
 2240 0193 4D6F 6E74 		.string	"Month"
 2240      6800 
 2241               	.LC27:
 2242 0199 6461 7900 		.string	"day"
 2243               	.LC28:
 2244 019d 4461 7900 		.string	"Day"
 2245               	.LC29:
 2246 01a1 6365 6C73 		.string	"celsius"
 2246      6975 7300 
 2247               	.LC30:
 2248 01a9 4365 6C73 		.string	"Celsius"
 2248      6975 7300 
 2249               	.LC31:
 2250 01b1 646F 6563 		.string	"doecho"
 2250      686F 00
 2251               	.LC32:
 2252 01b8 446F 2045 		.string	"Do Echo"
 2252      6368 6F00 
 2253               	.LC33:
 2254 01c0 6163 636C 		.string	"acclock"
 2254      6F63 6B00 
 2255               	.LC34:
 2256 01c8 4143 2043 		.string	"AC Clock"
 2256      6C6F 636B 
 2256      00
 2257               	.LC35:
 2258 01d1 7874 616C 		.string	"xtalisfast"
 2258      6973 6661 
 2258      7374 00
 2259               	.LC36:
 2260 01dc 7368 6F77 		.string	"showtherm"
 2260      7468 6572 
 2260      6D00 
 2261               	.LC37:
 2262 01e6 5368 6F77 		.string	"Show Therm"
 2262      2054 6865 
 2262      726D 00
 2263               	.LC38:
 2264 01f1 7368 6F77 		.string	"showfreq"
 2264      6672 6571 
 2264      00
 2265               	.LC39:
 2266 01fa 5368 6F77 		.string	"Show Freq"
 2266      2046 7265 
 2266      7100 
 2267               	.LC40:
 2268 0204 7368 6F77 		.string	"showdate"
 2268      6461 7465 
 2268      00
 2269               	.LC41:
 2270 020d 5368 6F77 		.string	"Show Date"
 2270      2044 6174 
 2270      6500 
 2271               	.LC42:
 2272 0217 746F 6767 		.string	"toggleled"
 2272      6C65 6C65 
 2272      6400 
 2273               	.LC43:
 2274 0221 546F 6767 		.string	"Toggle LED"
 2274      6C65 204C 
 2274      4544 00
 2275               	.LC44:
 2276 022c 6E69 7869 		.string	"nixiesleepstart"
 2276      6573 6C65 
 2276      6570 7374 
 2276      6172 7400 
 2277               	.LC45:
 2278 023c 4E69 7869 		.string	"Nixie Sleep Start Time"
 2278      6520 536C 
 2278      6565 7020 
 2278      5374 6172 
 2278      7420 5469 
 2279               	.LC46:
 2280 0253 6E69 7869 		.string	"nixiesleepend"
 2280      6573 6C65 
 2280      6570 656E 
 2280      6400 
 2281               	.LC47:
 2282 0261 4E69 7869 		.string	"Nixie Sleep End Time"
 2282      6520 536C 
 2282      6565 7020 
 2282      456E 6420 
 2282      5469 6D65 
 2283               	.LC48:
 2284 0276 6765 7461 		.string	"getall"
 2284      6C6C 00
 2285               	.LC49:
 2286 027d 2C00      		.string	","
 2287               	.LC50:
 2288 027f 7261 6D74 		.string	"ramtoeeprom"
 2288      6F65 6570 
 2288      726F 6D00 
 2289               	.LC51:
 2290 028b 4545 5052 		.string	"EEPROM Storage Complete"
 2290      4F4D 2053 
 2290      746F 7261 
 2290      6765 2043 
 2290      6F6D 706C 
 2291               	.LC52:
 2292 02a3 706F 6B65 		.string	"poke"
 2292      00
 2293               	.LC53:
 2294 02a8 4865 6C6C 		.string	"Hello!"
 2294      6F21 00
 2295               	.LC54:
 2296 02af 4927 6D20 		.string	"I'm Serial Number: "
 2296      5365 7269 
 2296      616C 204E 
 2296      756D 6265 
 2296      723A 2000 
 2297               	.LC55:
 2298 02c3 7077 726F 		.string	"pwrok"
 2298      6B00 
 2299               	.LC56:
 2300 02c9 6876 6665 		.string	"hvfeedback"
 2300      6564 6261 
 2300      636B 00
 2301               	.LC57:
 2302 02d4 6261 7474 		.string	"battvoltage"
 2302      766F 6C74 
 2302      6167 6500 
 2303               	.LC58:
 2304 02e0 7265 6374 		.string	"rectifiedac"
 2304      6966 6965 
 2304      6461 6300 
 2305               		.text
 2306               	.global	process_command
 2308               	process_command:
 2309               	.LFB27:
 516:main.c        **** {
 2310               		.loc 3 516 0
 2311               		.cfi_startproc
 2312 096a CF92      		push r12
 2313               	.LCFI47:
 2314               		.cfi_def_cfa_offset 3
 2315               		.cfi_offset 12, -2
 2316 096c DF92      		push r13
 2317               	.LCFI48:
 2318               		.cfi_def_cfa_offset 4
 2319               		.cfi_offset 13, -3
 2320 096e EF92      		push r14
 2321               	.LCFI49:
 2322               		.cfi_def_cfa_offset 5
 2323               		.cfi_offset 14, -4
 2324 0970 FF92      		push r15
 2325               	.LCFI50:
 2326               		.cfi_def_cfa_offset 6
 2327               		.cfi_offset 15, -5
 2328 0972 0F93      		push r16
 2329               	.LCFI51:
 2330               		.cfi_def_cfa_offset 7
 2331               		.cfi_offset 16, -6
 2332 0974 1F93      		push r17
 2333               	.LCFI52:
 2334               		.cfi_def_cfa_offset 8
 2335               		.cfi_offset 17, -7
 2336               	/* prologue: function */
 2337               	/* frame size = 0 */
 2338               	/* stack size = 6 */
 2339               	.L__stack_usage = 6
 517:main.c        ****     if(strcasestr(myUartString,"hours") != NULL){
 2340               		.loc 3 517 0
 2341 0976 60E0      		ldi r22,lo8(.LC11)
 2342 0978 70E0      		ldi r23,hi8(.LC11)
 2343 097a 80E0      		ldi r24,lo8(myUartString)
 2344 097c 90E0      		ldi r25,hi8(myUartString)
 2345 097e 0E94 0000 		call strcasestr
 2346               	.LVL171:
 2347 0982 892B      		or r24,r25
 2348 0984 01F0      		breq .L92
 518:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2349               		.loc 3 518 0
 2350 0986 60E0      		ldi r22,lo8(.LC12)
 2351 0988 70E0      		ldi r23,hi8(.LC12)
 2352 098a 80E0      		ldi r24,lo8(myUartString)
 2353 098c 90E0      		ldi r25,hi8(myUartString)
 2354 098e 0E94 0000 		call strcasestr
 2355               	.LVL172:
 2356 0992 892B      		or r24,r25
 2357 0994 01F0      		breq .L93
 519:main.c        ****             print_value("Hours", hours);
 2358               		.loc 3 519 0
 2359 0996 4091 0000 		lds r20,hours
 2360 099a 50E0      		ldi r21,0
 2361 099c 60E0      		ldi r22,0
 2362 099e 70E0      		ldi r23,0
 2363 09a0 80E0      		ldi r24,lo8(.LC13)
 2364 09a2 90E0      		ldi r25,hi8(.LC13)
 2365 09a4 00C0      		rjmp .L209
 2366               	.L93:
 521:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2367               		.loc 3 521 0
 2368 09a6 60E0      		ldi r22,lo8(.LC14)
 2369 09a8 70E0      		ldi r23,hi8(.LC14)
 2370 09aa 80E0      		ldi r24,lo8(myUartString)
 2371 09ac 90E0      		ldi r25,hi8(myUartString)
 2372 09ae 0E94 0000 		call strcasestr
 2373               	.LVL173:
 2374 09b2 892B      		or r24,r25
 2375 09b4 01F4      		brne .+2
 2376 09b6 00C0      		rjmp .L94
 522:main.c        ****         		if( inRange( splitString(myUartString), 23, 0 ) )
 2377               		.loc 3 522 0
 2378 09b8 80E0      		ldi r24,lo8(myUartString)
 2379 09ba 90E0      		ldi r25,hi8(myUartString)
 2380 09bc 0E94 0000 		call splitString
 2381               	.LVL174:
 2382               	.LBB222:
 2383               	.LBB223:
 503:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 2384               		.loc 3 503 0
 2385 09c0 6831      		cpi r22,24
 2386 09c2 7105      		cpc r23,__zero_reg__
 2387 09c4 8105      		cpc r24,__zero_reg__
 2388 09c6 9105      		cpc r25,__zero_reg__
 2389 09c8 00F4      		brsh .+2
 2390 09ca 00C0      		rjmp .L96
 2391 09cc 00C0      		rjmp .L94
 2392               	.LVL175:
 2393               	.L92:
 2394               	.LBE223:
 2395               	.LBE222:
 528:main.c        ****     else if(strcasestr(myUartString,"minutes") != NULL){
 2396               		.loc 3 528 0
 2397 09ce 60E0      		ldi r22,lo8(.LC15)
 2398 09d0 70E0      		ldi r23,hi8(.LC15)
 2399 09d2 80E0      		ldi r24,lo8(myUartString)
 2400 09d4 90E0      		ldi r25,hi8(myUartString)
 2401 09d6 0E94 0000 		call strcasestr
 2402               	.LVL176:
 2403 09da 892B      		or r24,r25
 2404 09dc 01F0      		breq .L98
 529:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2405               		.loc 3 529 0
 2406 09de 60E0      		ldi r22,lo8(.LC12)
 2407 09e0 70E0      		ldi r23,hi8(.LC12)
 2408 09e2 80E0      		ldi r24,lo8(myUartString)
 2409 09e4 90E0      		ldi r25,hi8(myUartString)
 2410 09e6 0E94 0000 		call strcasestr
 2411               	.LVL177:
 2412 09ea 892B      		or r24,r25
 2413 09ec 01F0      		breq .L99
 530:main.c        ****             print_value("Minutes", minutes);
 2414               		.loc 3 530 0
 2415 09ee 4091 0000 		lds r20,minutes
 2416 09f2 50E0      		ldi r21,0
 2417 09f4 60E0      		ldi r22,0
 2418 09f6 70E0      		ldi r23,0
 2419 09f8 80E0      		ldi r24,lo8(.LC16)
 2420 09fa 90E0      		ldi r25,hi8(.LC16)
 2421 09fc 00C0      		rjmp .L209
 2422               	.L99:
 532:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2423               		.loc 3 532 0
 2424 09fe 60E0      		ldi r22,lo8(.LC14)
 2425 0a00 70E0      		ldi r23,hi8(.LC14)
 2426 0a02 80E0      		ldi r24,lo8(myUartString)
 2427 0a04 90E0      		ldi r25,hi8(myUartString)
 2428 0a06 0E94 0000 		call strcasestr
 2429               	.LVL178:
 2430 0a0a 892B      		or r24,r25
 2431 0a0c 01F4      		brne .+2
 2432 0a0e 00C0      		rjmp .L94
 533:main.c        ****         		if( inRange( splitString(myUartString), 59, 0 ) )
 2433               		.loc 3 533 0
 2434 0a10 80E0      		ldi r24,lo8(myUartString)
 2435 0a12 90E0      		ldi r25,hi8(myUartString)
 2436 0a14 0E94 0000 		call splitString
 2437               	.LVL179:
 2438               	.LBB224:
 2439               	.LBB225:
 503:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 2440               		.loc 3 503 0
 2441 0a18 6C33      		cpi r22,60
 2442 0a1a 7105      		cpc r23,__zero_reg__
 2443 0a1c 8105      		cpc r24,__zero_reg__
 2444 0a1e 9105      		cpc r25,__zero_reg__
 2445 0a20 00F4      		brsh .+2
 2446 0a22 00C0      		rjmp .L100
 2447 0a24 00C0      		rjmp .L94
 2448               	.LVL180:
 2449               	.L98:
 2450               	.LBE225:
 2451               	.LBE224:
 539:main.c        ****     else if(strcasestr(myUartString,"seconds") != NULL){
 2452               		.loc 3 539 0
 2453 0a26 60E0      		ldi r22,lo8(.LC17)
 2454 0a28 70E0      		ldi r23,hi8(.LC17)
 2455 0a2a 80E0      		ldi r24,lo8(myUartString)
 2456 0a2c 90E0      		ldi r25,hi8(myUartString)
 2457 0a2e 0E94 0000 		call strcasestr
 2458               	.LVL181:
 2459 0a32 892B      		or r24,r25
 2460 0a34 01F0      		breq .L101
 540:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2461               		.loc 3 540 0
 2462 0a36 60E0      		ldi r22,lo8(.LC12)
 2463 0a38 70E0      		ldi r23,hi8(.LC12)
 2464 0a3a 80E0      		ldi r24,lo8(myUartString)
 2465 0a3c 90E0      		ldi r25,hi8(myUartString)
 2466 0a3e 0E94 0000 		call strcasestr
 2467               	.LVL182:
 2468 0a42 892B      		or r24,r25
 2469 0a44 01F0      		breq .L102
 541:main.c        ****             print_value("Seconds", seconds);
 2470               		.loc 3 541 0
 2471 0a46 4091 0000 		lds r20,seconds
 2472 0a4a 50E0      		ldi r21,0
 2473 0a4c 60E0      		ldi r22,0
 2474 0a4e 70E0      		ldi r23,0
 2475 0a50 80E0      		ldi r24,lo8(.LC18)
 2476 0a52 90E0      		ldi r25,hi8(.LC18)
 2477 0a54 00C0      		rjmp .L209
 2478               	.L102:
 543:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2479               		.loc 3 543 0
 2480 0a56 60E0      		ldi r22,lo8(.LC14)
 2481 0a58 70E0      		ldi r23,hi8(.LC14)
 2482 0a5a 80E0      		ldi r24,lo8(myUartString)
 2483 0a5c 90E0      		ldi r25,hi8(myUartString)
 2484 0a5e 0E94 0000 		call strcasestr
 2485               	.LVL183:
 2486 0a62 892B      		or r24,r25
 2487 0a64 01F4      		brne .+2
 2488 0a66 00C0      		rjmp .L94
 544:main.c        ****         		if( inRange( splitString(myUartString), 59, 0 ) )
 2489               		.loc 3 544 0
 2490 0a68 80E0      		ldi r24,lo8(myUartString)
 2491 0a6a 90E0      		ldi r25,hi8(myUartString)
 2492 0a6c 0E94 0000 		call splitString
 2493               	.LVL184:
 2494               	.LBB226:
 2495               	.LBB227:
 503:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 2496               		.loc 3 503 0
 2497 0a70 6C33      		cpi r22,60
 2498 0a72 7105      		cpc r23,__zero_reg__
 2499 0a74 8105      		cpc r24,__zero_reg__
 2500 0a76 9105      		cpc r25,__zero_reg__
 2501 0a78 00F4      		brsh .+2
 2502 0a7a 00C0      		rjmp .L103
 2503 0a7c 00C0      		rjmp .L94
 2504               	.LVL185:
 2505               	.L101:
 2506               	.LBE227:
 2507               	.LBE226:
 550:main.c        ****     else if(strcasestr(myUartString,"mscal") != NULL){
 2508               		.loc 3 550 0
 2509 0a7e 60E0      		ldi r22,lo8(.LC19)
 2510 0a80 70E0      		ldi r23,hi8(.LC19)
 2511 0a82 80E0      		ldi r24,lo8(myUartString)
 2512 0a84 90E0      		ldi r25,hi8(myUartString)
 2513 0a86 0E94 0000 		call strcasestr
 2514               	.LVL186:
 2515 0a8a 892B      		or r24,r25
 2516 0a8c 01F0      		breq .L104
 551:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2517               		.loc 3 551 0
 2518 0a8e 60E0      		ldi r22,lo8(.LC12)
 2519 0a90 70E0      		ldi r23,hi8(.LC12)
 2520 0a92 80E0      		ldi r24,lo8(myUartString)
 2521 0a94 90E0      		ldi r25,hi8(myUartString)
 2522 0a96 0E94 0000 		call strcasestr
 2523               	.LVL187:
 2524 0a9a 892B      		or r24,r25
 2525 0a9c 01F0      		breq .L105
 552:main.c        ****             print_value("mS Calibration", mscal);
 2526               		.loc 3 552 0
 2527 0a9e 4091 0000 		lds r20,mscal
 2528 0aa2 5091 0000 		lds r21,mscal+1
 2529 0aa6 6091 0000 		lds r22,mscal+2
 2530 0aaa 7091 0000 		lds r23,mscal+3
 2531 0aae 80E0      		ldi r24,lo8(.LC20)
 2532 0ab0 90E0      		ldi r25,hi8(.LC20)
 2533 0ab2 00C0      		rjmp .L209
 2534               	.L105:
 554:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2535               		.loc 3 554 0
 2536 0ab4 60E0      		ldi r22,lo8(.LC14)
 2537 0ab6 70E0      		ldi r23,hi8(.LC14)
 2538 0ab8 80E0      		ldi r24,lo8(myUartString)
 2539 0aba 90E0      		ldi r25,hi8(myUartString)
 2540 0abc 0E94 0000 		call strcasestr
 2541               	.LVL188:
 2542 0ac0 892B      		or r24,r25
 2543 0ac2 01F4      		brne .+2
 2544 0ac4 00C0      		rjmp .L94
 555:main.c        ****         		if( inRange( splitString(myUartString), 4294967295, 0 ) )
 2545               		.loc 3 555 0
 2546 0ac6 80E0      		ldi r24,lo8(myUartString)
 2547 0ac8 90E0      		ldi r25,hi8(myUartString)
 2548 0aca 0E94 0000 		call splitString
 2549               	.LVL189:
 556:main.c        ****             		mscal = splitString(myUartString);
 2550               		.loc 3 556 0
 2551 0ace 80E0      		ldi r24,lo8(myUartString)
 2552 0ad0 90E0      		ldi r25,hi8(myUartString)
 2553 0ad2 0E94 0000 		call splitString
 2554               	.LVL190:
 2555 0ad6 6093 0000 		sts mscal,r22
 2556 0ada 7093 0000 		sts mscal+1,r23
 2557 0ade 8093 0000 		sts mscal+2,r24
 2558 0ae2 9093 0000 		sts mscal+3,r25
 2559 0ae6 00C0      		rjmp .L94
 2560               	.LVL191:
 2561               	.L104:
 561:main.c        ****     else if(strcasestr(myUartString,"miltime") != NULL){
 2562               		.loc 3 561 0
 2563 0ae8 60E0      		ldi r22,lo8(.LC21)
 2564 0aea 70E0      		ldi r23,hi8(.LC21)
 2565 0aec 80E0      		ldi r24,lo8(myUartString)
 2566 0aee 90E0      		ldi r25,hi8(myUartString)
 2567 0af0 0E94 0000 		call strcasestr
 2568               	.LVL192:
 2569 0af4 892B      		or r24,r25
 2570 0af6 01F0      		breq .L106
 562:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2571               		.loc 3 562 0
 2572 0af8 60E0      		ldi r22,lo8(.LC12)
 2573 0afa 70E0      		ldi r23,hi8(.LC12)
 2574 0afc 80E0      		ldi r24,lo8(myUartString)
 2575 0afe 90E0      		ldi r25,hi8(myUartString)
 2576 0b00 0E94 0000 		call strcasestr
 2577               	.LVL193:
 2578 0b04 892B      		or r24,r25
 2579 0b06 01F0      		breq .L107
 563:main.c        ****             print_value("MIL Time", miltime);
 2580               		.loc 3 563 0
 2581 0b08 4091 0000 		lds r20,miltime
 2582 0b0c 50E0      		ldi r21,0
 2583 0b0e 60E0      		ldi r22,0
 2584 0b10 70E0      		ldi r23,0
 2585 0b12 80E0      		ldi r24,lo8(.LC22)
 2586 0b14 90E0      		ldi r25,hi8(.LC22)
 2587 0b16 00C0      		rjmp .L209
 2588               	.L107:
 565:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2589               		.loc 3 565 0
 2590 0b18 60E0      		ldi r22,lo8(.LC14)
 2591 0b1a 70E0      		ldi r23,hi8(.LC14)
 2592 0b1c 80E0      		ldi r24,lo8(myUartString)
 2593 0b1e 90E0      		ldi r25,hi8(myUartString)
 2594 0b20 0E94 0000 		call strcasestr
 2595               	.LVL194:
 2596 0b24 892B      		or r24,r25
 2597 0b26 01F4      		brne .+2
 2598 0b28 00C0      		rjmp .L94
 566:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 2599               		.loc 3 566 0
 2600 0b2a 80E0      		ldi r24,lo8(myUartString)
 2601 0b2c 90E0      		ldi r25,hi8(myUartString)
 2602 0b2e 0E94 0000 		call splitString
 2603               	.LVL195:
 2604               	.LBB228:
 2605               	.LBB229:
 503:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 2606               		.loc 3 503 0
 2607 0b32 6230      		cpi r22,2
 2608 0b34 7105      		cpc r23,__zero_reg__
 2609 0b36 8105      		cpc r24,__zero_reg__
 2610 0b38 9105      		cpc r25,__zero_reg__
 2611 0b3a 00F0      		brlo .+2
 2612 0b3c 00C0      		rjmp .L94
 2613 0b3e 00C0      		rjmp .L108
 2614               	.LVL196:
 2615               	.L106:
 2616               	.LBE229:
 2617               	.LBE228:
 572:main.c        ****     else if(strcasestr(myUartString,"year") != NULL){
 2618               		.loc 3 572 0
 2619 0b40 60E0      		ldi r22,lo8(.LC23)
 2620 0b42 70E0      		ldi r23,hi8(.LC23)
 2621 0b44 80E0      		ldi r24,lo8(myUartString)
 2622 0b46 90E0      		ldi r25,hi8(myUartString)
 2623 0b48 0E94 0000 		call strcasestr
 2624               	.LVL197:
 2625 0b4c 892B      		or r24,r25
 2626 0b4e 01F0      		breq .L109
 573:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2627               		.loc 3 573 0
 2628 0b50 60E0      		ldi r22,lo8(.LC12)
 2629 0b52 70E0      		ldi r23,hi8(.LC12)
 2630 0b54 80E0      		ldi r24,lo8(myUartString)
 2631 0b56 90E0      		ldi r25,hi8(myUartString)
 2632 0b58 0E94 0000 		call strcasestr
 2633               	.LVL198:
 2634 0b5c 892B      		or r24,r25
 2635 0b5e 01F0      		breq .L110
 574:main.c        ****             print_value("Year", year);
 2636               		.loc 3 574 0
 2637 0b60 4091 0000 		lds r20,year
 2638 0b64 5091 0000 		lds r21,year+1
 2639 0b68 60E0      		ldi r22,0
 2640 0b6a 70E0      		ldi r23,0
 2641 0b6c 80E0      		ldi r24,lo8(.LC24)
 2642 0b6e 90E0      		ldi r25,hi8(.LC24)
 2643 0b70 00C0      		rjmp .L209
 2644               	.L110:
 576:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2645               		.loc 3 576 0
 2646 0b72 60E0      		ldi r22,lo8(.LC14)
 2647 0b74 70E0      		ldi r23,hi8(.LC14)
 2648 0b76 80E0      		ldi r24,lo8(myUartString)
 2649 0b78 90E0      		ldi r25,hi8(myUartString)
 2650 0b7a 0E94 0000 		call strcasestr
 2651               	.LVL199:
 2652 0b7e 892B      		or r24,r25
 2653 0b80 01F4      		brne .+2
 2654 0b82 00C0      		rjmp .L94
 577:main.c        ****         		if( inRange( splitString(myUartString), 2525, 0 ) )
 2655               		.loc 3 577 0
 2656 0b84 80E0      		ldi r24,lo8(myUartString)
 2657 0b86 90E0      		ldi r25,hi8(myUartString)
 2658 0b88 0E94 0000 		call splitString
 2659               	.LVL200:
 2660               	.LBB230:
 2661               	.LBB231:
 503:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 2662               		.loc 3 503 0
 2663 0b8c 6E3D      		cpi r22,-34
 2664 0b8e 7940      		sbci r23,9
 2665 0b90 8105      		cpc r24,__zero_reg__
 2666 0b92 9105      		cpc r25,__zero_reg__
 2667 0b94 00F4      		brsh .+2
 2668 0b96 00C0      		rjmp .L111
 2669 0b98 00C0      		rjmp .L94
 2670               	.LVL201:
 2671               	.L109:
 2672               	.LBE231:
 2673               	.LBE230:
 583:main.c        ****     else if(strcasestr(myUartString,"month") != NULL){
 2674               		.loc 3 583 0
 2675 0b9a 60E0      		ldi r22,lo8(.LC25)
 2676 0b9c 70E0      		ldi r23,hi8(.LC25)
 2677 0b9e 80E0      		ldi r24,lo8(myUartString)
 2678 0ba0 90E0      		ldi r25,hi8(myUartString)
 2679 0ba2 0E94 0000 		call strcasestr
 2680               	.LVL202:
 2681 0ba6 892B      		or r24,r25
 2682 0ba8 01F0      		breq .L112
 584:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2683               		.loc 3 584 0
 2684 0baa 60E0      		ldi r22,lo8(.LC12)
 2685 0bac 70E0      		ldi r23,hi8(.LC12)
 2686 0bae 80E0      		ldi r24,lo8(myUartString)
 2687 0bb0 90E0      		ldi r25,hi8(myUartString)
 2688 0bb2 0E94 0000 		call strcasestr
 2689               	.LVL203:
 2690 0bb6 892B      		or r24,r25
 2691 0bb8 01F0      		breq .L113
 585:main.c        ****             print_value("Month", month);
 2692               		.loc 3 585 0
 2693 0bba 4091 0000 		lds r20,month
 2694 0bbe 50E0      		ldi r21,0
 2695 0bc0 60E0      		ldi r22,0
 2696 0bc2 70E0      		ldi r23,0
 2697 0bc4 80E0      		ldi r24,lo8(.LC26)
 2698 0bc6 90E0      		ldi r25,hi8(.LC26)
 2699 0bc8 00C0      		rjmp .L209
 2700               	.L113:
 587:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2701               		.loc 3 587 0
 2702 0bca 60E0      		ldi r22,lo8(.LC14)
 2703 0bcc 70E0      		ldi r23,hi8(.LC14)
 2704 0bce 80E0      		ldi r24,lo8(myUartString)
 2705 0bd0 90E0      		ldi r25,hi8(myUartString)
 2706 0bd2 0E94 0000 		call strcasestr
 2707               	.LVL204:
 2708 0bd6 892B      		or r24,r25
 2709 0bd8 01F4      		brne .+2
 2710 0bda 00C0      		rjmp .L94
 588:main.c        ****         		if( inRange( splitString(myUartString), 12, 0 ) )
 2711               		.loc 3 588 0
 2712 0bdc 80E0      		ldi r24,lo8(myUartString)
 2713 0bde 90E0      		ldi r25,hi8(myUartString)
 2714 0be0 0E94 0000 		call splitString
 2715               	.LVL205:
 2716               	.LBB232:
 2717               	.LBB233:
 503:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 2718               		.loc 3 503 0
 2719 0be4 6D30      		cpi r22,13
 2720 0be6 7105      		cpc r23,__zero_reg__
 2721 0be8 8105      		cpc r24,__zero_reg__
 2722 0bea 9105      		cpc r25,__zero_reg__
 2723 0bec 00F4      		brsh .+2
 2724 0bee 00C0      		rjmp .L114
 2725 0bf0 00C0      		rjmp .L94
 2726               	.LVL206:
 2727               	.L112:
 2728               	.LBE233:
 2729               	.LBE232:
 594:main.c        ****     else if(strcasestr(myUartString,"day") != NULL){
 2730               		.loc 3 594 0
 2731 0bf2 60E0      		ldi r22,lo8(.LC27)
 2732 0bf4 70E0      		ldi r23,hi8(.LC27)
 2733 0bf6 80E0      		ldi r24,lo8(myUartString)
 2734 0bf8 90E0      		ldi r25,hi8(myUartString)
 2735 0bfa 0E94 0000 		call strcasestr
 2736               	.LVL207:
 2737 0bfe 892B      		or r24,r25
 2738 0c00 01F0      		breq .L115
 595:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2739               		.loc 3 595 0
 2740 0c02 60E0      		ldi r22,lo8(.LC12)
 2741 0c04 70E0      		ldi r23,hi8(.LC12)
 2742 0c06 80E0      		ldi r24,lo8(myUartString)
 2743 0c08 90E0      		ldi r25,hi8(myUartString)
 2744 0c0a 0E94 0000 		call strcasestr
 2745               	.LVL208:
 2746 0c0e 892B      		or r24,r25
 2747 0c10 01F0      		breq .L116
 596:main.c        ****             print_value("Day", day);
 2748               		.loc 3 596 0
 2749 0c12 4091 0000 		lds r20,day
 2750 0c16 50E0      		ldi r21,0
 2751 0c18 60E0      		ldi r22,0
 2752 0c1a 70E0      		ldi r23,0
 2753 0c1c 80E0      		ldi r24,lo8(.LC28)
 2754 0c1e 90E0      		ldi r25,hi8(.LC28)
 2755 0c20 00C0      		rjmp .L209
 2756               	.L116:
 598:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2757               		.loc 3 598 0
 2758 0c22 60E0      		ldi r22,lo8(.LC14)
 2759 0c24 70E0      		ldi r23,hi8(.LC14)
 2760 0c26 80E0      		ldi r24,lo8(myUartString)
 2761 0c28 90E0      		ldi r25,hi8(myUartString)
 2762 0c2a 0E94 0000 		call strcasestr
 2763               	.LVL209:
 2764 0c2e 892B      		or r24,r25
 2765 0c30 01F4      		brne .+2
 2766 0c32 00C0      		rjmp .L94
 599:main.c        ****         		if( inRange( splitString(myUartString), 31, 0 ) )
 2767               		.loc 3 599 0
 2768 0c34 80E0      		ldi r24,lo8(myUartString)
 2769 0c36 90E0      		ldi r25,hi8(myUartString)
 2770 0c38 0E94 0000 		call splitString
 2771               	.LVL210:
 2772               	.LBB234:
 2773               	.LBB235:
 503:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 2774               		.loc 3 503 0
 2775 0c3c 6032      		cpi r22,32
 2776 0c3e 7105      		cpc r23,__zero_reg__
 2777 0c40 8105      		cpc r24,__zero_reg__
 2778 0c42 9105      		cpc r25,__zero_reg__
 2779 0c44 00F4      		brsh .+2
 2780 0c46 00C0      		rjmp .L117
 2781 0c48 00C0      		rjmp .L94
 2782               	.LVL211:
 2783               	.L115:
 2784               	.LBE235:
 2785               	.LBE234:
 605:main.c        ****     else if(strcasestr(myUartString,"celsius") != NULL){
 2786               		.loc 3 605 0
 2787 0c4a 60E0      		ldi r22,lo8(.LC29)
 2788 0c4c 70E0      		ldi r23,hi8(.LC29)
 2789 0c4e 80E0      		ldi r24,lo8(myUartString)
 2790 0c50 90E0      		ldi r25,hi8(myUartString)
 2791 0c52 0E94 0000 		call strcasestr
 2792               	.LVL212:
 2793 0c56 892B      		or r24,r25
 2794 0c58 01F0      		breq .L118
 606:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2795               		.loc 3 606 0
 2796 0c5a 60E0      		ldi r22,lo8(.LC12)
 2797 0c5c 70E0      		ldi r23,hi8(.LC12)
 2798 0c5e 80E0      		ldi r24,lo8(myUartString)
 2799 0c60 90E0      		ldi r25,hi8(myUartString)
 2800 0c62 0E94 0000 		call strcasestr
 2801               	.LVL213:
 2802 0c66 892B      		or r24,r25
 2803 0c68 01F0      		breq .L119
 607:main.c        ****             print_value("Celsius", celsius);
 2804               		.loc 3 607 0
 2805 0c6a 4091 0000 		lds r20,celsius
 2806 0c6e 50E0      		ldi r21,0
 2807 0c70 60E0      		ldi r22,0
 2808 0c72 70E0      		ldi r23,0
 2809 0c74 80E0      		ldi r24,lo8(.LC30)
 2810 0c76 90E0      		ldi r25,hi8(.LC30)
 2811 0c78 00C0      		rjmp .L209
 2812               	.L119:
 609:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2813               		.loc 3 609 0
 2814 0c7a 60E0      		ldi r22,lo8(.LC14)
 2815 0c7c 70E0      		ldi r23,hi8(.LC14)
 2816 0c7e 80E0      		ldi r24,lo8(myUartString)
 2817 0c80 90E0      		ldi r25,hi8(myUartString)
 2818 0c82 0E94 0000 		call strcasestr
 2819               	.LVL214:
 2820 0c86 892B      		or r24,r25
 2821 0c88 01F4      		brne .+2
 2822 0c8a 00C0      		rjmp .L94
 610:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 2823               		.loc 3 610 0
 2824 0c8c 80E0      		ldi r24,lo8(myUartString)
 2825 0c8e 90E0      		ldi r25,hi8(myUartString)
 2826 0c90 0E94 0000 		call splitString
 2827               	.LVL215:
 2828               	.LBB236:
 2829               	.LBB237:
 503:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 2830               		.loc 3 503 0
 2831 0c94 6230      		cpi r22,2
 2832 0c96 7105      		cpc r23,__zero_reg__
 2833 0c98 8105      		cpc r24,__zero_reg__
 2834 0c9a 9105      		cpc r25,__zero_reg__
 2835 0c9c 00F0      		brlo .+2
 2836 0c9e 00C0      		rjmp .L94
 2837 0ca0 00C0      		rjmp .L120
 2838               	.LVL216:
 2839               	.L118:
 2840               	.LBE237:
 2841               	.LBE236:
 616:main.c        ****     else if(strcasestr(myUartString,"doecho") != NULL){
 2842               		.loc 3 616 0
 2843 0ca2 60E0      		ldi r22,lo8(.LC31)
 2844 0ca4 70E0      		ldi r23,hi8(.LC31)
 2845 0ca6 80E0      		ldi r24,lo8(myUartString)
 2846 0ca8 90E0      		ldi r25,hi8(myUartString)
 2847 0caa 0E94 0000 		call strcasestr
 2848               	.LVL217:
 2849 0cae 892B      		or r24,r25
 2850 0cb0 01F0      		breq .L121
 617:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2851               		.loc 3 617 0
 2852 0cb2 60E0      		ldi r22,lo8(.LC12)
 2853 0cb4 70E0      		ldi r23,hi8(.LC12)
 2854 0cb6 80E0      		ldi r24,lo8(myUartString)
 2855 0cb8 90E0      		ldi r25,hi8(myUartString)
 2856 0cba 0E94 0000 		call strcasestr
 2857               	.LVL218:
 2858 0cbe 892B      		or r24,r25
 2859 0cc0 01F0      		breq .L122
 618:main.c        ****             print_value("Do Echo", doecho);
 2860               		.loc 3 618 0
 2861 0cc2 4091 0000 		lds r20,doecho
 2862 0cc6 50E0      		ldi r21,0
 2863 0cc8 60E0      		ldi r22,0
 2864 0cca 70E0      		ldi r23,0
 2865 0ccc 80E0      		ldi r24,lo8(.LC32)
 2866 0cce 90E0      		ldi r25,hi8(.LC32)
 2867 0cd0 00C0      		rjmp .L209
 2868               	.L122:
 620:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2869               		.loc 3 620 0
 2870 0cd2 60E0      		ldi r22,lo8(.LC14)
 2871 0cd4 70E0      		ldi r23,hi8(.LC14)
 2872 0cd6 80E0      		ldi r24,lo8(myUartString)
 2873 0cd8 90E0      		ldi r25,hi8(myUartString)
 2874 0cda 0E94 0000 		call strcasestr
 2875               	.LVL219:
 2876 0cde 892B      		or r24,r25
 2877 0ce0 01F4      		brne .+2
 2878 0ce2 00C0      		rjmp .L94
 621:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 2879               		.loc 3 621 0
 2880 0ce4 80E0      		ldi r24,lo8(myUartString)
 2881 0ce6 90E0      		ldi r25,hi8(myUartString)
 2882 0ce8 0E94 0000 		call splitString
 2883               	.LVL220:
 2884               	.LBB238:
 2885               	.LBB239:
 503:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 2886               		.loc 3 503 0
 2887 0cec 6230      		cpi r22,2
 2888 0cee 7105      		cpc r23,__zero_reg__
 2889 0cf0 8105      		cpc r24,__zero_reg__
 2890 0cf2 9105      		cpc r25,__zero_reg__
 2891 0cf4 00F0      		brlo .+2
 2892 0cf6 00C0      		rjmp .L94
 2893 0cf8 00C0      		rjmp .L123
 2894               	.LVL221:
 2895               	.L121:
 2896               	.LBE239:
 2897               	.LBE238:
 627:main.c        ****     else if(strcasestr(myUartString,"acclock") != NULL){
 2898               		.loc 3 627 0
 2899 0cfa 60E0      		ldi r22,lo8(.LC33)
 2900 0cfc 70E0      		ldi r23,hi8(.LC33)
 2901 0cfe 80E0      		ldi r24,lo8(myUartString)
 2902 0d00 90E0      		ldi r25,hi8(myUartString)
 2903 0d02 0E94 0000 		call strcasestr
 2904               	.LVL222:
 2905 0d06 892B      		or r24,r25
 2906 0d08 01F0      		breq .L124
 628:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2907               		.loc 3 628 0
 2908 0d0a 60E0      		ldi r22,lo8(.LC12)
 2909 0d0c 70E0      		ldi r23,hi8(.LC12)
 2910 0d0e 80E0      		ldi r24,lo8(myUartString)
 2911 0d10 90E0      		ldi r25,hi8(myUartString)
 2912 0d12 0E94 0000 		call strcasestr
 2913               	.LVL223:
 2914 0d16 892B      		or r24,r25
 2915 0d18 01F0      		breq .L125
 629:main.c        ****             print_value("AC Clock", acclock);
 2916               		.loc 3 629 0
 2917 0d1a 4091 0000 		lds r20,acclock
 2918 0d1e 50E0      		ldi r21,0
 2919 0d20 60E0      		ldi r22,0
 2920 0d22 70E0      		ldi r23,0
 2921 0d24 80E0      		ldi r24,lo8(.LC34)
 2922 0d26 90E0      		ldi r25,hi8(.LC34)
 2923 0d28 00C0      		rjmp .L209
 2924               	.L125:
 631:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2925               		.loc 3 631 0
 2926 0d2a 60E0      		ldi r22,lo8(.LC14)
 2927 0d2c 70E0      		ldi r23,hi8(.LC14)
 2928 0d2e 80E0      		ldi r24,lo8(myUartString)
 2929 0d30 90E0      		ldi r25,hi8(myUartString)
 2930 0d32 0E94 0000 		call strcasestr
 2931               	.LVL224:
 2932 0d36 892B      		or r24,r25
 2933 0d38 01F4      		brne .+2
 2934 0d3a 00C0      		rjmp .L94
 632:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 2935               		.loc 3 632 0
 2936 0d3c 80E0      		ldi r24,lo8(myUartString)
 2937 0d3e 90E0      		ldi r25,hi8(myUartString)
 2938 0d40 0E94 0000 		call splitString
 2939               	.LVL225:
 2940               	.LBB240:
 2941               	.LBB241:
 503:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 2942               		.loc 3 503 0
 2943 0d44 6230      		cpi r22,2
 2944 0d46 7105      		cpc r23,__zero_reg__
 2945 0d48 8105      		cpc r24,__zero_reg__
 2946 0d4a 9105      		cpc r25,__zero_reg__
 2947 0d4c 00F0      		brlo .+2
 2948 0d4e 00C0      		rjmp .L94
 2949 0d50 00C0      		rjmp .L126
 2950               	.LVL226:
 2951               	.L124:
 2952               	.LBE241:
 2953               	.LBE240:
 638:main.c        ****     else if(strcasestr(myUartString,"xtalisfast") != NULL){
 2954               		.loc 3 638 0
 2955 0d52 60E0      		ldi r22,lo8(.LC35)
 2956 0d54 70E0      		ldi r23,hi8(.LC35)
 2957 0d56 80E0      		ldi r24,lo8(myUartString)
 2958 0d58 90E0      		ldi r25,hi8(myUartString)
 2959 0d5a 0E94 0000 		call strcasestr
 2960               	.LVL227:
 2961 0d5e 892B      		or r24,r25
 2962 0d60 01F0      		breq .L127
 639:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2963               		.loc 3 639 0
 2964 0d62 60E0      		ldi r22,lo8(.LC12)
 2965 0d64 70E0      		ldi r23,hi8(.LC12)
 2966 0d66 80E0      		ldi r24,lo8(myUartString)
 2967 0d68 90E0      		ldi r25,hi8(myUartString)
 2968 0d6a 0E94 0000 		call strcasestr
 2969               	.LVL228:
 2970 0d6e 892B      		or r24,r25
 2971 0d70 01F0      		breq .L128
 640:main.c        ****             print_value("xtalisfast", xtalisfast);
 2972               		.loc 3 640 0
 2973 0d72 4091 0000 		lds r20,xtalisfast
 2974 0d76 50E0      		ldi r21,0
 2975 0d78 60E0      		ldi r22,0
 2976 0d7a 70E0      		ldi r23,0
 2977 0d7c 80E0      		ldi r24,lo8(.LC35)
 2978 0d7e 90E0      		ldi r25,hi8(.LC35)
 2979               	.L209:
 2980 0d80 0E94 0000 		call print_value
 2981               	.LVL229:
 2982 0d84 00C0      		rjmp .L94
 2983               	.L128:
 642:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2984               		.loc 3 642 0
 2985 0d86 60E0      		ldi r22,lo8(.LC14)
 2986 0d88 70E0      		ldi r23,hi8(.LC14)
 2987 0d8a 80E0      		ldi r24,lo8(myUartString)
 2988 0d8c 90E0      		ldi r25,hi8(myUartString)
 2989 0d8e 0E94 0000 		call strcasestr
 2990               	.LVL230:
 2991 0d92 892B      		or r24,r25
 2992 0d94 01F4      		brne .+2
 2993 0d96 00C0      		rjmp .L94
 643:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 2994               		.loc 3 643 0
 2995 0d98 80E0      		ldi r24,lo8(myUartString)
 2996 0d9a 90E0      		ldi r25,hi8(myUartString)
 2997 0d9c 0E94 0000 		call splitString
 2998               	.LVL231:
 2999               	.LBB242:
 3000               	.LBB243:
 503:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 3001               		.loc 3 503 0
 3002 0da0 6230      		cpi r22,2
 3003 0da2 7105      		cpc r23,__zero_reg__
 3004 0da4 8105      		cpc r24,__zero_reg__
 3005 0da6 9105      		cpc r25,__zero_reg__
 3006 0da8 00F0      		brlo .+2
 3007 0daa 00C0      		rjmp .L94
 3008 0dac 00C0      		rjmp .L129
 3009               	.LVL232:
 3010               	.L127:
 3011               	.LBE243:
 3012               	.LBE242:
 649:main.c        **** 	else if(strcasestr(myUartString,"showtherm") != NULL){
 3013               		.loc 3 649 0
 3014 0dae 60E0      		ldi r22,lo8(.LC36)
 3015 0db0 70E0      		ldi r23,hi8(.LC36)
 3016 0db2 80E0      		ldi r24,lo8(myUartString)
 3017 0db4 90E0      		ldi r25,hi8(myUartString)
 3018 0db6 0E94 0000 		call strcasestr
 3019               	.LVL233:
 3020 0dba 892B      		or r24,r25
 3021 0dbc 01F0      		breq .L130
 650:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 3022               		.loc 3 650 0
 3023 0dbe 60E0      		ldi r22,lo8(.LC12)
 3024 0dc0 70E0      		ldi r23,hi8(.LC12)
 3025 0dc2 80E0      		ldi r24,lo8(myUartString)
 3026 0dc4 90E0      		ldi r25,hi8(myUartString)
 3027 0dc6 0E94 0000 		call strcasestr
 3028               	.LVL234:
 3029 0dca 892B      		or r24,r25
 3030 0dcc 01F0      		breq .L131
 651:main.c        ****             print_value("Show Therm", showtherm);
 3031               		.loc 3 651 0
 3032 0dce 4091 0000 		lds r20,showtherm
 3033 0dd2 50E0      		ldi r21,0
 3034 0dd4 60E0      		ldi r22,0
 3035 0dd6 70E0      		ldi r23,0
 3036 0dd8 80E0      		ldi r24,lo8(.LC37)
 3037 0dda 90E0      		ldi r25,hi8(.LC37)
 3038 0ddc 00C0      		rjmp .L209
 3039               	.L131:
 653:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 3040               		.loc 3 653 0
 3041 0dde 60E0      		ldi r22,lo8(.LC14)
 3042 0de0 70E0      		ldi r23,hi8(.LC14)
 3043 0de2 80E0      		ldi r24,lo8(myUartString)
 3044 0de4 90E0      		ldi r25,hi8(myUartString)
 3045 0de6 0E94 0000 		call strcasestr
 3046               	.LVL235:
 3047 0dea 892B      		or r24,r25
 3048 0dec 01F4      		brne .+2
 3049 0dee 00C0      		rjmp .L94
 654:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 3050               		.loc 3 654 0
 3051 0df0 80E0      		ldi r24,lo8(myUartString)
 3052 0df2 90E0      		ldi r25,hi8(myUartString)
 3053 0df4 0E94 0000 		call splitString
 3054               	.LVL236:
 3055               	.LBB244:
 3056               	.LBB245:
 503:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 3057               		.loc 3 503 0
 3058 0df8 6230      		cpi r22,2
 3059 0dfa 7105      		cpc r23,__zero_reg__
 3060 0dfc 8105      		cpc r24,__zero_reg__
 3061 0dfe 9105      		cpc r25,__zero_reg__
 3062 0e00 00F0      		brlo .+2
 3063 0e02 00C0      		rjmp .L94
 3064 0e04 00C0      		rjmp .L132
 3065               	.LVL237:
 3066               	.L130:
 3067               	.LBE245:
 3068               	.LBE244:
 660:main.c        ****     else if(strcasestr(myUartString,"showfreq") != NULL){
 3069               		.loc 3 660 0
 3070 0e06 60E0      		ldi r22,lo8(.LC38)
 3071 0e08 70E0      		ldi r23,hi8(.LC38)
 3072 0e0a 80E0      		ldi r24,lo8(myUartString)
 3073 0e0c 90E0      		ldi r25,hi8(myUartString)
 3074 0e0e 0E94 0000 		call strcasestr
 3075               	.LVL238:
 3076 0e12 892B      		or r24,r25
 3077 0e14 01F0      		breq .L133
 661:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 3078               		.loc 3 661 0
 3079 0e16 60E0      		ldi r22,lo8(.LC12)
 3080 0e18 70E0      		ldi r23,hi8(.LC12)
 3081 0e1a 80E0      		ldi r24,lo8(myUartString)
 3082 0e1c 90E0      		ldi r25,hi8(myUartString)
 3083 0e1e 0E94 0000 		call strcasestr
 3084               	.LVL239:
 3085 0e22 892B      		or r24,r25
 3086 0e24 01F0      		breq .L134
 662:main.c        ****             print_value("Show Freq", showfreq);
 3087               		.loc 3 662 0
 3088 0e26 4091 0000 		lds r20,showfreq
 3089 0e2a 50E0      		ldi r21,0
 3090 0e2c 60E0      		ldi r22,0
 3091 0e2e 70E0      		ldi r23,0
 3092 0e30 80E0      		ldi r24,lo8(.LC39)
 3093 0e32 90E0      		ldi r25,hi8(.LC39)
 3094 0e34 00C0      		rjmp .L209
 3095               	.L134:
 664:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 3096               		.loc 3 664 0
 3097 0e36 60E0      		ldi r22,lo8(.LC14)
 3098 0e38 70E0      		ldi r23,hi8(.LC14)
 3099 0e3a 80E0      		ldi r24,lo8(myUartString)
 3100 0e3c 90E0      		ldi r25,hi8(myUartString)
 3101 0e3e 0E94 0000 		call strcasestr
 3102               	.LVL240:
 3103 0e42 892B      		or r24,r25
 3104 0e44 01F4      		brne .+2
 3105 0e46 00C0      		rjmp .L94
 665:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 3106               		.loc 3 665 0
 3107 0e48 80E0      		ldi r24,lo8(myUartString)
 3108 0e4a 90E0      		ldi r25,hi8(myUartString)
 3109 0e4c 0E94 0000 		call splitString
 3110               	.LVL241:
 3111               	.LBB246:
 3112               	.LBB247:
 503:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 3113               		.loc 3 503 0
 3114 0e50 6230      		cpi r22,2
 3115 0e52 7105      		cpc r23,__zero_reg__
 3116 0e54 8105      		cpc r24,__zero_reg__
 3117 0e56 9105      		cpc r25,__zero_reg__
 3118 0e58 00F0      		brlo .+2
 3119 0e5a 00C0      		rjmp .L94
 3120 0e5c 00C0      		rjmp .L135
 3121               	.LVL242:
 3122               	.L133:
 3123               	.LBE247:
 3124               	.LBE246:
 671:main.c        **** 	else if(strcasestr(myUartString,"showdate") != NULL){
 3125               		.loc 3 671 0
 3126 0e5e 60E0      		ldi r22,lo8(.LC40)
 3127 0e60 70E0      		ldi r23,hi8(.LC40)
 3128 0e62 80E0      		ldi r24,lo8(myUartString)
 3129 0e64 90E0      		ldi r25,hi8(myUartString)
 3130 0e66 0E94 0000 		call strcasestr
 3131               	.LVL243:
 3132 0e6a 892B      		or r24,r25
 3133 0e6c 01F0      		breq .L136
 672:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 3134               		.loc 3 672 0
 3135 0e6e 60E0      		ldi r22,lo8(.LC12)
 3136 0e70 70E0      		ldi r23,hi8(.LC12)
 3137 0e72 80E0      		ldi r24,lo8(myUartString)
 3138 0e74 90E0      		ldi r25,hi8(myUartString)
 3139 0e76 0E94 0000 		call strcasestr
 3140               	.LVL244:
 3141 0e7a 892B      		or r24,r25
 3142 0e7c 01F0      		breq .L137
 673:main.c        ****             print_value("Show Date", showdate);
 3143               		.loc 3 673 0
 3144 0e7e 4091 0000 		lds r20,showdate
 3145 0e82 50E0      		ldi r21,0
 3146 0e84 60E0      		ldi r22,0
 3147 0e86 70E0      		ldi r23,0
 3148 0e88 80E0      		ldi r24,lo8(.LC41)
 3149 0e8a 90E0      		ldi r25,hi8(.LC41)
 3150 0e8c 00C0      		rjmp .L209
 3151               	.L137:
 675:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 3152               		.loc 3 675 0
 3153 0e8e 60E0      		ldi r22,lo8(.LC14)
 3154 0e90 70E0      		ldi r23,hi8(.LC14)
 3155 0e92 80E0      		ldi r24,lo8(myUartString)
 3156 0e94 90E0      		ldi r25,hi8(myUartString)
 3157 0e96 0E94 0000 		call strcasestr
 3158               	.LVL245:
 3159 0e9a 892B      		or r24,r25
 3160 0e9c 01F4      		brne .+2
 3161 0e9e 00C0      		rjmp .L94
 676:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 3162               		.loc 3 676 0
 3163 0ea0 80E0      		ldi r24,lo8(myUartString)
 3164 0ea2 90E0      		ldi r25,hi8(myUartString)
 3165 0ea4 0E94 0000 		call splitString
 3166               	.LVL246:
 3167               	.LBB248:
 3168               	.LBB249:
 503:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 3169               		.loc 3 503 0
 3170 0ea8 6230      		cpi r22,2
 3171 0eaa 7105      		cpc r23,__zero_reg__
 3172 0eac 8105      		cpc r24,__zero_reg__
 3173 0eae 9105      		cpc r25,__zero_reg__
 3174 0eb0 00F0      		brlo .+2
 3175 0eb2 00C0      		rjmp .L94
 3176 0eb4 00C0      		rjmp .L138
 3177               	.LVL247:
 3178               	.L136:
 3179               	.LBE249:
 3180               	.LBE248:
 682:main.c        ****     else if(strcasestr(myUartString,"toggleled")!= NULL){
 3181               		.loc 3 682 0
 3182 0eb6 60E0      		ldi r22,lo8(.LC42)
 3183 0eb8 70E0      		ldi r23,hi8(.LC42)
 3184 0eba 80E0      		ldi r24,lo8(myUartString)
 3185 0ebc 90E0      		ldi r25,hi8(myUartString)
 3186 0ebe 0E94 0000 		call strcasestr
 3187               	.LVL248:
 3188 0ec2 892B      		or r24,r25
 3189 0ec4 01F0      		breq .L139
 683:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 3190               		.loc 3 683 0
 3191 0ec6 60E0      		ldi r22,lo8(.LC12)
 3192 0ec8 70E0      		ldi r23,hi8(.LC12)
 3193 0eca 80E0      		ldi r24,lo8(myUartString)
 3194 0ecc 90E0      		ldi r25,hi8(myUartString)
 3195 0ece 0E94 0000 		call strcasestr
 3196               	.LVL249:
 3197 0ed2 892B      		or r24,r25
 3198 0ed4 01F0      		breq .L140
 684:main.c        ****             print_value("Toggle LED", toggleled);
 3199               		.loc 3 684 0
 3200 0ed6 4091 0000 		lds r20,toggleled
 3201 0eda 50E0      		ldi r21,0
 3202 0edc 60E0      		ldi r22,0
 3203 0ede 70E0      		ldi r23,0
 3204 0ee0 80E0      		ldi r24,lo8(.LC43)
 3205 0ee2 90E0      		ldi r25,hi8(.LC43)
 3206 0ee4 00C0      		rjmp .L209
 3207               	.L140:
 686:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 3208               		.loc 3 686 0
 3209 0ee6 60E0      		ldi r22,lo8(.LC14)
 3210 0ee8 70E0      		ldi r23,hi8(.LC14)
 3211 0eea 80E0      		ldi r24,lo8(myUartString)
 3212 0eec 90E0      		ldi r25,hi8(myUartString)
 3213 0eee 0E94 0000 		call strcasestr
 3214               	.LVL250:
 3215 0ef2 892B      		or r24,r25
 3216 0ef4 01F4      		brne .+2
 3217 0ef6 00C0      		rjmp .L94
 687:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 3218               		.loc 3 687 0
 3219 0ef8 80E0      		ldi r24,lo8(myUartString)
 3220 0efa 90E0      		ldi r25,hi8(myUartString)
 3221 0efc 0E94 0000 		call splitString
 3222               	.LVL251:
 3223               	.LBB250:
 3224               	.LBB251:
 503:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 3225               		.loc 3 503 0
 3226 0f00 6230      		cpi r22,2
 3227 0f02 7105      		cpc r23,__zero_reg__
 3228 0f04 8105      		cpc r24,__zero_reg__
 3229 0f06 9105      		cpc r25,__zero_reg__
 3230 0f08 00F0      		brlo .+2
 3231 0f0a 00C0      		rjmp .L94
 3232 0f0c 00C0      		rjmp .L141
 3233               	.LVL252:
 3234               	.L139:
 3235               	.LBE251:
 3236               	.LBE250:
 693:main.c        ****     else if(strcasestr(myUartString,"nixiesleepstart") != NULL){
 3237               		.loc 3 693 0
 3238 0f0e 60E0      		ldi r22,lo8(.LC44)
 3239 0f10 70E0      		ldi r23,hi8(.LC44)
 3240 0f12 80E0      		ldi r24,lo8(myUartString)
 3241 0f14 90E0      		ldi r25,hi8(myUartString)
 3242 0f16 0E94 0000 		call strcasestr
 3243               	.LVL253:
 3244 0f1a 892B      		or r24,r25
 3245 0f1c 01F0      		breq .L142
 694:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 3246               		.loc 3 694 0
 3247 0f1e 60E0      		ldi r22,lo8(.LC12)
 3248 0f20 70E0      		ldi r23,hi8(.LC12)
 3249 0f22 80E0      		ldi r24,lo8(myUartString)
 3250 0f24 90E0      		ldi r25,hi8(myUartString)
 3251 0f26 0E94 0000 		call strcasestr
 3252               	.LVL254:
 3253 0f2a 892B      		or r24,r25
 3254 0f2c 01F0      		breq .L143
 695:main.c        ****             print_value("Nixie Sleep Start Time", nixiesleepstart);
 3255               		.loc 3 695 0
 3256 0f2e 4091 0000 		lds r20,nixiesleepstart
 3257 0f32 5091 0000 		lds r21,nixiesleepstart+1
 3258 0f36 6091 0000 		lds r22,nixiesleepstart+2
 3259 0f3a 7091 0000 		lds r23,nixiesleepstart+3
 3260 0f3e 80E0      		ldi r24,lo8(.LC45)
 3261 0f40 90E0      		ldi r25,hi8(.LC45)
 3262 0f42 00C0      		rjmp .L209
 3263               	.L143:
 697:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 3264               		.loc 3 697 0
 3265 0f44 60E0      		ldi r22,lo8(.LC14)
 3266 0f46 70E0      		ldi r23,hi8(.LC14)
 3267 0f48 80E0      		ldi r24,lo8(myUartString)
 3268 0f4a 90E0      		ldi r25,hi8(myUartString)
 3269 0f4c 0E94 0000 		call strcasestr
 3270               	.LVL255:
 3271 0f50 892B      		or r24,r25
 3272 0f52 01F4      		brne .+2
 3273 0f54 00C0      		rjmp .L94
 698:main.c        ****         		if( inRange( splitString(myUartString), 2358, 0 ) )
 3274               		.loc 3 698 0
 3275 0f56 80E0      		ldi r24,lo8(myUartString)
 3276 0f58 90E0      		ldi r25,hi8(myUartString)
 3277 0f5a 0E94 0000 		call splitString
 3278               	.LVL256:
 3279               	.LBB252:
 3280               	.LBB253:
 503:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 3281               		.loc 3 503 0
 3282 0f5e 6733      		cpi r22,55
 3283 0f60 7940      		sbci r23,9
 3284 0f62 8105      		cpc r24,__zero_reg__
 3285 0f64 9105      		cpc r25,__zero_reg__
 3286 0f66 00F4      		brsh .+2
 3287 0f68 00C0      		rjmp .L144
 3288 0f6a 00C0      		rjmp .L94
 3289               	.LVL257:
 3290               	.L142:
 3291               	.LBE253:
 3292               	.LBE252:
 704:main.c        ****     else if(strcasestr(myUartString,"nixiesleepend") != NULL){
 3293               		.loc 3 704 0
 3294 0f6c 60E0      		ldi r22,lo8(.LC46)
 3295 0f6e 70E0      		ldi r23,hi8(.LC46)
 3296 0f70 80E0      		ldi r24,lo8(myUartString)
 3297 0f72 90E0      		ldi r25,hi8(myUartString)
 3298 0f74 0E94 0000 		call strcasestr
 3299               	.LVL258:
 3300 0f78 892B      		or r24,r25
 3301 0f7a 01F0      		breq .L145
 705:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 3302               		.loc 3 705 0
 3303 0f7c 60E0      		ldi r22,lo8(.LC12)
 3304 0f7e 70E0      		ldi r23,hi8(.LC12)
 3305 0f80 80E0      		ldi r24,lo8(myUartString)
 3306 0f82 90E0      		ldi r25,hi8(myUartString)
 3307 0f84 0E94 0000 		call strcasestr
 3308               	.LVL259:
 3309 0f88 892B      		or r24,r25
 3310 0f8a 01F0      		breq .L146
 706:main.c        ****             print_value("Nixie Sleep End Time", nixiesleepend);
 3311               		.loc 3 706 0
 3312 0f8c 4091 0000 		lds r20,nixiesleepend
 3313 0f90 5091 0000 		lds r21,nixiesleepend+1
 3314 0f94 6091 0000 		lds r22,nixiesleepend+2
 3315 0f98 7091 0000 		lds r23,nixiesleepend+3
 3316 0f9c 80E0      		ldi r24,lo8(.LC47)
 3317 0f9e 90E0      		ldi r25,hi8(.LC47)
 3318 0fa0 00C0      		rjmp .L209
 3319               	.L146:
 708:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 3320               		.loc 3 708 0
 3321 0fa2 60E0      		ldi r22,lo8(.LC14)
 3322 0fa4 70E0      		ldi r23,hi8(.LC14)
 3323 0fa6 80E0      		ldi r24,lo8(myUartString)
 3324 0fa8 90E0      		ldi r25,hi8(myUartString)
 3325 0faa 0E94 0000 		call strcasestr
 3326               	.LVL260:
 3327 0fae 892B      		or r24,r25
 3328 0fb0 01F4      		brne .+2
 3329 0fb2 00C0      		rjmp .L94
 709:main.c        ****         		if( inRange( splitString(myUartString), 2359, nixiesleepstart + 1 ) )
 3330               		.loc 3 709 0
 3331 0fb4 C090 0000 		lds r12,nixiesleepstart
 3332 0fb8 D090 0000 		lds r13,nixiesleepstart+1
 3333 0fbc E090 0000 		lds r14,nixiesleepstart+2
 3334 0fc0 F090 0000 		lds r15,nixiesleepstart+3
 3335 0fc4 8FEF      		ldi r24,-1
 3336 0fc6 C81A      		sub r12,r24
 3337 0fc8 D80A      		sbc r13,r24
 3338 0fca E80A      		sbc r14,r24
 3339 0fcc F80A      		sbc r15,r24
 3340 0fce 80E0      		ldi r24,lo8(myUartString)
 3341 0fd0 90E0      		ldi r25,hi8(myUartString)
 3342 0fd2 0E94 0000 		call splitString
 3343               	.LVL261:
 3344               	.LBB254:
 3345               	.LBB255:
 503:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 3346               		.loc 3 503 0
 3347 0fd6 6C15      		cp r22,r12
 3348 0fd8 7D05      		cpc r23,r13
 3349 0fda 8E05      		cpc r24,r14
 3350 0fdc 9F05      		cpc r25,r15
 3351 0fde 00F4      		brsh .+2
 3352 0fe0 00C0      		rjmp .L94
 3353 0fe2 6833      		cpi r22,56
 3354 0fe4 7940      		sbci r23,9
 3355 0fe6 8105      		cpc r24,__zero_reg__
 3356 0fe8 9105      		cpc r25,__zero_reg__
 3357 0fea 00F4      		brsh .+2
 3358 0fec 00C0      		rjmp .L147
 3359 0fee 00C0      		rjmp .L94
 3360               	.LVL262:
 3361               	.L145:
 3362               	.LBE255:
 3363               	.LBE254:
 716:main.c        ****     else if(strcasestr(myUartString,"getall") != NULL){
 3364               		.loc 3 716 0
 3365 0ff0 60E0      		ldi r22,lo8(.LC48)
 3366 0ff2 70E0      		ldi r23,hi8(.LC48)
 3367 0ff4 80E0      		ldi r24,lo8(myUartString)
 3368 0ff6 90E0      		ldi r25,hi8(myUartString)
 3369 0ff8 0E94 0000 		call strcasestr
 3370               	.LVL263:
 3371 0ffc 892B      		or r24,r25
 3372 0ffe 01F4      		brne .+2
 3373 1000 00C0      		rjmp .L148
 3374               	.LBB256:
 718:main.c        ****     	print_csv( ",", hours );					
 3375               		.loc 3 718 0
 3376 1002 4091 0000 		lds r20,hours
 3377 1006 50E0      		ldi r21,0
 3378 1008 60E0      		ldi r22,0
 3379 100a 70E0      		ldi r23,0
 3380 100c 80E0      		ldi r24,lo8(.LC49)
 3381 100e 90E0      		ldi r25,hi8(.LC49)
 3382 1010 0E94 0000 		call print_csv
 3383               	.LVL264:
 719:main.c        ****     	print_csv( ",", minutes );					
 3384               		.loc 3 719 0
 3385 1014 4091 0000 		lds r20,minutes
 3386 1018 50E0      		ldi r21,0
 3387 101a 60E0      		ldi r22,0
 3388 101c 70E0      		ldi r23,0
 3389 101e 80E0      		ldi r24,lo8(.LC49)
 3390 1020 90E0      		ldi r25,hi8(.LC49)
 3391 1022 0E94 0000 		call print_csv
 3392               	.LVL265:
 720:main.c        ****     	print_csv( ",", seconds );					
 3393               		.loc 3 720 0
 3394 1026 4091 0000 		lds r20,seconds
 3395 102a 50E0      		ldi r21,0
 3396 102c 60E0      		ldi r22,0
 3397 102e 70E0      		ldi r23,0
 3398 1030 80E0      		ldi r24,lo8(.LC49)
 3399 1032 90E0      		ldi r25,hi8(.LC49)
 3400 1034 0E94 0000 		call print_csv
 3401               	.LVL266:
 721:main.c        ****     	print_csv( ",", mscal );					
 3402               		.loc 3 721 0
 3403 1038 4091 0000 		lds r20,mscal
 3404 103c 5091 0000 		lds r21,mscal+1
 3405 1040 6091 0000 		lds r22,mscal+2
 3406 1044 7091 0000 		lds r23,mscal+3
 3407 1048 80E0      		ldi r24,lo8(.LC49)
 3408 104a 90E0      		ldi r25,hi8(.LC49)
 3409 104c 0E94 0000 		call print_csv
 3410               	.LVL267:
 722:main.c        ****     	print_csv( ",", miltime );					
 3411               		.loc 3 722 0
 3412 1050 4091 0000 		lds r20,miltime
 3413 1054 50E0      		ldi r21,0
 3414 1056 60E0      		ldi r22,0
 3415 1058 70E0      		ldi r23,0
 3416 105a 80E0      		ldi r24,lo8(.LC49)
 3417 105c 90E0      		ldi r25,hi8(.LC49)
 3418 105e 0E94 0000 		call print_csv
 3419               	.LVL268:
 723:main.c        ****     	print_csv( ",", year );						
 3420               		.loc 3 723 0
 3421 1062 4091 0000 		lds r20,year
 3422 1066 5091 0000 		lds r21,year+1
 3423 106a 60E0      		ldi r22,0
 3424 106c 70E0      		ldi r23,0
 3425 106e 80E0      		ldi r24,lo8(.LC49)
 3426 1070 90E0      		ldi r25,hi8(.LC49)
 3427 1072 0E94 0000 		call print_csv
 3428               	.LVL269:
 724:main.c        ****     	print_csv( ",", month );					
 3429               		.loc 3 724 0
 3430 1076 4091 0000 		lds r20,month
 3431 107a 50E0      		ldi r21,0
 3432 107c 60E0      		ldi r22,0
 3433 107e 70E0      		ldi r23,0
 3434 1080 80E0      		ldi r24,lo8(.LC49)
 3435 1082 90E0      		ldi r25,hi8(.LC49)
 3436 1084 0E94 0000 		call print_csv
 3437               	.LVL270:
 725:main.c        ****     	print_csv( ",", day );						
 3438               		.loc 3 725 0
 3439 1088 4091 0000 		lds r20,day
 3440 108c 50E0      		ldi r21,0
 3441 108e 60E0      		ldi r22,0
 3442 1090 70E0      		ldi r23,0
 3443 1092 80E0      		ldi r24,lo8(.LC49)
 3444 1094 90E0      		ldi r25,hi8(.LC49)
 3445 1096 0E94 0000 		call print_csv
 3446               	.LVL271:
 726:main.c        ****     	print_csv( ",", celsius );					
 3447               		.loc 3 726 0
 3448 109a 4091 0000 		lds r20,celsius
 3449 109e 50E0      		ldi r21,0
 3450 10a0 60E0      		ldi r22,0
 3451 10a2 70E0      		ldi r23,0
 3452 10a4 80E0      		ldi r24,lo8(.LC49)
 3453 10a6 90E0      		ldi r25,hi8(.LC49)
 3454 10a8 0E94 0000 		call print_csv
 3455               	.LVL272:
 727:main.c        ****     	print_csv( ",", doecho );					
 3456               		.loc 3 727 0
 3457 10ac 4091 0000 		lds r20,doecho
 3458 10b0 50E0      		ldi r21,0
 3459 10b2 60E0      		ldi r22,0
 3460 10b4 70E0      		ldi r23,0
 3461 10b6 80E0      		ldi r24,lo8(.LC49)
 3462 10b8 90E0      		ldi r25,hi8(.LC49)
 3463 10ba 0E94 0000 		call print_csv
 3464               	.LVL273:
 728:main.c        ****     	print_csv( ",", xtalisfast );				
 3465               		.loc 3 728 0
 3466 10be 4091 0000 		lds r20,xtalisfast
 3467 10c2 50E0      		ldi r21,0
 3468 10c4 60E0      		ldi r22,0
 3469 10c6 70E0      		ldi r23,0
 3470 10c8 80E0      		ldi r24,lo8(.LC49)
 3471 10ca 90E0      		ldi r25,hi8(.LC49)
 3472 10cc 0E94 0000 		call print_csv
 3473               	.LVL274:
 729:main.c        ****     	print_csv( ",", showtherm );				
 3474               		.loc 3 729 0
 3475 10d0 4091 0000 		lds r20,showtherm
 3476 10d4 50E0      		ldi r21,0
 3477 10d6 60E0      		ldi r22,0
 3478 10d8 70E0      		ldi r23,0
 3479 10da 80E0      		ldi r24,lo8(.LC49)
 3480 10dc 90E0      		ldi r25,hi8(.LC49)
 3481 10de 0E94 0000 		call print_csv
 3482               	.LVL275:
 730:main.c        ****     	print_csv( ",", showdate );					
 3483               		.loc 3 730 0
 3484 10e2 4091 0000 		lds r20,showdate
 3485 10e6 50E0      		ldi r21,0
 3486 10e8 60E0      		ldi r22,0
 3487 10ea 70E0      		ldi r23,0
 3488 10ec 80E0      		ldi r24,lo8(.LC49)
 3489 10ee 90E0      		ldi r25,hi8(.LC49)
 3490 10f0 0E94 0000 		call print_csv
 3491               	.LVL276:
 731:main.c        ****     	print_csv( ",", toggleled );				
 3492               		.loc 3 731 0
 3493 10f4 4091 0000 		lds r20,toggleled
 3494 10f8 50E0      		ldi r21,0
 3495 10fa 60E0      		ldi r22,0
 3496 10fc 70E0      		ldi r23,0
 3497 10fe 80E0      		ldi r24,lo8(.LC49)
 3498 1100 90E0      		ldi r25,hi8(.LC49)
 3499 1102 0E94 0000 		call print_csv
 3500               	.LVL277:
 732:main.c        ****     	print_csv( ",", nixiesleepstart );			
 3501               		.loc 3 732 0
 3502 1106 4091 0000 		lds r20,nixiesleepstart
 3503 110a 5091 0000 		lds r21,nixiesleepstart+1
 3504 110e 6091 0000 		lds r22,nixiesleepstart+2
 3505 1112 7091 0000 		lds r23,nixiesleepstart+3
 3506 1116 80E0      		ldi r24,lo8(.LC49)
 3507 1118 90E0      		ldi r25,hi8(.LC49)
 3508 111a 0E94 0000 		call print_csv
 3509               	.LVL278:
 733:main.c        ****     	print_csv( ",", nixiesleepend );				
 3510               		.loc 3 733 0
 3511 111e 4091 0000 		lds r20,nixiesleepend
 3512 1122 5091 0000 		lds r21,nixiesleepend+1
 3513 1126 6091 0000 		lds r22,nixiesleepend+2
 3514 112a 7091 0000 		lds r23,nixiesleepend+3
 3515 112e 80E0      		ldi r24,lo8(.LC49)
 3516 1130 90E0      		ldi r25,hi8(.LC49)
 3517 1132 0E94 0000 		call print_csv
 3518               	.LVL279:
 734:main.c        ****     	print_csv( ",", SERIAL_NUMBER );			
 3519               		.loc 3 734 0
 3520 1136 44E6      		ldi r20,lo8(100)
 3521 1138 50E0      		ldi r21,0
 3522 113a 60E0      		ldi r22,0
 3523 113c 70E0      		ldi r23,0
 3524 113e 80E0      		ldi r24,lo8(.LC49)
 3525 1140 90E0      		ldi r25,hi8(.LC49)
 3526 1142 0E94 0000 		call print_csv
 3527               	.LVL280:
 737:main.c        ****     	double Volts = adc_raw[0] * 0.019375;
 3528               		.loc 3 737 0
 3529 1146 6091 0000 		lds r22,adc_raw
 3530               	.LVL281:
 3531 114a 70E0      		ldi r23,0
 3532 114c 80E0      		ldi r24,0
 3533 114e 90E0      		ldi r25,0
 3534 1150 0E94 0000 		call __floatsisf
 3535               	.LVL282:
 3536 1154 22E5      		ldi r18,lo8(82)
 3537 1156 38EB      		ldi r19,lo8(-72)
 3538 1158 4EE9      		ldi r20,lo8(-98)
 3539 115a 5CE3      		ldi r21,lo8(60)
 3540 115c 0E94 0000 		call __mulsf3
 3541               	.LVL283:
 738:main.c        ****         dtostrf(Volts , 10, 2, printBuffer);
 3542               		.loc 3 738 0
 3543 1160 00E0      		ldi r16,lo8(printBuffer)
 3544 1162 10E0      		ldi r17,hi8(printBuffer)
 3545 1164 22E0      		ldi r18,lo8(2)
 3546 1166 4AE0      		ldi r20,lo8(10)
 3547 1168 0E94 0000 		call dtostrf
 3548               	.LVL284:
 739:main.c        ****         uart_puts(printBuffer);
 3549               		.loc 3 739 0
 3550 116c C801      		movw r24,r16
 3551 116e 0E94 0000 		call uart_puts
 3552               	.LVL285:
 740:main.c        ****         uart_puts(",");
 3553               		.loc 3 740 0
 3554 1172 80E0      		ldi r24,lo8(.LC49)
 3555 1174 90E0      		ldi r25,hi8(.LC49)
 3556 1176 0E94 0000 		call uart_puts
 3557               	.LVL286:
 743:main.c        ****         Volts = adc_raw[1] * 1.9375;
 3558               		.loc 3 743 0
 3559 117a 6091 0000 		lds r22,adc_raw+1
 3560               	.LVL287:
 3561 117e 70E0      		ldi r23,0
 3562 1180 80E0      		ldi r24,0
 3563 1182 90E0      		ldi r25,0
 3564 1184 0E94 0000 		call __floatsisf
 3565               	.LVL288:
 3566 1188 20E0      		ldi r18,0
 3567 118a 30E0      		ldi r19,0
 3568 118c 48EF      		ldi r20,lo8(-8)
 3569 118e 5FE3      		ldi r21,lo8(63)
 3570 1190 0E94 0000 		call __mulsf3
 3571               	.LVL289:
 744:main.c        ****         dtostrf(Volts , 10, 2, printBuffer);
 3572               		.loc 3 744 0
 3573 1194 22E0      		ldi r18,lo8(2)
 3574 1196 4AE0      		ldi r20,lo8(10)
 3575 1198 0E94 0000 		call dtostrf
 3576               	.LVL290:
 745:main.c        ****         uart_puts(printBuffer);
 3577               		.loc 3 745 0
 3578 119c C801      		movw r24,r16
 3579 119e 0E94 0000 		call uart_puts
 3580               	.LVL291:
 746:main.c        ****         uart_puts(",");
 3581               		.loc 3 746 0
 3582 11a2 80E0      		ldi r24,lo8(.LC49)
 3583 11a4 90E0      		ldi r25,hi8(.LC49)
 3584 11a6 0E94 0000 		call uart_puts
 3585               	.LVL292:
 749:main.c        ****         Volts = adc_raw[2] * 0.019375;
 3586               		.loc 3 749 0
 3587 11aa 6091 0000 		lds r22,adc_raw+2
 3588               	.LVL293:
 3589 11ae 70E0      		ldi r23,0
 3590 11b0 80E0      		ldi r24,0
 3591 11b2 90E0      		ldi r25,0
 3592 11b4 0E94 0000 		call __floatsisf
 3593               	.LVL294:
 3594 11b8 22E5      		ldi r18,lo8(82)
 3595 11ba 38EB      		ldi r19,lo8(-72)
 3596 11bc 4EE9      		ldi r20,lo8(-98)
 3597 11be 5CE3      		ldi r21,lo8(60)
 3598 11c0 0E94 0000 		call __mulsf3
 3599               	.LVL295:
 750:main.c        ****         dtostrf(Volts , 10, 2, printBuffer);
 3600               		.loc 3 750 0
 3601 11c4 22E0      		ldi r18,lo8(2)
 3602 11c6 4AE0      		ldi r20,lo8(10)
 3603 11c8 0E94 0000 		call dtostrf
 3604               	.LVL296:
 751:main.c        ****         uart_puts(printBuffer);
 3605               		.loc 3 751 0
 3606 11cc C801      		movw r24,r16
 3607 11ce 0E94 0000 		call uart_puts
 3608               	.LVL297:
 752:main.c        ****         uart_puts(",");
 3609               		.loc 3 752 0
 3610 11d2 80E0      		ldi r24,lo8(.LC49)
 3611 11d4 90E0      		ldi r25,hi8(.LC49)
 3612 11d6 0E94 0000 		call uart_puts
 3613               	.LVL298:
 755:main.c        ****         Volts = adc_raw[3] * 0.11;
 3614               		.loc 3 755 0
 3615 11da 6091 0000 		lds r22,adc_raw+3
 3616               	.LVL299:
 3617 11de 70E0      		ldi r23,0
 3618 11e0 80E0      		ldi r24,0
 3619 11e2 90E0      		ldi r25,0
 3620 11e4 0E94 0000 		call __floatsisf
 3621               	.LVL300:
 3622 11e8 2EEA      		ldi r18,lo8(-82)
 3623 11ea 37E4      		ldi r19,lo8(71)
 3624 11ec 41EE      		ldi r20,lo8(-31)
 3625 11ee 5DE3      		ldi r21,lo8(61)
 3626 11f0 0E94 0000 		call __mulsf3
 3627               	.LVL301:
 3628 11f4 00C0      		rjmp .L210
 3629               	.L148:
 3630               	.LBE256:
 761:main.c        ****     else if(strcasestr(myUartString,"ramtoeeprom") != NULL){
 3631               		.loc 3 761 0
 3632 11f6 60E0      		ldi r22,lo8(.LC50)
 3633 11f8 70E0      		ldi r23,hi8(.LC50)
 3634 11fa 80E0      		ldi r24,lo8(myUartString)
 3635 11fc 90E0      		ldi r25,hi8(myUartString)
 3636 11fe 0E94 0000 		call strcasestr
 3637               	.LVL302:
 3638 1202 892B      		or r24,r25
 3639 1204 01F0      		breq .L149
 762:main.c        ****     	updateVarsToEeprom();   
 3640               		.loc 3 762 0
 3641 1206 0E94 0000 		call updateVarsToEeprom
 3642               	.LVL303:
 763:main.c        **** 		uart_puts( "EEPROM Storage Complete");
 3643               		.loc 3 763 0
 3644 120a 80E0      		ldi r24,lo8(.LC51)
 3645 120c 90E0      		ldi r25,hi8(.LC51)
 3646 120e 00C0      		rjmp .L211
 3647               	.L149:
 766:main.c        ****     else if(strstr(myUartString,"poke") != NULL){
 3648               		.loc 3 766 0
 3649 1210 60E0      		ldi r22,lo8(.LC52)
 3650 1212 70E0      		ldi r23,hi8(.LC52)
 3651 1214 80E0      		ldi r24,lo8(myUartString)
 3652 1216 90E0      		ldi r25,hi8(myUartString)
 3653 1218 0E94 0000 		call strstr
 3654               	.LVL304:
 3655 121c 892B      		or r24,r25
 3656 121e 01F0      		breq .L150
 768:main.c        ****         uart_puts( "Hello!");
 3657               		.loc 3 768 0
 3658 1220 80E0      		ldi r24,lo8(.LC53)
 3659 1222 90E0      		ldi r25,hi8(.LC53)
 3660 1224 0E94 0000 		call uart_puts
 3661               	.LVL305:
 769:main.c        ****         uart_puts( RETURN_NEWLINE );
 3662               		.loc 3 769 0
 3663 1228 80E0      		ldi r24,lo8(.LC3)
 3664 122a 90E0      		ldi r25,hi8(.LC3)
 3665 122c 0E94 0000 		call uart_puts
 3666               	.LVL306:
 770:main.c        ****         uart_puts( "I'm Serial Number: ");
 3667               		.loc 3 770 0
 3668 1230 80E0      		ldi r24,lo8(.LC54)
 3669 1232 90E0      		ldi r25,hi8(.LC54)
 3670 1234 0E94 0000 		call uart_puts
 3671               	.LVL307:
 771:main.c        ****         uart_puts( itoa( SERIAL_NUMBER, printBuffer, 10 ) );
 3672               		.loc 3 771 0
 3673 1238 4AE0      		ldi r20,lo8(10)
 3674 123a 50E0      		ldi r21,0
 3675 123c 60E0      		ldi r22,lo8(printBuffer)
 3676 123e 70E0      		ldi r23,hi8(printBuffer)
 3677 1240 84E6      		ldi r24,lo8(100)
 3678 1242 90E0      		ldi r25,0
 3679 1244 0E94 0000 		call itoa
 3680               	.LVL308:
 3681 1248 00C0      		rjmp .L211
 3682               	.L150:
 775:main.c        ****     else if(strstr(myUartString,"pwrok") != NULL){
 3683               		.loc 3 775 0
 3684 124a 60E0      		ldi r22,lo8(.LC55)
 3685 124c 70E0      		ldi r23,hi8(.LC55)
 3686 124e 80E0      		ldi r24,lo8(myUartString)
 3687 1250 90E0      		ldi r25,hi8(myUartString)
 3688 1252 0E94 0000 		call strstr
 3689               	.LVL309:
 3690 1256 892B      		or r24,r25
 3691 1258 01F0      		breq .L151
 3692               	.LBB257:
 777:main.c        ****         double pwrokVolts = adc_raw[0] * 0.019375;
 3693               		.loc 3 777 0
 3694 125a 6091 0000 		lds r22,adc_raw
 3695               	.LVL310:
 3696 125e 00C0      		rjmp .L213
 3697               	.LVL311:
 3698               	.L151:
 3699               	.LBE257:
 782:main.c        ****     else if(strstr(myUartString,"hvfeedback") != NULL){
 3700               		.loc 3 782 0
 3701 1260 60E0      		ldi r22,lo8(.LC56)
 3702 1262 70E0      		ldi r23,hi8(.LC56)
 3703 1264 80E0      		ldi r24,lo8(myUartString)
 3704 1266 90E0      		ldi r25,hi8(myUartString)
 3705 1268 0E94 0000 		call strstr
 3706               	.LVL312:
 3707 126c 892B      		or r24,r25
 3708 126e 01F0      		breq .L152
 3709               	.LBB258:
 784:main.c        ****         double hvVolts = adc_raw[1] * 1.9375;
 3710               		.loc 3 784 0
 3711 1270 6091 0000 		lds r22,adc_raw+1
 3712               	.LVL313:
 3713 1274 70E0      		ldi r23,0
 3714 1276 80E0      		ldi r24,0
 3715 1278 90E0      		ldi r25,0
 3716 127a 0E94 0000 		call __floatsisf
 3717               	.LVL314:
 3718 127e 20E0      		ldi r18,0
 3719 1280 30E0      		ldi r19,0
 3720 1282 48EF      		ldi r20,lo8(-8)
 3721 1284 5FE3      		ldi r21,lo8(63)
 3722 1286 00C0      		rjmp .L212
 3723               	.L152:
 3724               	.LBE258:
 789:main.c        ****     else if(strstr(myUartString,"battvoltage") != NULL){
 3725               		.loc 3 789 0
 3726 1288 60E0      		ldi r22,lo8(.LC57)
 3727 128a 70E0      		ldi r23,hi8(.LC57)
 3728 128c 80E0      		ldi r24,lo8(myUartString)
 3729 128e 90E0      		ldi r25,hi8(myUartString)
 3730 1290 0E94 0000 		call strstr
 3731               	.LVL315:
 3732 1294 892B      		or r24,r25
 3733 1296 01F0      		breq .L153
 3734               	.LBB259:
 791:main.c        ****         double battVolts = adc_raw[2] * 0.019375;
 3735               		.loc 3 791 0
 3736 1298 6091 0000 		lds r22,adc_raw+2
 3737               	.L213:
 3738               	.LVL316:
 3739 129c 70E0      		ldi r23,0
 3740 129e 80E0      		ldi r24,0
 3741 12a0 90E0      		ldi r25,0
 3742 12a2 0E94 0000 		call __floatsisf
 3743               	.LVL317:
 3744 12a6 22E5      		ldi r18,lo8(82)
 3745 12a8 38EB      		ldi r19,lo8(-72)
 3746 12aa 4EE9      		ldi r20,lo8(-98)
 3747 12ac 5CE3      		ldi r21,lo8(60)
 3748 12ae 00C0      		rjmp .L212
 3749               	.L153:
 3750               	.LBE259:
 796:main.c        ****     else if(strstr(myUartString,"rectifiedac") != NULL){
 3751               		.loc 3 796 0
 3752 12b0 60E0      		ldi r22,lo8(.LC58)
 3753 12b2 70E0      		ldi r23,hi8(.LC58)
 3754 12b4 80E0      		ldi r24,lo8(myUartString)
 3755 12b6 90E0      		ldi r25,hi8(myUartString)
 3756 12b8 0E94 0000 		call strstr
 3757               	.LVL318:
 3758 12bc 892B      		or r24,r25
 3759 12be 01F0      		breq .L94
 3760               	.LBB260:
 800:main.c        ****         double rectVolts = adc_raw[3] * 0.11;
 3761               		.loc 3 800 0
 3762 12c0 6091 0000 		lds r22,adc_raw+3
 3763               	.LVL319:
 3764 12c4 70E0      		ldi r23,0
 3765 12c6 80E0      		ldi r24,0
 3766 12c8 90E0      		ldi r25,0
 3767 12ca 0E94 0000 		call __floatsisf
 3768               	.LVL320:
 3769 12ce 2EEA      		ldi r18,lo8(-82)
 3770 12d0 37E4      		ldi r19,lo8(71)
 3771 12d2 41EE      		ldi r20,lo8(-31)
 3772 12d4 5DE3      		ldi r21,lo8(61)
 3773               	.L212:
 3774 12d6 0E94 0000 		call __mulsf3
 3775               	.LVL321:
 801:main.c        ****         dtostrf(rectVolts , 10, 2, printBuffer);
 3776               		.loc 3 801 0
 3777 12da 00E0      		ldi r16,lo8(printBuffer)
 3778 12dc 10E0      		ldi r17,hi8(printBuffer)
 3779               	.L210:
 3780 12de 22E0      		ldi r18,lo8(2)
 3781 12e0 4AE0      		ldi r20,lo8(10)
 3782 12e2 0E94 0000 		call dtostrf
 3783               	.LVL322:
 802:main.c        ****         uart_puts(printBuffer);
 3784               		.loc 3 802 0
 3785 12e6 C801      		movw r24,r16
 3786               	.L211:
 3787 12e8 0E94 0000 		call uart_puts
 3788               	.LVL323:
 3789               	.L94:
 3790               	.LBE260:
 804:main.c        ****     uart_puts( RETURN_NEWLINE );
 3791               		.loc 3 804 0
 3792 12ec 80E0      		ldi r24,lo8(.LC3)
 3793 12ee 90E0      		ldi r25,hi8(.LC3)
 3794               	/* epilogue start */
 805:main.c        **** }
 3795               		.loc 3 805 0
 3796 12f0 1F91      		pop r17
 3797 12f2 0F91      		pop r16
 3798 12f4 FF90      		pop r15
 3799 12f6 EF90      		pop r14
 3800 12f8 DF90      		pop r13
 3801 12fa CF90      		pop r12
 804:main.c        ****     uart_puts( RETURN_NEWLINE );
 3802               		.loc 3 804 0
 3803 12fc 0C94 0000 		jmp uart_puts
 3804               	.LVL324:
 3805               	.L96:
 523:main.c        ****             		hours = splitString(myUartString);
 3806               		.loc 3 523 0
 3807 1300 80E0      		ldi r24,lo8(myUartString)
 3808 1302 90E0      		ldi r25,hi8(myUartString)
 3809 1304 0E94 0000 		call splitString
 3810               	.LVL325:
 3811 1308 6093 0000 		sts hours,r22
 3812 130c 00C0      		rjmp .L94
 3813               	.LVL326:
 3814               	.L100:
 534:main.c        ****             		minutes = splitString(myUartString);
 3815               		.loc 3 534 0
 3816 130e 80E0      		ldi r24,lo8(myUartString)
 3817 1310 90E0      		ldi r25,hi8(myUartString)
 3818 1312 0E94 0000 		call splitString
 3819               	.LVL327:
 3820 1316 6093 0000 		sts minutes,r22
 3821 131a 00C0      		rjmp .L94
 3822               	.LVL328:
 3823               	.L103:
 545:main.c        ****             		seconds = splitString(myUartString);
 3824               		.loc 3 545 0
 3825 131c 80E0      		ldi r24,lo8(myUartString)
 3826 131e 90E0      		ldi r25,hi8(myUartString)
 3827 1320 0E94 0000 		call splitString
 3828               	.LVL329:
 3829 1324 6093 0000 		sts seconds,r22
 3830 1328 00C0      		rjmp .L94
 3831               	.LVL330:
 3832               	.L108:
 567:main.c        ****             		miltime = splitString(myUartString);
 3833               		.loc 3 567 0
 3834 132a 80E0      		ldi r24,lo8(myUartString)
 3835 132c 90E0      		ldi r25,hi8(myUartString)
 3836 132e 0E94 0000 		call splitString
 3837               	.LVL331:
 3838 1332 6093 0000 		sts miltime,r22
 3839 1336 00C0      		rjmp .L94
 3840               	.LVL332:
 3841               	.L111:
 578:main.c        ****             		year = splitString(myUartString);
 3842               		.loc 3 578 0
 3843 1338 80E0      		ldi r24,lo8(myUartString)
 3844 133a 90E0      		ldi r25,hi8(myUartString)
 3845 133c 0E94 0000 		call splitString
 3846               	.LVL333:
 3847 1340 7093 0000 		sts year+1,r23
 3848 1344 6093 0000 		sts year,r22
 3849 1348 00C0      		rjmp .L94
 3850               	.LVL334:
 3851               	.L114:
 589:main.c        ****             		month = splitString(myUartString);
 3852               		.loc 3 589 0
 3853 134a 80E0      		ldi r24,lo8(myUartString)
 3854 134c 90E0      		ldi r25,hi8(myUartString)
 3855 134e 0E94 0000 		call splitString
 3856               	.LVL335:
 3857 1352 6093 0000 		sts month,r22
 3858 1356 00C0      		rjmp .L94
 3859               	.LVL336:
 3860               	.L117:
 600:main.c        ****             		day = splitString(myUartString);
 3861               		.loc 3 600 0
 3862 1358 80E0      		ldi r24,lo8(myUartString)
 3863 135a 90E0      		ldi r25,hi8(myUartString)
 3864 135c 0E94 0000 		call splitString
 3865               	.LVL337:
 3866 1360 6093 0000 		sts day,r22
 3867 1364 00C0      		rjmp .L94
 3868               	.LVL338:
 3869               	.L120:
 611:main.c        ****             		celsius = splitString(myUartString);
 3870               		.loc 3 611 0
 3871 1366 80E0      		ldi r24,lo8(myUartString)
 3872 1368 90E0      		ldi r25,hi8(myUartString)
 3873 136a 0E94 0000 		call splitString
 3874               	.LVL339:
 3875 136e 6093 0000 		sts celsius,r22
 3876 1372 00C0      		rjmp .L94
 3877               	.LVL340:
 3878               	.L123:
 622:main.c        ****             		doecho = splitString(myUartString);
 3879               		.loc 3 622 0
 3880 1374 80E0      		ldi r24,lo8(myUartString)
 3881 1376 90E0      		ldi r25,hi8(myUartString)
 3882 1378 0E94 0000 		call splitString
 3883               	.LVL341:
 3884 137c 6093 0000 		sts doecho,r22
 3885 1380 00C0      		rjmp .L94
 3886               	.LVL342:
 3887               	.L126:
 633:main.c        ****             		acclock = splitString(myUartString);
 3888               		.loc 3 633 0
 3889 1382 80E0      		ldi r24,lo8(myUartString)
 3890 1384 90E0      		ldi r25,hi8(myUartString)
 3891 1386 0E94 0000 		call splitString
 3892               	.LVL343:
 3893 138a 6093 0000 		sts acclock,r22
 3894 138e 00C0      		rjmp .L94
 3895               	.LVL344:
 3896               	.L129:
 644:main.c        ****             		xtalisfast = splitString(myUartString);
 3897               		.loc 3 644 0
 3898 1390 80E0      		ldi r24,lo8(myUartString)
 3899 1392 90E0      		ldi r25,hi8(myUartString)
 3900 1394 0E94 0000 		call splitString
 3901               	.LVL345:
 3902 1398 6093 0000 		sts xtalisfast,r22
 3903 139c 00C0      		rjmp .L94
 3904               	.LVL346:
 3905               	.L132:
 655:main.c        ****             		showtherm = splitString(myUartString);
 3906               		.loc 3 655 0
 3907 139e 80E0      		ldi r24,lo8(myUartString)
 3908 13a0 90E0      		ldi r25,hi8(myUartString)
 3909 13a2 0E94 0000 		call splitString
 3910               	.LVL347:
 3911 13a6 6093 0000 		sts showtherm,r22
 3912 13aa 00C0      		rjmp .L94
 3913               	.LVL348:
 3914               	.L135:
 666:main.c        ****             		showfreq = splitString(myUartString);
 3915               		.loc 3 666 0
 3916 13ac 80E0      		ldi r24,lo8(myUartString)
 3917 13ae 90E0      		ldi r25,hi8(myUartString)
 3918 13b0 0E94 0000 		call splitString
 3919               	.LVL349:
 3920 13b4 6093 0000 		sts showfreq,r22
 3921 13b8 00C0      		rjmp .L94
 3922               	.LVL350:
 3923               	.L138:
 677:main.c        ****             		showdate = splitString(myUartString);
 3924               		.loc 3 677 0
 3925 13ba 80E0      		ldi r24,lo8(myUartString)
 3926 13bc 90E0      		ldi r25,hi8(myUartString)
 3927 13be 0E94 0000 		call splitString
 3928               	.LVL351:
 3929 13c2 6093 0000 		sts showdate,r22
 3930 13c6 00C0      		rjmp .L94
 3931               	.LVL352:
 3932               	.L141:
 688:main.c        ****             		toggleled = splitString(myUartString);
 3933               		.loc 3 688 0
 3934 13c8 80E0      		ldi r24,lo8(myUartString)
 3935 13ca 90E0      		ldi r25,hi8(myUartString)
 3936 13cc 0E94 0000 		call splitString
 3937               	.LVL353:
 3938 13d0 6093 0000 		sts toggleled,r22
 3939 13d4 00C0      		rjmp .L94
 3940               	.LVL354:
 3941               	.L144:
 699:main.c        ****             		nixiesleepstart = splitString(myUartString);
 3942               		.loc 3 699 0
 3943 13d6 80E0      		ldi r24,lo8(myUartString)
 3944 13d8 90E0      		ldi r25,hi8(myUartString)
 3945 13da 0E94 0000 		call splitString
 3946               	.LVL355:
 3947 13de 6093 0000 		sts nixiesleepstart,r22
 3948 13e2 7093 0000 		sts nixiesleepstart+1,r23
 3949 13e6 8093 0000 		sts nixiesleepstart+2,r24
 3950 13ea 9093 0000 		sts nixiesleepstart+3,r25
 3951 13ee 00C0      		rjmp .L94
 3952               	.LVL356:
 3953               	.L147:
 710:main.c        ****             		nixiesleepend = splitString(myUartString);
 3954               		.loc 3 710 0
 3955 13f0 80E0      		ldi r24,lo8(myUartString)
 3956 13f2 90E0      		ldi r25,hi8(myUartString)
 3957 13f4 0E94 0000 		call splitString
 3958               	.LVL357:
 3959 13f8 6093 0000 		sts nixiesleepend,r22
 3960 13fc 7093 0000 		sts nixiesleepend+1,r23
 3961 1400 8093 0000 		sts nixiesleepend+2,r24
 3962 1404 9093 0000 		sts nixiesleepend+3,r25
 3963 1408 00C0      		rjmp .L94
 3964               		.cfi_endproc
 3965               	.LFE27:
 3967               	.global	checkSerialIn
 3969               	checkSerialIn:
 3970               	.LFB31:
 848:main.c        **** {
 3971               		.loc 3 848 0
 3972               		.cfi_startproc
 3973 140a CF93      		push r28
 3974               	.LCFI53:
 3975               		.cfi_def_cfa_offset 3
 3976               		.cfi_offset 28, -2
 3977 140c DF93      		push r29
 3978               	.LCFI54:
 3979               		.cfi_def_cfa_offset 4
 3980               		.cfi_offset 29, -3
 3981               	/* prologue: function */
 3982               	/* frame size = 0 */
 3983               	/* stack size = 2 */
 3984               	.L__stack_usage = 2
 850:main.c        ****     unsigned int aChar = uart_getc();
 3985               		.loc 3 850 0
 3986 140e 0E94 0000 		call uart_getc
 3987               	.LVL358:
 3988 1412 EC01      		movw r28,r24
 3989               	.LVL359:
 852:main.c        ****     if ( aChar & UART_NO_DATA )
 3990               		.loc 3 852 0
 3991 1414 90FD      		sbrc r25,0
 3992 1416 00C0      		rjmp .L214
 865:main.c        ****         if ( aChar & UART_FRAME_ERROR )
 3993               		.loc 3 865 0
 3994 1418 93FF      		sbrs r25,3
 3995 141a 00C0      		rjmp .L217
 868:main.c        ****             uart_puts_P("UART Frame Error: ");
 3996               		.loc 3 868 0
 3997 141c 80E0      		ldi r24,lo8(__c.2230)
 3998 141e 90E0      		ldi r25,hi8(__c.2230)
 3999               	.LVL360:
 4000 1420 0E94 0000 		call uart_puts_p
 4001               	.LVL361:
 4002               	.L217:
 870:main.c        ****         if ( aChar & UART_OVERRUN_ERROR )
 4003               		.loc 3 870 0
 4004 1424 D2FF      		sbrs r29,2
 4005 1426 00C0      		rjmp .L218
 877:main.c        ****             uart_puts_P("UART Overrun Error: ");
 4006               		.loc 3 877 0
 4007 1428 80E0      		ldi r24,lo8(__c.2232)
 4008 142a 90E0      		ldi r25,hi8(__c.2232)
 4009 142c 0E94 0000 		call uart_puts_p
 4010               	.LVL362:
 4011               	.L218:
 879:main.c        ****         if ( aChar & UART_BUFFER_OVERFLOW )
 4012               		.loc 3 879 0
 4013 1430 D1FF      		sbrs r29,1
 4014 1432 00C0      		rjmp .L219
 885:main.c        ****             uart_puts_P("Buffer overflow error: ");
 4015               		.loc 3 885 0
 4016 1434 80E0      		ldi r24,lo8(__c.2234)
 4017 1436 90E0      		ldi r25,hi8(__c.2234)
 4018 1438 0E94 0000 		call uart_puts_p
 4019               	.LVL363:
 4020               	.L219:
 892:main.c        ****     uartString[uartStringIndex] = aChar;
 4021               		.loc 3 892 0
 4022 143c 8091 0000 		lds r24,uartStringIndex
 4023 1440 DC2F      		mov r29,r28
 4024 1442 E82F      		mov r30,r24
 4025 1444 F0E0      		ldi r31,0
 4026 1446 E050      		subi r30,lo8(-(uartString))
 4027 1448 F040      		sbci r31,hi8(-(uartString))
 4028 144a C083      		st Z,r28
 895:main.c        ****     if (uartString[uartStringIndex] == CHAR_RETURN) {
 4029               		.loc 3 895 0
 4030 144c CD30      		cpi r28,lo8(13)
 4031 144e 01F4      		brne .L220
 897:main.c        ****         uartStringIndex = 0;
 4032               		.loc 3 897 0
 4033 1450 1092 0000 		sts uartStringIndex,__zero_reg__
 898:main.c        ****         uart_puts(RETURN_NEWLINE);
 4034               		.loc 3 898 0
 4035 1454 80E0      		ldi r24,lo8(.LC3)
 4036 1456 90E0      		ldi r25,hi8(.LC3)
 4037 1458 0E94 0000 		call uart_puts
 4038               	.LVL364:
 900:main.c        ****         copy_command();
 4039               		.loc 3 900 0
 4040 145c 0E94 0000 		call copy_command
 4041               	.LVL365:
 901:main.c        ****         process_command();
 4042               		.loc 3 901 0
 4043 1460 0E94 0000 		call process_command
 4044               	.LVL366:
 4045 1464 00C0      		rjmp .L221
 4046               	.L220:
 904:main.c        ****         uartStringIndex++;
 4047               		.loc 3 904 0
 4048 1466 8F5F      		subi r24,lo8(-(1))
 4049 1468 8093 0000 		sts uartStringIndex,r24
 4050               	.L221:
 907:main.c        ****     if( doecho ){
 4051               		.loc 3 907 0
 4052 146c 8091 0000 		lds r24,doecho
 4053 1470 8823      		tst r24
 4054 1472 01F0      		breq .L214
 908:main.c        ****     	uart_putc( (unsigned char)aChar ); //echo
 4055               		.loc 3 908 0
 4056 1474 8D2F      		mov r24,r29
 4057               	/* epilogue start */
 912:main.c        **** }
 4058               		.loc 3 912 0
 4059 1476 DF91      		pop r29
 4060 1478 CF91      		pop r28
 4061               	.LVL367:
 908:main.c        ****     	uart_putc( (unsigned char)aChar ); //echo
 4062               		.loc 3 908 0
 4063 147a 0C94 0000 		jmp uart_putc
 4064               	.LVL368:
 4065               	.L214:
 4066               	/* epilogue start */
 912:main.c        **** }
 4067               		.loc 3 912 0
 4068 147e DF91      		pop r29
 4069 1480 CF91      		pop r28
 4070               	.LVL369:
 4071 1482 0895      		ret
 4072               		.cfi_endproc
 4073               	.LFE31:
 4075               	.global	acPowerOk
 4077               	acPowerOk:
 4078               	.LFB46:
1317:main.c        **** 
1318:main.c        **** }
1319:main.c        **** 
1320:main.c        **** 
1321:main.c        **** 
1322:main.c        **** 
1323:main.c        **** uint8_t acPowerOk( void )
1324:main.c        **** {
 4079               		.loc 3 1324 0
 4080               		.cfi_startproc
 4081               	/* prologue: function */
 4082               	/* frame size = 0 */
 4083               	/* stack size = 0 */
 4084               	.L__stack_usage = 0
1325:main.c        **** 	if( adc_raw[0] < 51 ){	// If PWR_OK < ~2 V
 4085               		.loc 3 1325 0
 4086 1484 9091 0000 		lds r25,adc_raw
 4087 1488 81E0      		ldi r24,lo8(1)
 4088 148a 9333      		cpi r25,lo8(51)
 4089 148c 00F4      		brsh .L236
 4090 148e 80E0      		ldi r24,0
 4091               	.L236:
1326:main.c        **** 		return 0;
1327:main.c        **** 	}else{
1328:main.c        **** 		return 1;
1329:main.c        **** 	}
1330:main.c        **** 
1331:main.c        **** }
 4092               		.loc 3 1331 0
 4093 1490 0895      		ret
 4094               		.cfi_endproc
 4095               	.LFE46:
 4097               	.global	__vector_11
 4099               	__vector_11:
 4100               	.LFB34:
 953:main.c        **** {
 4101               		.loc 3 953 0
 4102               		.cfi_startproc
 4103 1492 1F92      		push r1
 4104               	.LCFI55:
 4105               		.cfi_def_cfa_offset 3
 4106               		.cfi_offset 1, -2
 4107 1494 0F92      		push r0
 4108               	.LCFI56:
 4109               		.cfi_def_cfa_offset 4
 4110               		.cfi_offset 0, -3
 4111 1496 0FB6      		in r0,__SREG__
 4112 1498 0F92      		push r0
 4113 149a 1124      		clr __zero_reg__
 4114 149c 2F93      		push r18
 4115               	.LCFI57:
 4116               		.cfi_def_cfa_offset 5
 4117               		.cfi_offset 18, -4
 4118 149e 3F93      		push r19
 4119               	.LCFI58:
 4120               		.cfi_def_cfa_offset 6
 4121               		.cfi_offset 19, -5
 4122 14a0 4F93      		push r20
 4123               	.LCFI59:
 4124               		.cfi_def_cfa_offset 7
 4125               		.cfi_offset 20, -6
 4126 14a2 5F93      		push r21
 4127               	.LCFI60:
 4128               		.cfi_def_cfa_offset 8
 4129               		.cfi_offset 21, -7
 4130 14a4 6F93      		push r22
 4131               	.LCFI61:
 4132               		.cfi_def_cfa_offset 9
 4133               		.cfi_offset 22, -8
 4134 14a6 7F93      		push r23
 4135               	.LCFI62:
 4136               		.cfi_def_cfa_offset 10
 4137               		.cfi_offset 23, -9
 4138 14a8 8F93      		push r24
 4139               	.LCFI63:
 4140               		.cfi_def_cfa_offset 11
 4141               		.cfi_offset 24, -10
 4142 14aa 9F93      		push r25
 4143               	.LCFI64:
 4144               		.cfi_def_cfa_offset 12
 4145               		.cfi_offset 25, -11
 4146 14ac AF93      		push r26
 4147               	.LCFI65:
 4148               		.cfi_def_cfa_offset 13
 4149               		.cfi_offset 26, -12
 4150 14ae BF93      		push r27
 4151               	.LCFI66:
 4152               		.cfi_def_cfa_offset 14
 4153               		.cfi_offset 27, -13
 4154 14b0 EF93      		push r30
 4155               	.LCFI67:
 4156               		.cfi_def_cfa_offset 15
 4157               		.cfi_offset 30, -14
 4158 14b2 FF93      		push r31
 4159               	.LCFI68:
 4160               		.cfi_def_cfa_offset 16
 4161               		.cfi_offset 31, -15
 4162               	/* prologue: Signal */
 4163               	/* frame size = 0 */
 4164               	/* stack size = 15 */
 4165               	.L__stack_usage = 15
 4166               	.LVL370:
 958:main.c        ****     milliSeconds++;
 4167               		.loc 3 958 0
 4168 14b4 2091 0000 		lds r18,milliSeconds.2247
 4169 14b8 3091 0000 		lds r19,milliSeconds.2247+1
 4170 14bc 2F5F      		subi r18,-1
 4171 14be 3F4F      		sbci r19,-1
 4172 14c0 3093 0000 		sts milliSeconds.2247+1,r19
 4173 14c4 2093 0000 		sts milliSeconds.2247,r18
 959:main.c        ****     clockCalCounter++;
 4174               		.loc 3 959 0
 4175 14c8 8091 0000 		lds r24,clockCalCounter.2248
 4176 14cc 9091 0000 		lds r25,clockCalCounter.2248+1
 4177 14d0 A091 0000 		lds r26,clockCalCounter.2248+2
 4178 14d4 B091 0000 		lds r27,clockCalCounter.2248+3
 4179 14d8 0196      		adiw r24,1
 4180 14da A11D      		adc r26,__zero_reg__
 4181 14dc B11D      		adc r27,__zero_reg__
 4182 14de 8093 0000 		sts clockCalCounter.2248,r24
 4183 14e2 9093 0000 		sts clockCalCounter.2248+1,r25
 4184 14e6 A093 0000 		sts clockCalCounter.2248+2,r26
 4185 14ea B093 0000 		sts clockCalCounter.2248+3,r27
 962:main.c        ****     if( milliSeconds >= MS_IN_SEC )
 4186               		.loc 3 962 0
 4187 14ee 283E      		cpi r18,-24
 4188 14f0 3340      		sbci r19,3
 4189 14f2 00F0      		brlo .L238
 964:main.c        ****     	if( acclock == 0 || acPowerOk() == 0 ){	// If we are meant to use the internal xtal, not power
 4190               		.loc 3 964 0
 4191 14f4 8091 0000 		lds r24,acclock
 4192 14f8 8111      		cpse r24,__zero_reg__
 4193 14fa 00C0      		rjmp .L239
 4194               	.L241:
 966:main.c        ****         	seconds++;          // increment seconds
 4195               		.loc 3 966 0
 4196 14fc 8091 0000 		lds r24,seconds
 4197 1500 8F5F      		subi r24,lo8(-(1))
 4198 1502 8093 0000 		sts seconds,r24
 4199 1506 00C0      		rjmp .L240
 4200               	.L239:
 964:main.c        ****     	if( acclock == 0 || acPowerOk() == 0 ){	// If we are meant to use the internal xtal, not power
 4201               		.loc 3 964 0 discriminator 1
 4202 1508 0E94 0000 		call acPowerOk
 4203               	.LVL371:
 4204 150c 8823      		tst r24
 4205 150e 01F0      		breq .L241
 4206               	.L240:
 969:main.c        ****         	milliSeconds = 0;   // reset milliseconds
 4207               		.loc 3 969 0
 4208 1510 1092 0000 		sts milliSeconds.2247+1,__zero_reg__
 4209 1514 1092 0000 		sts milliSeconds.2247,__zero_reg__
 971:main.c        ****         	if( toggleled )		// Clearly toggling the LED is only available when using the internal xta
 4210               		.loc 3 971 0
 4211 1518 8091 0000 		lds r24,toggleled
 4212 151c 8111      		cpse r24,__zero_reg__
 972:main.c        ****         		toggle_led();	// Toggle the LED if allowed.
 4213               		.loc 3 972 0
 4214 151e 0E94 0000 		call toggle_led
 4215               	.LVL372:
 4216               	.L242:
 973:main.c        ****         	acFreqFiltCtr++;	// Increment the frequency filter counter.	
 4217               		.loc 3 973 0
 4218 1522 8091 0000 		lds r24,acFreqFiltCtr.2250
 4219 1526 9091 0000 		lds r25,acFreqFiltCtr.2250+1
 4220 152a 0196      		adiw r24,1
 4221 152c 9093 0000 		sts acFreqFiltCtr.2250+1,r25
 4222 1530 8093 0000 		sts acFreqFiltCtr.2250,r24
 4223               	.L238:
 977:main.c        **** 	if( acFreqFiltCtr >= AC_FRQ_FILT_SEC )
 4224               		.loc 3 977 0
 4225 1534 8091 0000 		lds r24,acFreqFiltCtr.2250
 4226 1538 9091 0000 		lds r25,acFreqFiltCtr.2250+1
 4227 153c CC97      		sbiw r24,60
 4228 153e 00F0      		brlo .L243
 979:main.c        **** 		acZeroCrossSnapshot = acZeroCrossCounter;	// Grab the current number of zero crossings since the 
 4229               		.loc 3 979 0
 4230 1540 8091 0000 		lds r24,acZeroCrossCounter
 4231 1544 9091 0000 		lds r25,acZeroCrossCounter+1
 4232 1548 9093 0000 		sts acZeroCrossSnapshot+1,r25
 4233 154c 8093 0000 		sts acZeroCrossSnapshot,r24
 980:main.c        **** 		acZeroCrossCounter = 0;				// Reset the number of zero crossings.
 4234               		.loc 3 980 0
 4235 1550 1092 0000 		sts acZeroCrossCounter+1,__zero_reg__
 4236 1554 1092 0000 		sts acZeroCrossCounter,__zero_reg__
 981:main.c        **** 		acFreqFlag = 1;						// Signal that a computation is ready to be made.
 4237               		.loc 3 981 0
 4238 1558 81E0      		ldi r24,lo8(1)
 4239 155a 8093 0000 		sts acFreqFlag,r24
 982:main.c        **** 		acFreqFiltCtr = 0;					// Reset the measurement interval counter.
 4240               		.loc 3 982 0
 4241 155e 1092 0000 		sts acFreqFiltCtr.2250+1,__zero_reg__
 4242 1562 1092 0000 		sts acFreqFiltCtr.2250,__zero_reg__
 4243               	.L243:
 989:main.c        ****     if( mscal != 0 )
 4244               		.loc 3 989 0
 4245 1566 8091 0000 		lds r24,mscal
 4246 156a 9091 0000 		lds r25,mscal+1
 4247 156e A091 0000 		lds r26,mscal+2
 4248 1572 B091 0000 		lds r27,mscal+3
 4249 1576 892B      		or r24,r25
 4250 1578 8A2B      		or r24,r26
 4251 157a 8B2B      		or r24,r27
 4252 157c 01F4      		brne .+2
 4253 157e 00C0      		rjmp .L244
 991:main.c        ****         if( xtalisfast == 1 )
 4254               		.loc 3 991 0
 4255 1580 2091 0000 		lds r18,xtalisfast
 4256 1584 8091 0000 		lds r24,clockCalCounter.2248
 4257 1588 9091 0000 		lds r25,clockCalCounter.2248+1
 4258 158c A091 0000 		lds r26,clockCalCounter.2248+2
 4259 1590 B091 0000 		lds r27,clockCalCounter.2248+3
 993:main.c        ****             if( ( clockCalCounter >= mscal ) && ( milliSeconds > 1 ))
 4260               		.loc 3 993 0
 4261 1594 4091 0000 		lds r20,mscal
 4262 1598 5091 0000 		lds r21,mscal+1
 4263 159c 6091 0000 		lds r22,mscal+2
 4264 15a0 7091 0000 		lds r23,mscal+3
 991:main.c        ****         if( xtalisfast == 1 )
 4265               		.loc 3 991 0
 4266 15a4 2130      		cpi r18,lo8(1)
 4267 15a6 01F4      		brne .L245
 993:main.c        ****             if( ( clockCalCounter >= mscal ) && ( milliSeconds > 1 ))
 4268               		.loc 3 993 0
 4269 15a8 8417      		cp r24,r20
 4270 15aa 9507      		cpc r25,r21
 4271 15ac A607      		cpc r26,r22
 4272 15ae B707      		cpc r27,r23
 4273 15b0 00F0      		brlo .L244
 993:main.c        ****             if( ( clockCalCounter >= mscal ) && ( milliSeconds > 1 ))
 4274               		.loc 3 993 0 is_stmt 0 discriminator 1
 4275 15b2 2091 0000 		lds r18,milliSeconds.2247
 4276 15b6 3091 0000 		lds r19,milliSeconds.2247+1
 4277 15ba 2230      		cpi r18,2
 4278 15bc 3105      		cpc r19,__zero_reg__
 4279 15be 00F0      		brlo .L244
 995:main.c        ****                 milliSeconds--;
 4280               		.loc 3 995 0 is_stmt 1
 4281 15c0 2150      		subi r18,1
 4282 15c2 3109      		sbc r19,__zero_reg__
 4283 15c4 00C0      		rjmp .L255
 4284               	.L245:
1005:main.c        ****             if( ( clockCalCounter >= mscal ) && ( milliSeconds < MS_IN_SEC - 1 ) )
 4285               		.loc 3 1005 0
 4286 15c6 8417      		cp r24,r20
 4287 15c8 9507      		cpc r25,r21
 4288 15ca A607      		cpc r26,r22
 4289 15cc B707      		cpc r27,r23
 4290 15ce 00F0      		brlo .L244
1005:main.c        ****             if( ( clockCalCounter >= mscal ) && ( milliSeconds < MS_IN_SEC - 1 ) )
 4291               		.loc 3 1005 0 is_stmt 0 discriminator 1
 4292 15d0 2091 0000 		lds r18,milliSeconds.2247
 4293 15d4 3091 0000 		lds r19,milliSeconds.2247+1
 4294 15d8 273E      		cpi r18,-25
 4295 15da 43E0      		ldi r20,3
 4296 15dc 3407      		cpc r19,r20
 4297 15de 00F4      		brsh .L244
1007:main.c        ****                 milliSeconds++;
 4298               		.loc 3 1007 0 is_stmt 1
 4299 15e0 2F5F      		subi r18,-1
 4300 15e2 3F4F      		sbci r19,-1
 4301               	.L255:
 4302 15e4 3093 0000 		sts milliSeconds.2247+1,r19
 4303 15e8 2093 0000 		sts milliSeconds.2247,r18
1012:main.c        ****                 clockCalCounter = clockCalCounter - mscal;
 4304               		.loc 3 1012 0
 4305 15ec 4091 0000 		lds r20,mscal
 4306 15f0 5091 0000 		lds r21,mscal+1
 4307 15f4 6091 0000 		lds r22,mscal+2
 4308 15f8 7091 0000 		lds r23,mscal+3
 4309 15fc 841B      		sub r24,r20
 4310 15fe 950B      		sbc r25,r21
 4311 1600 A60B      		sbc r26,r22
 4312 1602 B70B      		sbc r27,r23
 4313 1604 8093 0000 		sts clockCalCounter.2248,r24
 4314 1608 9093 0000 		sts clockCalCounter.2248+1,r25
 4315 160c A093 0000 		sts clockCalCounter.2248+2,r26
 4316 1610 B093 0000 		sts clockCalCounter.2248+3,r27
 4317               	.L244:
1017:main.c        ****     updateBoostConverter();	// Updated here for determinism.
 4318               		.loc 3 1017 0
 4319 1614 0E94 0000 		call updateBoostConverter
 4320               	.LVL373:
 4321               	/* epilogue start */
1018:main.c        **** }
 4322               		.loc 3 1018 0
 4323 1618 FF91      		pop r31
 4324 161a EF91      		pop r30
 4325 161c BF91      		pop r27
 4326 161e AF91      		pop r26
 4327 1620 9F91      		pop r25
 4328 1622 8F91      		pop r24
 4329 1624 7F91      		pop r23
 4330 1626 6F91      		pop r22
 4331 1628 5F91      		pop r21
 4332 162a 4F91      		pop r20
 4333 162c 3F91      		pop r19
 4334 162e 2F91      		pop r18
 4335 1630 0F90      		pop r0
 4336 1632 0FBE      		out __SREG__,r0
 4337 1634 0F90      		pop r0
 4338 1636 1F90      		pop r1
 4339 1638 1895      		reti
 4340               		.cfi_endproc
 4341               	.LFE34:
 4343               	.global	turnOnOffBoostConverter
 4345               	turnOnOffBoostConverter:
 4346               	.LFB48:
1332:main.c        **** 
1333:main.c        **** 
1334:main.c        **** 
1335:main.c        **** 
1336:main.c        **** void updateNixieOutputState( void )
1337:main.c        **** {
1338:main.c        **** 	uint16_t aTimeToCompare = 0;
1339:main.c        **** 	
1340:main.c        **** 	// Check to see if we have lost AC power.
1341:main.c        **** 	
1342:main.c        **** 	
1343:main.c        **** 	if( acPowerOk() == 0 )			// If we have lost AC power.
1344:main.c        **** 	{
1345:main.c        **** 		//
1346:main.c        **** 		turnOnOffBoostConverter( 0 );	// Turn off the boost converter.
1347:main.c        **** 		return;						// Leave.
1348:main.c        **** 	}
1349:main.c        **** 	
1350:main.c        **** 
1351:main.c        **** 		// Check to see if the nixies will go to sleep at night.
1352:main.c        **** 		if( nixiesleepstart != 0 )
1353:main.c        **** 		{
1354:main.c        **** 			// We aren't really comparing time here, just some integers.
1355:main.c        **** 			// This is because 10 AM is stored as 10000 in the sleep time vars.
1356:main.c        **** 			// This is OK, as it works out mathematically the same.
1357:main.c        **** 			
1358:main.c        **** 			aTimeToCompare = ( hours * 100 ) + minutes;
1359:main.c        **** 			
1360:main.c        **** 			// If the turn back ON time is the next day, it could be a smaller number than the turn OFF time
1361:main.c        **** 			// If the turn back ON time is the same day, it could be a larger  number than the turn OFF time
1362:main.c        **** 			// This matters due to the logic of checking if you are "inside" or "outside" the time window.
1363:main.c        **** 			
1364:main.c        **** 			// For turn ON/OFF times that are on the same day, the turn OFF time is smaller than the turn ON
1365:main.c        **** 			if( nixiesleepend >= nixiesleepstart ){
1366:main.c        **** 				// Check to see if the time is in the sleep window.
1367:main.c        **** 				if( aTimeToCompare >= nixiesleepstart && aTimeToCompare < nixiesleepend )
1368:main.c        **** 				{
1369:main.c        **** 					turnOnOffBoostConverter( 0 );	// Turn off the boost converter.
1370:main.c        **** 					return;
1371:main.c        **** 				}
1372:main.c        **** 			}else{	// For turn ON/OFF times that are on different days, the turn OFF time is larger than the
1373:main.c        **** 				// Check to see if the time is in the sleep window.
1374:main.c        **** 				if( aTimeToCompare >= nixiesleepstart || aTimeToCompare < nixiesleepend ) 
1375:main.c        **** 				{
1376:main.c        **** 					turnOnOffBoostConverter( 0 );	// Turn off the boost converter.
1377:main.c        **** 					return;
1378:main.c        **** 				}
1379:main.c        **** 			}
1380:main.c        **** 		}
1381:main.c        **** 		
1382:main.c        **** 	// Otherwise, the voltage is good, and the nixie sleep window is either not now or is inactive.
1383:main.c        **** 	turnOnOffBoostConverter( 1 );	// Turn on the boost converter.
1384:main.c        **** 	
1385:main.c        **** }
1386:main.c        **** 
1387:main.c        **** 
1388:main.c        **** // Very important to use this function to turn ON or OFF the boost converter.  Read below to find o
1389:main.c        **** // Send 1 to turn ON, send 0 ( or anything else ) to turn OFF
1390:main.c        **** void turnOnOffBoostConverter( uint8_t state )
1391:main.c        **** {
 4347               		.loc 3 1391 0
 4348               		.cfi_startproc
 4349               	.LVL374:
 4350               	/* prologue: function */
 4351               	/* frame size = 0 */
 4352               	/* stack size = 0 */
 4353               	.L__stack_usage = 0
1392:main.c        **** 	if( state ){
 4354               		.loc 3 1392 0
 4355 163a 8823      		tst r24
 4356 163c 01F0      		breq .L257
 4357               	.LBB263:
 4358               	.LBB264:
1393:main.c        **** 		TCCR0A |= ( 1 << COM0A1 );	// Connect the output pin to the PWM controller.
 4359               		.loc 3 1393 0
 4360 163e 84B5      		in r24,0x24
 4361               	.LVL375:
 4362 1640 8068      		ori r24,lo8(-128)
 4363 1642 84BD      		out 0x24,r24
 4364 1644 0895      		ret
 4365               	.LVL376:
 4366               	.L257:
 4367               	.LBE264:
 4368               	.LBE263:
1394:main.c        **** 	}
1395:main.c        **** 	else{
1396:main.c        **** 		TCCR0A &= ~( 1 << COM0A1 );	// Disconnect the output pin from the PWM controller.
 4369               		.loc 3 1396 0
 4370 1646 84B5      		in r24,0x24
 4371               	.LVL377:
 4372 1648 8F77      		andi r24,lo8(127)
 4373 164a 84BD      		out 0x24,r24
1397:main.c        **** 		PORTD &= ~( 1 << F_BOOST );	// Set the output pin low, otherwise you will have a direct short 
 4374               		.loc 3 1397 0
 4375 164c 5E98      		cbi 0xb,6
 4376 164e 0895      		ret
 4377               		.cfi_endproc
 4378               	.LFE48:
 4380               	.global	updateNixieOutputState
 4382               	updateNixieOutputState:
 4383               	.LFB47:
1337:main.c        **** {
 4384               		.loc 3 1337 0
 4385               		.cfi_startproc
 4386 1650 0F93      		push r16
 4387               	.LCFI69:
 4388               		.cfi_def_cfa_offset 3
 4389               		.cfi_offset 16, -2
 4390 1652 1F93      		push r17
 4391               	.LCFI70:
 4392               		.cfi_def_cfa_offset 4
 4393               		.cfi_offset 17, -3
 4394               	/* prologue: function */
 4395               	/* frame size = 0 */
 4396               	/* stack size = 2 */
 4397               	.L__stack_usage = 2
 4398               	.LVL378:
1343:main.c        **** 	if( acPowerOk() == 0 )			// If we have lost AC power.
 4399               		.loc 3 1343 0
 4400 1654 0E94 0000 		call acPowerOk
 4401               	.LVL379:
 4402 1658 8111      		cpse r24,__zero_reg__
 4403 165a 00C0      		rjmp .L260
 4404               	.LVL380:
 4405               	.L263:
1346:main.c        **** 		turnOnOffBoostConverter( 0 );	// Turn off the boost converter.
 4406               		.loc 3 1346 0
 4407 165c 80E0      		ldi r24,0
 4408               	/* epilogue start */
1385:main.c        **** }
 4409               		.loc 3 1385 0
 4410 165e 1F91      		pop r17
 4411 1660 0F91      		pop r16
1346:main.c        **** 		turnOnOffBoostConverter( 0 );	// Turn off the boost converter.
 4412               		.loc 3 1346 0
 4413 1662 0C94 0000 		jmp turnOnOffBoostConverter
 4414               	.LVL381:
 4415               	.L260:
1352:main.c        **** 		if( nixiesleepstart != 0 )
 4416               		.loc 3 1352 0
 4417 1666 4091 0000 		lds r20,nixiesleepstart
 4418 166a 5091 0000 		lds r21,nixiesleepstart+1
 4419 166e 6091 0000 		lds r22,nixiesleepstart+2
 4420 1672 7091 0000 		lds r23,nixiesleepstart+3
 4421 1676 4115      		cp r20,__zero_reg__
 4422 1678 5105      		cpc r21,__zero_reg__
 4423 167a 6105      		cpc r22,__zero_reg__
 4424 167c 7105      		cpc r23,__zero_reg__
 4425 167e 01F0      		breq .L261
1358:main.c        **** 			aTimeToCompare = ( hours * 100 ) + minutes;
 4426               		.loc 3 1358 0
 4427 1680 2091 0000 		lds r18,hours
 4428 1684 8091 0000 		lds r24,minutes
 4429 1688 90E0      		ldi r25,0
 4430 168a 34E6      		ldi r19,lo8(100)
 4431 168c 239F      		mul r18,r19
 4432 168e 800D      		add r24,r0
 4433 1690 911D      		adc r25,r1
 4434 1692 1124      		clr __zero_reg__
 4435               	.LVL382:
1365:main.c        **** 			if( nixiesleepend >= nixiesleepstart ){
 4436               		.loc 3 1365 0
 4437 1694 0091 0000 		lds r16,nixiesleepend
 4438 1698 1091 0000 		lds r17,nixiesleepend+1
 4439 169c 2091 0000 		lds r18,nixiesleepend+2
 4440 16a0 3091 0000 		lds r19,nixiesleepend+3
 4441 16a4 AA27      		clr r26
 4442 16a6 97FD      		sbrc r25,7
 4443 16a8 A095      		com r26
 4444 16aa BA2F      		mov r27,r26
 4445 16ac 0417      		cp r16,r20
 4446 16ae 1507      		cpc r17,r21
 4447 16b0 2607      		cpc r18,r22
 4448 16b2 3707      		cpc r19,r23
 4449 16b4 00F0      		brlo .L262
1367:main.c        **** 				if( aTimeToCompare >= nixiesleepstart && aTimeToCompare < nixiesleepend )
 4450               		.loc 3 1367 0
 4451 16b6 8417      		cp r24,r20
 4452 16b8 9507      		cpc r25,r21
 4453 16ba A607      		cpc r26,r22
 4454 16bc B707      		cpc r27,r23
 4455 16be 00F0      		brlo .L261
 4456 16c0 00C0      		rjmp .L268
 4457               	.L262:
1374:main.c        **** 				if( aTimeToCompare >= nixiesleepstart || aTimeToCompare < nixiesleepend ) 
 4458               		.loc 3 1374 0
 4459 16c2 8417      		cp r24,r20
 4460 16c4 9507      		cpc r25,r21
 4461 16c6 A607      		cpc r26,r22
 4462 16c8 B707      		cpc r27,r23
 4463 16ca 00F4      		brsh .L263
 4464               	.L268:
1374:main.c        **** 				if( aTimeToCompare >= nixiesleepstart || aTimeToCompare < nixiesleepend ) 
 4465               		.loc 3 1374 0 is_stmt 0 discriminator 1
 4466 16cc 8017      		cp r24,r16
 4467 16ce 9107      		cpc r25,r17
 4468 16d0 A207      		cpc r26,r18
 4469 16d2 B307      		cpc r27,r19
 4470 16d4 00F0      		brlo .L263
 4471               	.LVL383:
 4472               	.L261:
 4473               	.LBB269:
 4474               	.LBB270:
 4475               	.LBB271:
1393:main.c        **** 		TCCR0A |= ( 1 << COM0A1 );	// Connect the output pin to the PWM controller.
 4476               		.loc 3 1393 0 is_stmt 1
 4477 16d6 84B5      		in r24,0x24
 4478 16d8 8068      		ori r24,lo8(-128)
 4479 16da 84BD      		out 0x24,r24
 4480               	/* epilogue start */
 4481               	.LBE271:
 4482               	.LBE270:
 4483               	.LBE269:
1385:main.c        **** }
 4484               		.loc 3 1385 0
 4485 16dc 1F91      		pop r17
 4486 16de 0F91      		pop r16
 4487 16e0 0895      		ret
 4488               		.cfi_endproc
 4489               	.LFE47:
 4491               	.global	updateAcFrequency
 4493               	updateAcFrequency:
 4494               	.LFB49:
1398:main.c        **** 	}								// thru the inductor and burn thru 5 fuses trying to figure it out. 
1399:main.c        **** 									// I have been told that the default state is low, so setting low may
1400:main.c        **** }									// be redundant.  I leave it here as I have not tested this.
1401:main.c        **** 
1402:main.c        **** 
1403:main.c        **** 
1404:main.c        **** 
1405:main.c        **** 
1406:main.c        **** void updateAcFrequency( void )
1407:main.c        **** {
 4495               		.loc 3 1407 0
 4496               		.cfi_startproc
 4497               	/* prologue: function */
 4498               	/* frame size = 0 */
 4499               	/* stack size = 0 */
 4500               	.L__stack_usage = 0
1408:main.c        **** 	if( acFreqFlag )	// acFreqFlag is set in ISR( TIMER1_COMPA_vect ) and cleared here.
 4501               		.loc 3 1408 0
 4502 16e2 8091 0000 		lds r24,acFreqFlag
 4503 16e6 8823      		tst r24
 4504 16e8 01F0      		breq .L269
1409:main.c        **** 	{
1410:main.c        **** 		// If acFreqFlag == 1, then acZeroCrossSnapshot contains the total number of AC waveform 
1411:main.c        **** 		// "zero crossings" in AC_FRQ_FILT_SEC seconds.  Here we just need to compute the average and
1412:main.c        **** 		// stuff the result into acFrequency.
1413:main.c        **** 		// Then, in out main app: The contents of acFrequency is the frequency of the AC line input.
1414:main.c        **** 		
1415:main.c        **** 		acFrequency = ( acZeroCrossSnapshot / ( AC_FRQ_FILT_SEC * 60.0 ) ) * 60.0;
 4505               		.loc 3 1415 0
 4506 16ea 6091 0000 		lds r22,acZeroCrossSnapshot
 4507 16ee 7091 0000 		lds r23,acZeroCrossSnapshot+1
 4508 16f2 80E0      		ldi r24,0
 4509 16f4 90E0      		ldi r25,0
 4510 16f6 0E94 0000 		call __floatunsisf
 4511               	.LVL384:
 4512 16fa 20E0      		ldi r18,0
 4513 16fc 30E0      		ldi r19,0
 4514 16fe 41E6      		ldi r20,lo8(97)
 4515 1700 55E4      		ldi r21,lo8(69)
 4516 1702 0E94 0000 		call __divsf3
 4517               	.LVL385:
 4518 1706 20E0      		ldi r18,0
 4519 1708 30E0      		ldi r19,0
 4520 170a 40E7      		ldi r20,lo8(112)
 4521 170c 52E4      		ldi r21,lo8(66)
 4522 170e 0E94 0000 		call __mulsf3
 4523               	.LVL386:
 4524 1712 AB01      		movw r20,r22
 4525 1714 BC01      		movw r22,r24
 4526 1716 4093 0000 		sts acFrequency,r20
 4527 171a 5093 0000 		sts acFrequency+1,r21
 4528 171e 6093 0000 		sts acFrequency+2,r22
 4529 1722 7093 0000 		sts acFrequency+3,r23
1416:main.c        **** 		
1417:main.c        **** 		// Since a pin change interrupt counts rising and falling edges, there are twice as many events.
1418:main.c        **** 		acFrequency /= 2.0;
 4530               		.loc 3 1418 0
 4531 1726 6091 0000 		lds r22,acFrequency
 4532 172a 7091 0000 		lds r23,acFrequency+1
 4533 172e 8091 0000 		lds r24,acFrequency+2
 4534 1732 9091 0000 		lds r25,acFrequency+3
 4535 1736 20E0      		ldi r18,0
 4536 1738 30E0      		ldi r19,0
 4537 173a 40E0      		ldi r20,0
 4538 173c 5FE3      		ldi r21,lo8(63)
 4539 173e 0E94 0000 		call __mulsf3
 4540               	.LVL387:
 4541 1742 AB01      		movw r20,r22
 4542 1744 BC01      		movw r22,r24
 4543 1746 4093 0000 		sts acFrequency,r20
 4544 174a 5093 0000 		sts acFrequency+1,r21
 4545 174e 6093 0000 		sts acFrequency+2,r22
 4546 1752 7093 0000 		sts acFrequency+3,r23
1419:main.c        **** 		
1420:main.c        **** 		acFreqFlag = 0;	// Reset the counter.
 4547               		.loc 3 1420 0
 4548 1756 1092 0000 		sts acFreqFlag,__zero_reg__
 4549               	.L269:
 4550 175a 0895      		ret
 4551               		.cfi_endproc
 4552               	.LFE49:
 4554               	.global	shiftRegisterPulse
 4556               	shiftRegisterPulse:
 4557               	.LFB52:
1421:main.c        **** 	}
1422:main.c        **** 	
1423:main.c        **** }
1424:main.c        **** 
1425:main.c        **** 
1426:main.c        **** 
1427:main.c        **** 
1428:main.c        **** void antiCathodePoisonPattern( uint16_t delay )
1429:main.c        **** {		
1430:main.c        **** 		// Count up.
1431:main.c        **** 		for( int i = 0; i < 10; i++ ){
1432:main.c        **** 			for( int j = 0; j < 6; j++ ){
1433:main.c        **** 				sendIntegerToNixie( i, 1 );
1434:main.c        **** 			}
1435:main.c        **** 			
1436:main.c        **** 			shiftRegisterSetOutput();
1437:main.c        **** 			_delay_ms( delay );
1438:main.c        **** 		}
1439:main.c        **** 		
1440:main.c        **** 		// Count down.
1441:main.c        **** 		for( int i = 8; i >= 1; i-- ){
1442:main.c        **** 			for( int j = 0; j < 6; j++ ){
1443:main.c        **** 				sendIntegerToNixie( i, 1 );
1444:main.c        **** 			}
1445:main.c        **** 			
1446:main.c        **** 			shiftRegisterSetOutput();
1447:main.c        **** 			_delay_ms( delay );
1448:main.c        **** 		}
1449:main.c        **** }
1450:main.c        **** 
1451:main.c        **** 
1452:main.c        **** 
1453:main.c        **** void checkCathodePoison( void )
1454:main.c        **** {
1455:main.c        **** 		// Anti-poison the cathodes every 30 minutes.
1456:main.c        ****         if( minutes == 30 || minutes == 0){
1457:main.c        ****         	if( cathodePoisonFlag == 1 ){
1458:main.c        ****         		antiCathodePoisonPattern( 250 );
1459:main.c        ****         		antiCathodePoisonPattern( 225 );
1460:main.c        ****         		antiCathodePoisonPattern( 200 );
1461:main.c        ****         		antiCathodePoisonPattern( 175 );
1462:main.c        ****         		antiCathodePoisonPattern( 150 );
1463:main.c        ****         		antiCathodePoisonPattern( 125 );
1464:main.c        ****         		antiCathodePoisonPattern( 100 );
1465:main.c        ****         		antiCathodePoisonPattern( 75 );
1466:main.c        ****         		antiCathodePoisonPattern( 50 );
1467:main.c        ****         		antiCathodePoisonPattern( 25 );
1468:main.c        ****         		antiCathodePoisonPattern( 10 );
1469:main.c        ****         		antiCathodePoisonPattern( 10 );
1470:main.c        ****         		antiCathodePoisonPattern( 5 );
1471:main.c        ****         		cathodePoisonFlag = 0;				// Reset the counter.
1472:main.c        ****         	}
1473:main.c        ****         }	
1474:main.c        **** 
1475:main.c        **** }
1476:main.c        **** 
1477:main.c        **** 
1478:main.c        **** 
1479:main.c        **** void shiftRegisterPulse( void )
1480:main.c        **** {
 4558               		.loc 3 1480 0
 4559               		.cfi_startproc
 4560               	/* prologue: function */
 4561               	/* frame size = 0 */
 4562               	/* stack size = 0 */
 4563               	.L__stack_usage = 0
1481:main.c        **** 
1482:main.c        **** 	PORTD |= ( 1 << SRCLK );		// set the serial clock line high.
 4564               		.loc 3 1482 0
 4565 175c 5C9A      		sbi 0xb,4
1483:main.c        **** 	//_delay_us( 1 );							// No delay
1484:main.c        ****     PORTD &= ~( 1 << SRCLK );	// Set the serial Clock line low.
 4566               		.loc 3 1484 0
 4567 175e 5C98      		cbi 0xb,4
 4568 1760 0895      		ret
 4569               		.cfi_endproc
 4570               	.LFE52:
 4572               	.global	shiftRegisterSetOutput
 4574               	shiftRegisterSetOutput:
 4575               	.LFB53:
1485:main.c        **** 
1486:main.c        **** }
1487:main.c        **** 
1488:main.c        **** 
1489:main.c        **** 
1490:main.c        **** 
1491:main.c        **** void shiftRegisterSetOutput( void )
1492:main.c        **** {
 4576               		.loc 3 1492 0
 4577               		.cfi_startproc
 4578               	/* prologue: function */
 4579               	/* frame size = 0 */
 4580               	/* stack size = 0 */
 4581               	.L__stack_usage = 0
1493:main.c        **** 
1494:main.c        **** 	PORTD |= ( 1 << RCLK );		// set the store output line high.
 4582               		.loc 3 1494 0
 4583 1762 5D9A      		sbi 0xb,5
1495:main.c        **** 	//_delay_us(1);							// No delay, might need a nop or 2.
1496:main.c        ****     PORTD &= ~( 1 << RCLK );	// Set the store output line low.
 4584               		.loc 3 1496 0
 4585 1764 5D98      		cbi 0xb,5
 4586 1766 0895      		ret
 4587               		.cfi_endproc
 4588               	.LFE53:
 4590               	.global	shiftByteOut
 4592               	shiftByteOut:
 4593               	.LFB54:
1497:main.c        ****     //_delay_us(1);							// No delay, might need a nop or 2.
1498:main.c        **** }
1499:main.c        **** 
1500:main.c        **** 
1501:main.c        **** 
1502:main.c        **** 
1503:main.c        **** 
1504:main.c        **** void shiftByteOut( uint8_t byteToShift )
1505:main.c        **** {
 4594               		.loc 3 1505 0
 4595               		.cfi_startproc
 4596               	.LVL388:
 4597 1768 0F93      		push r16
 4598               	.LCFI71:
 4599               		.cfi_def_cfa_offset 3
 4600               		.cfi_offset 16, -2
 4601 176a 1F93      		push r17
 4602               	.LCFI72:
 4603               		.cfi_def_cfa_offset 4
 4604               		.cfi_offset 17, -3
 4605 176c CF93      		push r28
 4606               	.LCFI73:
 4607               		.cfi_def_cfa_offset 5
 4608               		.cfi_offset 28, -4
 4609 176e DF93      		push r29
 4610               	.LCFI74:
 4611               		.cfi_def_cfa_offset 6
 4612               		.cfi_offset 29, -5
 4613               	/* prologue: function */
 4614               	/* frame size = 0 */
 4615               	/* stack size = 4 */
 4616               	.L__stack_usage = 4
1506:main.c        **** 	PORTD &= ~( 1 << RCLK );		// Hold low while transmitting.
 4617               		.loc 3 1506 0
 4618 1770 5D98      		cbi 0xb,5
 4619               	.LVL389:
 4620 1772 C7E0      		ldi r28,lo8(7)
 4621 1774 D0E0      		ldi r29,0
 4622               	.LBB272:
1507:main.c        **** 	
1508:main.c        **** 	for( uint8_t i = 0; i < 8; i++ ) 
1509:main.c        **** 	{
1510:main.c        **** 		// If the MSB is high.
1511:main.c        **** 		if ( byteToShift & _BV( 7 - i ) ){
 4623               		.loc 3 1511 0
 4624 1776 082F      		mov r16,r24
 4625 1778 10E0      		ldi r17,0
 4626               	.LVL390:
 4627               	.L279:
 4628 177a C801      		movw r24,r16
 4629 177c 0C2E      		mov r0,r28
 4630 177e 00C0      		rjmp 2f
 4631               		1:
 4632 1780 9595      		asr r25
 4633 1782 8795      		ror r24
 4634               		2:
 4635 1784 0A94      		dec r0
 4636 1786 02F4      		brpl 1b
 4637 1788 80FF      		sbrs r24,0
 4638 178a 00C0      		rjmp .L277
1512:main.c        **** 		
1513:main.c        ****             PORTD |= ( 1 << SER );	// set the output high
 4639               		.loc 3 1513 0
 4640 178c 5B9A      		sbi 0xb,3
 4641 178e 00C0      		rjmp .L278
 4642               	.L277:
1514:main.c        ****         
1515:main.c        ****         } else {
1516:main.c        ****         
1517:main.c        ****             PORTD &= ~( 1 << SER );	// Set the output low.
 4643               		.loc 3 1517 0
 4644 1790 5B98      		cbi 0xb,3
 4645               	.L278:
1518:main.c        ****         
1519:main.c        ****         }
1520:main.c        ****         
1521:main.c        ****         shiftRegisterPulse();
 4646               		.loc 3 1521 0
 4647 1792 0E94 0000 		call shiftRegisterPulse
 4648               	.LVL391:
 4649 1796 2197      		sbiw r28,1
 4650 1798 00F4      		brcc .L279
 4651               	.LBE272:
1522:main.c        ****     }
1523:main.c        ****     
1524:main.c        ****     PORTD |= ( 1 << RCLK );	
 4652               		.loc 3 1524 0
 4653 179a 5D9A      		sbi 0xb,5
 4654               	/* epilogue start */
1525:main.c        **** 
1526:main.c        **** }
 4655               		.loc 3 1526 0
 4656 179c DF91      		pop r29
 4657 179e CF91      		pop r28
 4658 17a0 1F91      		pop r17
 4659 17a2 0F91      		pop r16
 4660               	.LVL392:
 4661 17a4 0895      		ret
 4662               		.cfi_endproc
 4663               	.LFE54:
 4665               	.global	sendIntegerToNixie
 4667               	sendIntegerToNixie:
 4668               	.LFB55:
1527:main.c        **** 
1528:main.c        **** 
1529:main.c        **** 
1530:main.c        **** 
1531:main.c        **** void sendIntegerToNixie( uint8_t intToSend, uint8_t doDecimal )
1532:main.c        **** {
 4669               		.loc 3 1532 0
 4670               		.cfi_startproc
 4671               	.LVL393:
 4672               	/* prologue: function */
 4673               	/* frame size = 0 */
 4674               	/* stack size = 0 */
 4675               	.L__stack_usage = 0
1533:main.c        **** 	// Sends an int thru a shift register, thru a HV BCD driver and to a Nixie tube.
1534:main.c        **** 	// doDecimal passed in will turn the decimal point inside the nixie ON if 1, off if 0.
1535:main.c        **** /*
1536:main.c        **** //~~~~~~~~~~~~~~~~~~~~~~*********** Nixie Digits to BCD to Byte ***********~~~~~~~~~~~~~~~~~~~~~~~~
1537:main.c        **** 
1538:main.c        **** Nixie Digit		  K155ID BCD		Byte for shift register
1539:main.c        **** 				A	B	C	D
1540:main.c        **** _____________________________________________________________				
1541:main.c        **** 		0		L	L	L	L		0b00000000	
1542:main.c        **** 		1		L	L	L	H		0b00010000
1543:main.c        **** 		2		L	L	H	L		0b00100000
1544:main.c        **** 		3		L	L	H	H		0b00110000		
1545:main.c        **** 		4		L	H	L	L		0b01000000
1546:main.c        **** 		5		L	H	L	H		0b01010000
1547:main.c        **** 		6		L	H	H	L		0b01100000
1548:main.c        **** 		7		L	H	H	H		0b01110000
1549:main.c        **** 		8		H	L	L	L		0b10000000
1550:main.c        **** 		9		H	L	L	H		0b10010000
1551:main.c        ****   Decimal			N/A				0b00001000	// & this with the digit above to turn the decimal ON.
1552:main.c        **** 
1553:main.c        **** //~~~~~~~~~~~~~~~~~~~~~~*********** Nixie Digits to BCD to Byte ***********~~~~~~~~~~~~~~~~~~~~~~~~
1554:main.c        **** */
1555:main.c        **** 
1556:main.c        **** switch ( intToSend ){
 4676               		.loc 3 1556 0
 4677 17a6 8430      		cpi r24,lo8(4)
 4678 17a8 01F0      		breq .L287
 4679 17aa 00F4      		brsh .L293
 4680 17ac 8130      		cpi r24,lo8(1)
 4681 17ae 01F0      		breq .L284
 4682 17b0 00F0      		brlo .L283
 4683 17b2 8230      		cpi r24,lo8(2)
 4684 17b4 01F0      		breq .L285
 4685 17b6 8330      		cpi r24,lo8(3)
 4686 17b8 01F0      		breq .+2
 4687 17ba 00C0      		rjmp .L281
 4688 17bc 00C0      		rjmp .L286
 4689               	.L293:
 4690 17be 8730      		cpi r24,lo8(7)
 4691 17c0 01F0      		breq .L290
 4692 17c2 00F4      		brsh .L294
 4693 17c4 8530      		cpi r24,lo8(5)
 4694 17c6 01F0      		breq .L288
 4695 17c8 8630      		cpi r24,lo8(6)
 4696 17ca 01F0      		breq .+2
 4697 17cc 00C0      		rjmp .L281
 4698 17ce 00C0      		rjmp .L289
 4699               	.L294:
 4700 17d0 8830      		cpi r24,lo8(8)
 4701 17d2 01F0      		breq .L291
 4702 17d4 8930      		cpi r24,lo8(9)
 4703 17d6 01F4      		brne .L281
 4704 17d8 00C0      		rjmp .L292
 4705               	.L283:
1557:main.c        **** 	
1558:main.c        **** 	case 0:
1559:main.c        **** 		if( doDecimal ){
 4706               		.loc 3 1559 0
 4707 17da 6623      		tst r22
 4708 17dc 01F0      		breq .L295
1560:main.c        **** 			shiftByteOut( 0b00000000 | 0b00010000 );
 4709               		.loc 3 1560 0
 4710 17de 80E1      		ldi r24,lo8(16)
 4711               	.LVL394:
 4712 17e0 00C0      		rjmp .L305
 4713               	.LVL395:
 4714               	.L295:
1561:main.c        **** 		}else{
1562:main.c        **** 			shiftByteOut( 0b00000000 );
 4715               		.loc 3 1562 0
 4716 17e2 80E0      		ldi r24,0
 4717               	.LVL396:
 4718 17e4 00C0      		rjmp .L305
 4719               	.LVL397:
 4720               	.L284:
1563:main.c        **** 		}
1564:main.c        **** 	break;
1565:main.c        **** 	
1566:main.c        **** 	
1567:main.c        **** 	case 1:
1568:main.c        **** 	if( doDecimal ){
 4721               		.loc 3 1568 0
 4722 17e6 6623      		tst r22
 4723 17e8 01F0      		breq .L296
1569:main.c        **** 		shiftByteOut( 0b00000001 | 0b00010000 );
 4724               		.loc 3 1569 0
 4725 17ea 81E1      		ldi r24,lo8(17)
 4726               	.LVL398:
 4727 17ec 00C0      		rjmp .L305
 4728               	.LVL399:
 4729               	.L296:
1570:main.c        **** 	}else{
1571:main.c        **** 		shiftByteOut( 0b00000001 );
 4730               		.loc 3 1571 0
 4731 17ee 81E0      		ldi r24,lo8(1)
 4732               	.LVL400:
 4733 17f0 00C0      		rjmp .L305
 4734               	.LVL401:
 4735               	.L285:
1572:main.c        **** 	}
1573:main.c        **** 	break;
1574:main.c        **** 	
1575:main.c        **** 
1576:main.c        **** 	case 2:
1577:main.c        **** 	if( doDecimal ){
 4736               		.loc 3 1577 0
 4737 17f2 6623      		tst r22
 4738 17f4 01F0      		breq .L297
1578:main.c        **** 		shiftByteOut( 0b00000010 | 0b00010000 );
 4739               		.loc 3 1578 0
 4740 17f6 82E1      		ldi r24,lo8(18)
 4741               	.LVL402:
 4742 17f8 00C0      		rjmp .L305
 4743               	.LVL403:
 4744               	.L297:
1579:main.c        **** 	}else{
1580:main.c        **** 		shiftByteOut( 0b00000010 );
 4745               		.loc 3 1580 0
 4746 17fa 82E0      		ldi r24,lo8(2)
 4747               	.LVL404:
 4748 17fc 00C0      		rjmp .L305
 4749               	.LVL405:
 4750               	.L286:
1581:main.c        **** 	}
1582:main.c        **** 	break;
1583:main.c        **** 	
1584:main.c        **** 	
1585:main.c        **** 	case 3:
1586:main.c        **** 	if( doDecimal ){
 4751               		.loc 3 1586 0
 4752 17fe 6623      		tst r22
 4753 1800 01F0      		breq .L298
1587:main.c        **** 		shiftByteOut( 0b00000011 | 0b00010000 );
 4754               		.loc 3 1587 0
 4755 1802 83E1      		ldi r24,lo8(19)
 4756               	.LVL406:
 4757 1804 00C0      		rjmp .L305
 4758               	.LVL407:
 4759               	.L298:
1588:main.c        **** 	}else{
1589:main.c        **** 		shiftByteOut( 0b00000011 );
 4760               		.loc 3 1589 0
 4761 1806 83E0      		ldi r24,lo8(3)
 4762               	.LVL408:
 4763 1808 00C0      		rjmp .L305
 4764               	.LVL409:
 4765               	.L287:
1590:main.c        **** 	}
1591:main.c        **** 	break;
1592:main.c        **** 	
1593:main.c        **** 	
1594:main.c        **** 	case 4:
1595:main.c        **** 	if( doDecimal ){
 4766               		.loc 3 1595 0
 4767 180a 6623      		tst r22
 4768 180c 01F0      		breq .L299
1596:main.c        **** 		shiftByteOut( 0b00000100 | 0b00010000 );
 4769               		.loc 3 1596 0
 4770 180e 84E1      		ldi r24,lo8(20)
 4771               	.LVL410:
 4772 1810 00C0      		rjmp .L305
 4773               	.LVL411:
 4774               	.L299:
1597:main.c        **** 	}else{
1598:main.c        **** 		shiftByteOut( 0b00000100 );
 4775               		.loc 3 1598 0
 4776 1812 84E0      		ldi r24,lo8(4)
 4777               	.LVL412:
 4778 1814 00C0      		rjmp .L305
 4779               	.LVL413:
 4780               	.L288:
1599:main.c        **** 	}
1600:main.c        **** 	break;
1601:main.c        **** 	
1602:main.c        **** 	
1603:main.c        **** 	case 5:
1604:main.c        **** 	if( doDecimal ){
 4781               		.loc 3 1604 0
 4782 1816 6623      		tst r22
 4783 1818 01F0      		breq .L300
1605:main.c        **** 		shiftByteOut( 0b00000101 | 0b00010000 );
 4784               		.loc 3 1605 0
 4785 181a 85E1      		ldi r24,lo8(21)
 4786               	.LVL414:
 4787 181c 00C0      		rjmp .L305
 4788               	.LVL415:
 4789               	.L300:
1606:main.c        **** 	}else{
1607:main.c        **** 		shiftByteOut( 0b00000101 );
 4790               		.loc 3 1607 0
 4791 181e 85E0      		ldi r24,lo8(5)
 4792               	.LVL416:
 4793 1820 00C0      		rjmp .L305
 4794               	.LVL417:
 4795               	.L289:
1608:main.c        **** 	}
1609:main.c        **** 	break;
1610:main.c        **** 	
1611:main.c        **** 	
1612:main.c        **** 	case 6:
1613:main.c        **** 	if( doDecimal ){
 4796               		.loc 3 1613 0
 4797 1822 6623      		tst r22
 4798 1824 01F0      		breq .L301
1614:main.c        **** 		shiftByteOut( 0b00000110 | 0b00010000 );
 4799               		.loc 3 1614 0
 4800 1826 86E1      		ldi r24,lo8(22)
 4801               	.LVL418:
 4802 1828 00C0      		rjmp .L305
 4803               	.LVL419:
 4804               	.L301:
1615:main.c        **** 	}else{
1616:main.c        **** 		shiftByteOut( 0b00000110 );
 4805               		.loc 3 1616 0
 4806 182a 86E0      		ldi r24,lo8(6)
 4807               	.LVL420:
 4808 182c 00C0      		rjmp .L305
 4809               	.LVL421:
 4810               	.L290:
1617:main.c        **** 	}
1618:main.c        **** 	break;
1619:main.c        **** 	
1620:main.c        **** 	
1621:main.c        **** 	case 7:
1622:main.c        **** 	if( doDecimal ){
 4811               		.loc 3 1622 0
 4812 182e 6623      		tst r22
 4813 1830 01F0      		breq .L302
1623:main.c        **** 		shiftByteOut( 0b00000111 | 0b00010000 );
 4814               		.loc 3 1623 0
 4815 1832 87E1      		ldi r24,lo8(23)
 4816               	.LVL422:
 4817 1834 00C0      		rjmp .L305
 4818               	.LVL423:
 4819               	.L302:
1624:main.c        **** 	}else{
1625:main.c        **** 		shiftByteOut( 0b00000111 );
 4820               		.loc 3 1625 0
 4821 1836 87E0      		ldi r24,lo8(7)
 4822               	.LVL424:
 4823 1838 00C0      		rjmp .L305
 4824               	.LVL425:
 4825               	.L291:
1626:main.c        **** 	}
1627:main.c        **** 	break;
1628:main.c        **** 	
1629:main.c        **** 	
1630:main.c        **** 	case 8:
1631:main.c        **** 	if( doDecimal ){
 4826               		.loc 3 1631 0
 4827 183a 6623      		tst r22
 4828 183c 01F0      		breq .L303
1632:main.c        **** 		shiftByteOut( 0b00001000 | 0b00010000 );
 4829               		.loc 3 1632 0
 4830 183e 88E1      		ldi r24,lo8(24)
 4831               	.LVL426:
 4832 1840 00C0      		rjmp .L305
 4833               	.LVL427:
 4834               	.L303:
1633:main.c        **** 	}else{
1634:main.c        **** 		shiftByteOut( 0b00001000 );
 4835               		.loc 3 1634 0
 4836 1842 88E0      		ldi r24,lo8(8)
 4837               	.LVL428:
 4838 1844 00C0      		rjmp .L305
 4839               	.LVL429:
 4840               	.L292:
1635:main.c        **** 	}
1636:main.c        **** 	break;
1637:main.c        **** 	
1638:main.c        **** 	
1639:main.c        **** 	case 9:
1640:main.c        **** 	if( doDecimal ){
 4841               		.loc 3 1640 0
 4842 1846 6623      		tst r22
 4843 1848 01F0      		breq .L304
1641:main.c        **** 		shiftByteOut( 0b00001001 | 0b00010000 );
 4844               		.loc 3 1641 0
 4845 184a 89E1      		ldi r24,lo8(25)
 4846               	.LVL430:
 4847 184c 00C0      		rjmp .L305
 4848               	.LVL431:
 4849               	.L304:
1642:main.c        **** 	}else{
1643:main.c        **** 		shiftByteOut( 0b00001001 );
 4850               		.loc 3 1643 0
 4851 184e 89E0      		ldi r24,lo8(9)
 4852               	.LVL432:
 4853               	.L305:
 4854 1850 0C94 0000 		jmp shiftByteOut
 4855               	.LVL433:
 4856               	.L281:
 4857 1854 0895      		ret
 4858               		.cfi_endproc
 4859               	.LFE55:
 4861               	.global	__ltsf2
 4862               	.global	__gtsf2
 4863               	.global	__fixunssfsi
 4864               	.global	antiCathodePoisonPattern
 4866               	antiCathodePoisonPattern:
 4867               	.LFB50:
1429:main.c        **** {		
 4868               		.loc 3 1429 0
 4869               		.cfi_startproc
 4870               	.LVL434:
 4871 1856 3F92      		push r3
 4872               	.LCFI75:
 4873               		.cfi_def_cfa_offset 3
 4874               		.cfi_offset 3, -2
 4875 1858 4F92      		push r4
 4876               	.LCFI76:
 4877               		.cfi_def_cfa_offset 4
 4878               		.cfi_offset 4, -3
 4879 185a 5F92      		push r5
 4880               	.LCFI77:
 4881               		.cfi_def_cfa_offset 5
 4882               		.cfi_offset 5, -4
 4883 185c 6F92      		push r6
 4884               	.LCFI78:
 4885               		.cfi_def_cfa_offset 6
 4886               		.cfi_offset 6, -5
 4887 185e 7F92      		push r7
 4888               	.LCFI79:
 4889               		.cfi_def_cfa_offset 7
 4890               		.cfi_offset 7, -6
 4891 1860 8F92      		push r8
 4892               	.LCFI80:
 4893               		.cfi_def_cfa_offset 8
 4894               		.cfi_offset 8, -7
 4895 1862 9F92      		push r9
 4896               	.LCFI81:
 4897               		.cfi_def_cfa_offset 9
 4898               		.cfi_offset 9, -8
 4899 1864 AF92      		push r10
 4900               	.LCFI82:
 4901               		.cfi_def_cfa_offset 10
 4902               		.cfi_offset 10, -9
 4903 1866 BF92      		push r11
 4904               	.LCFI83:
 4905               		.cfi_def_cfa_offset 11
 4906               		.cfi_offset 11, -10
 4907 1868 CF92      		push r12
 4908               	.LCFI84:
 4909               		.cfi_def_cfa_offset 12
 4910               		.cfi_offset 12, -11
 4911 186a DF92      		push r13
 4912               	.LCFI85:
 4913               		.cfi_def_cfa_offset 13
 4914               		.cfi_offset 13, -12
 4915 186c EF92      		push r14
 4916               	.LCFI86:
 4917               		.cfi_def_cfa_offset 14
 4918               		.cfi_offset 14, -13
 4919 186e FF92      		push r15
 4920               	.LCFI87:
 4921               		.cfi_def_cfa_offset 15
 4922               		.cfi_offset 15, -14
 4923 1870 0F93      		push r16
 4924               	.LCFI88:
 4925               		.cfi_def_cfa_offset 16
 4926               		.cfi_offset 16, -15
 4927 1872 1F93      		push r17
 4928               	.LCFI89:
 4929               		.cfi_def_cfa_offset 17
 4930               		.cfi_offset 17, -16
 4931 1874 CF93      		push r28
 4932               	.LCFI90:
 4933               		.cfi_def_cfa_offset 18
 4934               		.cfi_offset 28, -17
 4935 1876 DF93      		push r29
 4936               	.LCFI91:
 4937               		.cfi_def_cfa_offset 19
 4938               		.cfi_offset 29, -18
 4939               	/* prologue: function */
 4940               	/* frame size = 0 */
 4941               	/* stack size = 17 */
 4942               	.L__stack_usage = 17
 4943               	.LVL435:
 4944               	.LBB273:
 4945               	.LBB274:
 4946               	.LBB275:
 4947               		.file 4 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h"
   1:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
   6:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
   9:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  12:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  17:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  21:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  33:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  35:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  38:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
  41:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  42:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  46:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     \code
  49:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  54:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     used.
  58:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  59:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  68:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  77:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  81:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** */
  82:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  83:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
  87:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  88:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
  93:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  94:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
  97:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  98:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
 103:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 104:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /**
 105:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 107:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 109:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 112:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 114:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 120:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 125:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 129:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 132:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 140:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****  */
 141:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** void
 142:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** {
 144:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 153:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 156:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 159:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#else
 160:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 164:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 166:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #else
 167:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 4948               		.loc 4 169 0
 4949 1878 10E0      		ldi r17,0
 4950               	.LBE275:
 4951               	.LBE274:
1437:main.c        **** 			_delay_ms( delay );
 4952               		.loc 3 1437 0
 4953 187a 6C01      		movw r12,r24
 4954 187c E12C      		mov r14,__zero_reg__
 4955 187e F12C      		mov r15,__zero_reg__
 4956               	.LBB285:
 4957               	.LBB282:
 4958               	.LBB276:
 4959               	.LBB277:
 4960               		.loc 2 105 0
 4961 1880 C9E9      		ldi r28,lo8(-103)
 4962 1882 D1E0      		ldi r29,lo8(1)
 4963 1884 00C0      		rjmp .L307
 4964               	.LVL436:
 4965               	.L308:
 4966               	.LBE277:
 4967               	.LBE276:
 4968               	.LBE282:
 4969               	.LBE285:
 4970               	.LBB286:
1433:main.c        **** 				sendIntegerToNixie( i, 1 );
 4971               		.loc 3 1433 0 discriminator 2
 4972 1886 61E0      		ldi r22,lo8(1)
 4973 1888 812F      		mov r24,r17
 4974 188a 0E94 0000 		call sendIntegerToNixie
 4975               	.LVL437:
 4976 188e 81E0      		ldi r24,1
 4977 1890 A81A      		sub r10,r24
 4978 1892 B108      		sbc r11,__zero_reg__
1432:main.c        **** 			for( int j = 0; j < 6; j++ ){
 4979               		.loc 3 1432 0 discriminator 2
 4980 1894 01F4      		brne .L308
 4981               	.LBE286:
1436:main.c        **** 			shiftRegisterSetOutput();
 4982               		.loc 3 1436 0
 4983 1896 0E94 0000 		call shiftRegisterSetOutput
 4984               	.LVL438:
1437:main.c        **** 			_delay_ms( delay );
 4985               		.loc 3 1437 0
 4986 189a C701      		movw r24,r14
 4987 189c B601      		movw r22,r12
 4988 189e 0E94 0000 		call __floatunsisf
 4989               	.LVL439:
 4990 18a2 4B01      		movw r8,r22
 4991 18a4 5C01      		movw r10,r24
 4992               	.LVL440:
 4993               	.LBB287:
 4994               	.LBB283:
 167:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 4995               		.loc 4 167 0
 4996 18a6 20E0      		ldi r18,0
 4997 18a8 30E0      		ldi r19,0
 4998 18aa 40E8      		ldi r20,lo8(-128)
 4999 18ac 55E4      		ldi r21,lo8(69)
 5000 18ae 0E94 0000 		call __mulsf3
 5001               	.LVL441:
 5002 18b2 762E      		mov r7,r22
 5003 18b4 672E      		mov r6,r23
 5004 18b6 582E      		mov r5,r24
 5005 18b8 492E      		mov r4,r25
 5006               	.LVL442:
 168:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 5007               		.loc 4 168 0
 5008 18ba 20E0      		ldi r18,0
 5009 18bc 30E0      		ldi r19,0
 5010 18be 40E8      		ldi r20,lo8(-128)
 5011 18c0 5FE3      		ldi r21,lo8(63)
 5012 18c2 D301      		movw r26,r6
 5013 18c4 F201      		movw r30,r4
 5014 18c6 6B2F      		mov r22,r27
 5015 18c8 7A2F      		mov r23,r26
 5016 18ca 8F2F      		mov r24,r31
 5017 18cc 9E2F      		mov r25,r30
 5018 18ce 0E94 0000 		call __ltsf2
 5019               	.LVL443:
 5020 18d2 87FD      		sbrc r24,7
 5021 18d4 00C0      		rjmp .L326
 170:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 5022               		.loc 4 170 0
 5023 18d6 20E0      		ldi r18,0
 5024 18d8 3FEF      		ldi r19,lo8(-1)
 5025 18da 4FE7      		ldi r20,lo8(127)
 5026 18dc 57E4      		ldi r21,lo8(71)
 5027 18de D301      		movw r26,r6
 5028 18e0 F201      		movw r30,r4
 5029 18e2 6B2F      		mov r22,r27
 5030 18e4 7A2F      		mov r23,r26
 5031 18e6 8F2F      		mov r24,r31
 5032 18e8 9E2F      		mov r25,r30
 5033 18ea 0E94 0000 		call __gtsf2
 5034               	.LVL444:
 5035 18ee 1816      		cp __zero_reg__,r24
 5036 18f0 04F4      		brge .L332
 171:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	{
 172:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 5037               		.loc 4 173 0
 5038 18f2 20E0      		ldi r18,0
 5039 18f4 30E0      		ldi r19,0
 5040 18f6 40E2      		ldi r20,lo8(32)
 5041 18f8 51E4      		ldi r21,lo8(65)
 5042 18fa C501      		movw r24,r10
 5043 18fc B401      		movw r22,r8
 5044 18fe 0E94 0000 		call __mulsf3
 5045               	.LVL445:
 5046 1902 0E94 0000 		call __fixunssfsi
 5047               	.LVL446:
 5048 1906 00C0      		rjmp .L312
 5049               	.L313:
 5050               	.LVL447:
 5051               	.LBB279:
 5052               	.LBB278:
 5053               		.loc 2 105 0
 5054 1908 CE01      		movw r24,r28
 5055               	/* #APP */
 5056               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 5057 190a 0197      		1: sbiw r24,1
 5058 190c 01F4      		brne 1b
 5059               	 ;  0 "" 2
 5060               	.LVL448:
 5061               	/* #NOAPP */
 5062               	.LBE278:
 5063               	.LBE279:
 174:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		{
 176:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 			__ticks --;
 5064               		.loc 4 178 0
 5065 190e 6150      		subi r22,1
 5066 1910 7109      		sbc r23,__zero_reg__
 5067               	.LVL449:
 5068               	.L312:
 174:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 5069               		.loc 4 174 0
 5070 1912 6115      		cp r22,__zero_reg__
 5071 1914 7105      		cpc r23,__zero_reg__
 5072 1916 01F4      		brne .L313
 5073 1918 00C0      		rjmp .L314
 5074               	.LVL450:
 5075               	.L332:
 179:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		}
 180:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		return;
 181:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	}
 182:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	else
 183:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 5076               		.loc 4 183 0
 5077 191a A301      		movw r20,r6
 5078 191c 9201      		movw r18,r4
 5079 191e 652F      		mov r22,r21
 5080 1920 742F      		mov r23,r20
 5081 1922 832F      		mov r24,r19
 5082 1924 922F      		mov r25,r18
 5083 1926 0E94 0000 		call __fixunssfsi
 5084               	.LVL451:
 5085 192a 00C0      		rjmp .L309
 5086               	.LVL452:
 5087               	.L326:
 169:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 5088               		.loc 4 169 0
 5089 192c 61E0      		ldi r22,lo8(1)
 5090 192e 70E0      		ldi r23,0
 5091               	.L309:
 5092               	.LVL453:
 5093               	.LBB280:
 5094               	.LBB281:
 5095               		.loc 2 105 0
 5096 1930 CB01      		movw r24,r22
 5097               	/* #APP */
 5098               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 5099 1932 0197      		1: sbiw r24,1
 5100 1934 01F4      		brne 1b
 5101               	 ;  0 "" 2
 5102               	.LVL454:
 5103               	/* #NOAPP */
 5104               	.L314:
 5105 1936 1F5F      		subi r17,lo8(-(1))
 5106               	.LBE281:
 5107               	.LBE280:
 5108               	.LBE283:
 5109               	.LBE287:
1431:main.c        **** 		for( int i = 0; i < 10; i++ ){
 5110               		.loc 3 1431 0
 5111 1938 1A30      		cpi r17,lo8(10)
 5112 193a 01F4      		brne .L307
 5113               	.LBE273:
 5114               	.LBB289:
 5115               	.LBB290:
 5116               	.LBB291:
 5117               		.loc 4 183 0
 5118 193c A301      		movw r20,r6
 5119 193e 9201      		movw r18,r4
 5120 1940 652F      		mov r22,r21
 5121               	.LVL455:
 5122 1942 762D      		mov r23,r6
 5123 1944 832F      		mov r24,r19
 5124 1946 942D      		mov r25,r4
 5125 1948 0E94 0000 		call __fixunssfsi
 5126               	.LVL456:
 5127 194c 8B01      		movw r16,r22
 5128 194e 20E0      		ldi r18,0
 5129 1950 30E0      		ldi r19,0
 5130 1952 40E8      		ldi r20,lo8(-128)
 5131 1954 5FE3      		ldi r21,lo8(63)
 5132 1956 D301      		movw r26,r6
 5133 1958 F201      		movw r30,r4
 5134 195a 6B2F      		mov r22,r27
 5135 195c 762D      		mov r23,r6
 5136 195e 8F2F      		mov r24,r31
 5137 1960 942D      		mov r25,r4
 5138 1962 0E94 0000 		call __ltsf2
 5139               	.LVL457:
 5140 1966 87FF      		sbrs r24,7
 5141 1968 00C0      		rjmp .L333
 5142 196a C1E0      		ldi r28,lo8(1)
 5143 196c D0E0      		ldi r29,0
 5144 196e 00C0      		rjmp .L316
 5145               	.L333:
 5146 1970 E801      		movw r28,r16
 5147               	.L316:
 5148 1972 38E0      		ldi r19,lo8(8)
 5149 1974 332E      		mov r3,r19
 5150               	.LBB292:
 5151               	.LBB293:
 5152               		.loc 2 105 0
 5153 1976 09E9      		ldi r16,lo8(-103)
 5154 1978 11E0      		ldi r17,lo8(1)
 5155 197a 00C0      		rjmp .L318
 5156               	.LVL458:
 5157               	.L307:
 5158               	.LBE293:
 5159               	.LBE292:
 5160               	.LBE291:
 5161               	.LBE290:
 5162               	.LBE289:
1429:main.c        **** {		
 5163               		.loc 3 1429 0 discriminator 1
 5164 197c 26E0      		ldi r18,lo8(6)
 5165 197e A22E      		mov r10,r18
 5166 1980 B12C      		mov r11,__zero_reg__
 5167 1982 00C0      		rjmp .L308
 5168               	.LVL459:
 5169               	.L319:
 5170               	.LBB301:
 5171               	.LBB299:
1443:main.c        **** 				sendIntegerToNixie( i, 1 );
 5172               		.loc 3 1443 0 discriminator 2
 5173 1984 61E0      		ldi r22,lo8(1)
 5174 1986 832D      		mov r24,r3
 5175 1988 0E94 0000 		call sendIntegerToNixie
 5176               	.LVL460:
 5177 198c 81E0      		ldi r24,1
 5178 198e E81A      		sub r14,r24
 5179 1990 F108      		sbc r15,__zero_reg__
1442:main.c        **** 			for( int j = 0; j < 6; j++ ){
 5180               		.loc 3 1442 0 discriminator 2
 5181 1992 01F4      		brne .L319
 5182               	.LBE299:
1446:main.c        **** 			shiftRegisterSetOutput();
 5183               		.loc 3 1446 0
 5184 1994 0E94 0000 		call shiftRegisterSetOutput
 5185               	.LVL461:
 5186               	.LBB300:
 5187               	.LBB298:
 168:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 5188               		.loc 4 168 0
 5189 1998 20E0      		ldi r18,0
 5190 199a 30E0      		ldi r19,0
 5191 199c 40E8      		ldi r20,lo8(-128)
 5192 199e 5FE3      		ldi r21,lo8(63)
 5193 19a0 D301      		movw r26,r6
 5194 19a2 F201      		movw r30,r4
 5195 19a4 6B2F      		mov r22,r27
 5196 19a6 762D      		mov r23,r6
 5197 19a8 8F2F      		mov r24,r31
 5198 19aa 942D      		mov r25,r4
 5199 19ac 0E94 0000 		call __ltsf2
 5200               	.LVL462:
 5201 19b0 87FD      		sbrc r24,7
 5202 19b2 00C0      		rjmp .L320
 170:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 5203               		.loc 4 170 0
 5204 19b4 20E0      		ldi r18,0
 5205 19b6 3FEF      		ldi r19,lo8(-1)
 5206 19b8 4FE7      		ldi r20,lo8(127)
 5207 19ba 57E4      		ldi r21,lo8(71)
 5208 19bc D301      		movw r26,r6
 5209 19be F201      		movw r30,r4
 5210 19c0 6B2F      		mov r22,r27
 5211 19c2 762D      		mov r23,r6
 5212 19c4 8F2F      		mov r24,r31
 5213 19c6 942D      		mov r25,r4
 5214 19c8 0E94 0000 		call __gtsf2
 5215               	.LVL463:
 5216 19cc 1816      		cp __zero_reg__,r24
 5217 19ce 04F4      		brge .L320
 173:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 5218               		.loc 4 173 0
 5219 19d0 20E0      		ldi r18,0
 5220 19d2 30E0      		ldi r19,0
 5221 19d4 40E2      		ldi r20,lo8(32)
 5222 19d6 51E4      		ldi r21,lo8(65)
 5223 19d8 C501      		movw r24,r10
 5224 19da B401      		movw r22,r8
 5225 19dc 0E94 0000 		call __mulsf3
 5226               	.LVL464:
 5227 19e0 0E94 0000 		call __fixunssfsi
 5228               	.LVL465:
 5229 19e4 00C0      		rjmp .L322
 5230               	.L323:
 5231               	.LVL466:
 5232               	.LBB295:
 5233               	.LBB294:
 5234               		.loc 2 105 0
 5235 19e6 C801      		movw r24,r16
 5236               	/* #APP */
 5237               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 5238 19e8 0197      		1: sbiw r24,1
 5239 19ea 01F4      		brne 1b
 5240               	 ;  0 "" 2
 5241               	.LVL467:
 5242               	/* #NOAPP */
 5243               	.LBE294:
 5244               	.LBE295:
 178:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 			__ticks --;
 5245               		.loc 4 178 0
 5246 19ec 6150      		subi r22,1
 5247 19ee 7109      		sbc r23,__zero_reg__
 5248               	.LVL468:
 5249               	.L322:
 174:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 5250               		.loc 4 174 0
 5251 19f0 6115      		cp r22,__zero_reg__
 5252 19f2 7105      		cpc r23,__zero_reg__
 5253 19f4 01F4      		brne .L323
 5254 19f6 00C0      		rjmp .L324
 5255               	.LVL469:
 5256               	.L320:
 5257               	.LBB296:
 5258               	.LBB297:
 5259               		.loc 2 105 0
 5260 19f8 CE01      		movw r24,r28
 5261               	/* #APP */
 5262               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 5263 19fa 0197      		1: sbiw r24,1
 5264 19fc 01F4      		brne 1b
 5265               	 ;  0 "" 2
 5266               	.LVL470:
 5267               	/* #NOAPP */
 5268               	.L324:
 5269 19fe 3A94      		dec r3
 5270               	.LBE297:
 5271               	.LBE296:
 5272               	.LBE298:
 5273               	.LBE300:
1441:main.c        **** 		for( int i = 8; i >= 1; i-- ){
 5274               		.loc 3 1441 0
 5275 1a00 01F0      		breq .L306
 5276               	.LVL471:
 5277               	.L318:
 5278               	.LBE301:
 5279               	.LBB302:
 5280               	.LBB288:
 5281               	.LBB284:
 169:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 5282               		.loc 4 169 0 discriminator 1
 5283 1a02 96E0      		ldi r25,lo8(6)
 5284 1a04 E92E      		mov r14,r25
 5285 1a06 F12C      		mov r15,__zero_reg__
 5286 1a08 00C0      		rjmp .L319
 5287               	.LVL472:
 5288               	.L306:
 5289               	/* epilogue start */
 5290               	.LBE284:
 5291               	.LBE288:
 5292               	.LBE302:
1449:main.c        **** }
 5293               		.loc 3 1449 0
 5294 1a0a DF91      		pop r29
 5295 1a0c CF91      		pop r28
 5296 1a0e 1F91      		pop r17
 5297 1a10 0F91      		pop r16
 5298 1a12 FF90      		pop r15
 5299 1a14 EF90      		pop r14
 5300 1a16 DF90      		pop r13
 5301 1a18 CF90      		pop r12
 5302               	.LVL473:
 5303 1a1a BF90      		pop r11
 5304 1a1c AF90      		pop r10
 5305 1a1e 9F90      		pop r9
 5306 1a20 8F90      		pop r8
 5307               	.LVL474:
 5308 1a22 7F90      		pop r7
 5309               	.LVL475:
 5310 1a24 6F90      		pop r6
 5311 1a26 5F90      		pop r5
 5312 1a28 4F90      		pop r4
 5313 1a2a 3F90      		pop r3
 5314 1a2c 0895      		ret
 5315               		.cfi_endproc
 5316               	.LFE50:
 5318               	.global	checkCathodePoison
 5320               	checkCathodePoison:
 5321               	.LFB51:
1454:main.c        **** {
 5322               		.loc 3 1454 0
 5323               		.cfi_startproc
 5324               	/* prologue: function */
 5325               	/* frame size = 0 */
 5326               	/* stack size = 0 */
 5327               	.L__stack_usage = 0
1456:main.c        ****         if( minutes == 30 || minutes == 0){
 5328               		.loc 3 1456 0
 5329 1a2e 8091 0000 		lds r24,minutes
 5330 1a32 8E31      		cpi r24,lo8(30)
 5331 1a34 01F0      		breq .L335
1456:main.c        ****         if( minutes == 30 || minutes == 0){
 5332               		.loc 3 1456 0 is_stmt 0 discriminator 1
 5333 1a36 8111      		cpse r24,__zero_reg__
 5334 1a38 00C0      		rjmp .L334
 5335               	.L335:
1457:main.c        ****         	if( cathodePoisonFlag == 1 ){
 5336               		.loc 3 1457 0 is_stmt 1
 5337 1a3a 8091 0000 		lds r24,cathodePoisonFlag
 5338 1a3e 8130      		cpi r24,lo8(1)
 5339 1a40 01F4      		brne .L334
1458:main.c        ****         		antiCathodePoisonPattern( 250 );
 5340               		.loc 3 1458 0
 5341 1a42 8AEF      		ldi r24,lo8(-6)
 5342 1a44 90E0      		ldi r25,0
 5343 1a46 0E94 0000 		call antiCathodePoisonPattern
 5344               	.LVL476:
1459:main.c        ****         		antiCathodePoisonPattern( 225 );
 5345               		.loc 3 1459 0
 5346 1a4a 81EE      		ldi r24,lo8(-31)
 5347 1a4c 90E0      		ldi r25,0
 5348 1a4e 0E94 0000 		call antiCathodePoisonPattern
 5349               	.LVL477:
1460:main.c        ****         		antiCathodePoisonPattern( 200 );
 5350               		.loc 3 1460 0
 5351 1a52 88EC      		ldi r24,lo8(-56)
 5352 1a54 90E0      		ldi r25,0
 5353 1a56 0E94 0000 		call antiCathodePoisonPattern
 5354               	.LVL478:
1461:main.c        ****         		antiCathodePoisonPattern( 175 );
 5355               		.loc 3 1461 0
 5356 1a5a 8FEA      		ldi r24,lo8(-81)
 5357 1a5c 90E0      		ldi r25,0
 5358 1a5e 0E94 0000 		call antiCathodePoisonPattern
 5359               	.LVL479:
1462:main.c        ****         		antiCathodePoisonPattern( 150 );
 5360               		.loc 3 1462 0
 5361 1a62 86E9      		ldi r24,lo8(-106)
 5362 1a64 90E0      		ldi r25,0
 5363 1a66 0E94 0000 		call antiCathodePoisonPattern
 5364               	.LVL480:
1463:main.c        ****         		antiCathodePoisonPattern( 125 );
 5365               		.loc 3 1463 0
 5366 1a6a 8DE7      		ldi r24,lo8(125)
 5367 1a6c 90E0      		ldi r25,0
 5368 1a6e 0E94 0000 		call antiCathodePoisonPattern
 5369               	.LVL481:
1464:main.c        ****         		antiCathodePoisonPattern( 100 );
 5370               		.loc 3 1464 0
 5371 1a72 84E6      		ldi r24,lo8(100)
 5372 1a74 90E0      		ldi r25,0
 5373 1a76 0E94 0000 		call antiCathodePoisonPattern
 5374               	.LVL482:
1465:main.c        ****         		antiCathodePoisonPattern( 75 );
 5375               		.loc 3 1465 0
 5376 1a7a 8BE4      		ldi r24,lo8(75)
 5377 1a7c 90E0      		ldi r25,0
 5378 1a7e 0E94 0000 		call antiCathodePoisonPattern
 5379               	.LVL483:
1466:main.c        ****         		antiCathodePoisonPattern( 50 );
 5380               		.loc 3 1466 0
 5381 1a82 82E3      		ldi r24,lo8(50)
 5382 1a84 90E0      		ldi r25,0
 5383 1a86 0E94 0000 		call antiCathodePoisonPattern
 5384               	.LVL484:
1467:main.c        ****         		antiCathodePoisonPattern( 25 );
 5385               		.loc 3 1467 0
 5386 1a8a 89E1      		ldi r24,lo8(25)
 5387 1a8c 90E0      		ldi r25,0
 5388 1a8e 0E94 0000 		call antiCathodePoisonPattern
 5389               	.LVL485:
1468:main.c        ****         		antiCathodePoisonPattern( 10 );
 5390               		.loc 3 1468 0
 5391 1a92 8AE0      		ldi r24,lo8(10)
 5392 1a94 90E0      		ldi r25,0
 5393 1a96 0E94 0000 		call antiCathodePoisonPattern
 5394               	.LVL486:
1469:main.c        ****         		antiCathodePoisonPattern( 10 );
 5395               		.loc 3 1469 0
 5396 1a9a 8AE0      		ldi r24,lo8(10)
 5397 1a9c 90E0      		ldi r25,0
 5398 1a9e 0E94 0000 		call antiCathodePoisonPattern
 5399               	.LVL487:
1470:main.c        ****         		antiCathodePoisonPattern( 5 );
 5400               		.loc 3 1470 0
 5401 1aa2 85E0      		ldi r24,lo8(5)
 5402 1aa4 90E0      		ldi r25,0
 5403 1aa6 0E94 0000 		call antiCathodePoisonPattern
 5404               	.LVL488:
1471:main.c        ****         		cathodePoisonFlag = 0;				// Reset the counter.
 5405               		.loc 3 1471 0
 5406 1aaa 1092 0000 		sts cathodePoisonFlag,__zero_reg__
 5407               	.L334:
 5408 1aae 0895      		ret
 5409               		.cfi_endproc
 5410               	.LFE51:
 5412               	.global	__gesf2
 5413               	.global	__subsf3
 5414               	.global	nixiePrintTemperature
 5416               	nixiePrintTemperature:
 5417               	.LFB56:
1644:main.c        **** 	}
1645:main.c        **** 	break;
1646:main.c        **** 
1647:main.c        **** 	}
1648:main.c        **** }
1649:main.c        **** 
1650:main.c        **** 
1651:main.c        **** 
1652:main.c        **** 
1653:main.c        **** void nixiePrintTemperature( void )
1654:main.c        **** {
 5418               		.loc 3 1654 0
 5419               		.cfi_startproc
 5420 1ab0 CF92      		push r12
 5421               	.LCFI92:
 5422               		.cfi_def_cfa_offset 3
 5423               		.cfi_offset 12, -2
 5424 1ab2 DF92      		push r13
 5425               	.LCFI93:
 5426               		.cfi_def_cfa_offset 4
 5427               		.cfi_offset 13, -3
 5428 1ab4 EF92      		push r14
 5429               	.LCFI94:
 5430               		.cfi_def_cfa_offset 5
 5431               		.cfi_offset 14, -4
 5432 1ab6 FF92      		push r15
 5433               	.LCFI95:
 5434               		.cfi_def_cfa_offset 6
 5435               		.cfi_offset 15, -5
 5436 1ab8 1F93      		push r17
 5437               	.LCFI96:
 5438               		.cfi_def_cfa_offset 7
 5439               		.cfi_offset 17, -6
 5440 1aba CF93      		push r28
 5441               	.LCFI97:
 5442               		.cfi_def_cfa_offset 8
 5443               		.cfi_offset 28, -7
 5444 1abc DF93      		push r29
 5445               	.LCFI98:
 5446               		.cfi_def_cfa_offset 9
 5447               		.cfi_offset 29, -8
 5448               	/* prologue: function */
 5449               	/* frame size = 0 */
 5450               	/* stack size = 7 */
 5451               	.L__stack_usage = 7
 5452               	.LVL489:
1655:main.c        **** 	// We have 6 nixie tubes.  Let's let the left most digit be "0" for positive temperaures
1656:main.c        **** 	// and "1" for negative.  Let's do 2 decimal places, and that leaves 3 places for the
1657:main.c        **** 	// whole number temperature.
1658:main.c        **** 
1659:main.c        **** 	//averageCelsiusTemperature = -104.23;	// For testing.
1660:main.c        **** 	
1661:main.c        **** 	uint8_t isNegative = 0;		// 0 for positive temperatures, 1 for negative
1662:main.c        **** 	
1663:main.c        **** 	// Determine if the temperature is negative.
1664:main.c        **** 	// If so, we will set the leftmost nixie to "1".
1665:main.c        **** 	if( averageCelsiusTemperature >= 0 ){
 5453               		.loc 3 1665 0
 5454 1abe C090 0000 		lds r12,averageCelsiusTemperature
 5455 1ac2 D090 0000 		lds r13,averageCelsiusTemperature+1
 5456 1ac6 E090 0000 		lds r14,averageCelsiusTemperature+2
 5457 1aca F090 0000 		lds r15,averageCelsiusTemperature+3
 5458 1ace D1E0      		ldi r29,lo8(1)
 5459 1ad0 20E0      		ldi r18,0
 5460 1ad2 30E0      		ldi r19,0
 5461 1ad4 A901      		movw r20,r18
 5462 1ad6 C701      		movw r24,r14
 5463 1ad8 B601      		movw r22,r12
 5464 1ada 0E94 0000 		call __gesf2
 5465               	.LVL490:
 5466 1ade 87FD      		sbrc r24,7
 5467 1ae0 D0E0      		ldi r29,0
 5468               	.L341:
 5469 1ae2 C1E0      		ldi r28,lo8(1)
 5470 1ae4 CD27      		eor r28,r29
 5471               	.LVL491:
1666:main.c        **** 		isNegative = 0;
1667:main.c        **** 	}else{
1668:main.c        **** 		isNegative = 1;
1669:main.c        **** 	}
1670:main.c        **** 	
1671:main.c        **** 	// Get the current temperature reading.
1672:main.c        **** 	double absValTemperature = averageCelsiusTemperature;
1673:main.c        **** 	
1674:main.c        **** 	// And if negative, convert to absolute value of the temperature reading.
1675:main.c        **** 	if( averageCelsiusTemperature < 0 )
 5472               		.loc 3 1675 0
 5473 1ae6 20E0      		ldi r18,0
 5474 1ae8 30E0      		ldi r19,0
 5475 1aea A901      		movw r20,r18
 5476 1aec C701      		movw r24,r14
 5477 1aee B601      		movw r22,r12
 5478 1af0 0E94 0000 		call __ltsf2
 5479               	.LVL492:
 5480 1af4 87FF      		sbrs r24,7
 5481 1af6 00C0      		rjmp .L342
1676:main.c        **** 		absValTemperature *= -1; 
 5482               		.loc 3 1676 0
 5483 1af8 F7FA      		bst r15,7
 5484 1afa F094      		com r15
 5485 1afc F7F8      		bld r15,7
 5486 1afe F094      		com r15
 5487               	.LVL493:
 5488               	.L342:
1677:main.c        **** 	
1678:main.c        **** 		
1679:main.c        **** 	// Convert to Fahrenheit if necessary. 
1680:main.c        **** 	if( celsius == 0 )	
 5489               		.loc 3 1680 0
 5490 1b00 8091 0000 		lds r24,celsius
 5491 1b04 8111      		cpse r24,__zero_reg__
 5492 1b06 00C0      		rjmp .L344
1681:main.c        ****     {
1682:main.c        ****     	absValTemperature = ( absValTemperature * 1.8 ) + 32;
 5493               		.loc 3 1682 0
 5494 1b08 26E6      		ldi r18,lo8(102)
 5495 1b0a 36E6      		ldi r19,lo8(102)
 5496 1b0c 46EE      		ldi r20,lo8(-26)
 5497 1b0e 5FE3      		ldi r21,lo8(63)
 5498 1b10 C701      		movw r24,r14
 5499 1b12 B601      		movw r22,r12
 5500 1b14 0E94 0000 		call __mulsf3
 5501               	.LVL494:
 5502 1b18 20E0      		ldi r18,0
 5503 1b1a 30E0      		ldi r19,0
 5504 1b1c 40E0      		ldi r20,0
 5505 1b1e 52E4      		ldi r21,lo8(66)
 5506 1b20 0E94 0000 		call __addsf3
 5507               	.LVL495:
 5508 1b24 C62E      		mov r12,r22
 5509               	.LVL496:
 5510 1b26 D72E      		mov r13,r23
 5511 1b28 E82E      		mov r14,r24
 5512 1b2a F92E      		mov r15,r25
 5513               	.LVL497:
 5514               	.L344:
1683:main.c        ****     }
1684:main.c        ****    
1685:main.c        ****     
1686:main.c        ****     // The temperature reading to the left of the decimal point. 
1687:main.c        **** 	uint8_t intPartTemperature = absValTemperature;	
 5515               		.loc 3 1687 0
 5516 1b2c C701      		movw r24,r14
 5517 1b2e B601      		movw r22,r12
 5518 1b30 0E94 0000 		call __fixunssfsi
 5519               	.LVL498:
 5520 1b34 D62F      		mov r29,r22
 5521               	.LVL499:
1688:main.c        **** 		
1689:main.c        **** 		
1690:main.c        **** 	// Temperature reading to the right of the decimal point.						
1691:main.c        **** 	uint8_t decimalPartTemperature = ( absValTemperature - intPartTemperature ) * 100;
 5522               		.loc 3 1691 0
 5523 1b36 70E0      		ldi r23,0
 5524 1b38 80E0      		ldi r24,0
 5525 1b3a 90E0      		ldi r25,0
 5526 1b3c 0E94 0000 		call __floatsisf
 5527               	.LVL500:
 5528 1b40 9B01      		movw r18,r22
 5529 1b42 AC01      		movw r20,r24
 5530 1b44 C701      		movw r24,r14
 5531 1b46 B601      		movw r22,r12
 5532 1b48 0E94 0000 		call __subsf3
 5533               	.LVL501:
 5534 1b4c 20E0      		ldi r18,0
 5535 1b4e 30E0      		ldi r19,0
 5536 1b50 48EC      		ldi r20,lo8(-56)
 5537 1b52 52E4      		ldi r21,lo8(66)
 5538 1b54 0E94 0000 		call __mulsf3
 5539               	.LVL502:
 5540 1b58 0E94 0000 		call __fixunssfsi
 5541               	.LVL503:
 5542 1b5c 862F      		mov r24,r22
 5543               	.LVL504:
1692:main.c        ****             
1693:main.c        ****             
1694:main.c        **** 	uint8_t ones = 0;		// For outputting the digits to the nixies in order.
1695:main.c        **** 	uint8_t tens = 0;
1696:main.c        **** 	uint8_t hundreds = 0;
1697:main.c        **** 				
1698:main.c        **** 	// starting from the rightmost, decimal portion of the temperature.
1699:main.c        **** 	ones = decimalPartTemperature % 10;	// Grab the specific digits.
 5544               		.loc 3 1699 0
 5545 1b5e 1AE0      		ldi r17,lo8(10)
 5546 1b60 612F      		mov r22,r17
 5547               	.LVL505:
 5548 1b62 0E94 0000 		call __udivmodqi4
 5549               	.LVL506:
 5550 1b66 F82E      		mov r15,r24
 5551 1b68 892F      		mov r24,r25
 5552               	.LVL507:
1700:main.c        **** 	tens = decimalPartTemperature / 10;		
1701:main.c        **** 	
1702:main.c        **** 	sendIntegerToNixie( ones, 0 );		// Display the digits.
 5553               		.loc 3 1702 0
 5554 1b6a 60E0      		ldi r22,0
 5555 1b6c 0E94 0000 		call sendIntegerToNixie
 5556               	.LVL508:
1703:main.c        **** 	sendIntegerToNixie( tens, 1 );		// Display the decimal point.
 5557               		.loc 3 1703 0
 5558 1b70 61E0      		ldi r22,lo8(1)
 5559 1b72 8F2D      		mov r24,r15
 5560 1b74 0E94 0000 		call sendIntegerToNixie
 5561               	.LVL509:
1704:main.c        **** 	
1705:main.c        **** 	
1706:main.c        **** 	// And now the integer portion.
1707:main.c        ****     ones = intPartTemperature % 10;   
1708:main.c        ****     intPartTemperature /= 10;
 5562               		.loc 3 1708 0
 5563 1b78 8D2F      		mov r24,r29
 5564 1b7a 612F      		mov r22,r17
 5565 1b7c 0E94 0000 		call __udivmodqi4
 5566               	.LVL510:
 5567 1b80 D82F      		mov r29,r24
 5568               	.LVL511:
 5569 1b82 892F      		mov r24,r25
 5570               	.LVL512:
1709:main.c        ****     tens = intPartTemperature % 10;
1710:main.c        ****     intPartTemperature /= 10;
1711:main.c        ****     hundreds = intPartTemperature %10;		
1712:main.c        **** 	
1713:main.c        **** 	sendIntegerToNixie( ones, 0 );		// Display the digits.
 5571               		.loc 3 1713 0
 5572 1b84 60E0      		ldi r22,0
 5573 1b86 0E94 0000 		call sendIntegerToNixie
 5574               	.LVL513:
1709:main.c        ****     tens = intPartTemperature % 10;
 5575               		.loc 3 1709 0
 5576 1b8a 8D2F      		mov r24,r29
 5577 1b8c 612F      		mov r22,r17
 5578 1b8e 0E94 0000 		call __udivmodqi4
 5579               	.LVL514:
 5580 1b92 D82F      		mov r29,r24
 5581               	.LVL515:
 5582 1b94 892F      		mov r24,r25
 5583               	.LVL516:
1714:main.c        **** 	sendIntegerToNixie( tens, 0 );		
 5584               		.loc 3 1714 0
 5585 1b96 60E0      		ldi r22,0
 5586 1b98 0E94 0000 		call sendIntegerToNixie
 5587               	.LVL517:
1711:main.c        ****     hundreds = intPartTemperature %10;		
 5588               		.loc 3 1711 0
 5589 1b9c 8D2F      		mov r24,r29
 5590 1b9e 612F      		mov r22,r17
 5591 1ba0 0E94 0000 		call __udivmodqi4
 5592               	.LVL518:
 5593 1ba4 892F      		mov r24,r25
1715:main.c        **** 	sendIntegerToNixie( hundreds, 0 );
 5594               		.loc 3 1715 0
 5595 1ba6 60E0      		ldi r22,0
 5596 1ba8 0E94 0000 		call sendIntegerToNixie
 5597               	.LVL519:
1716:main.c        **** 	
1717:main.c        **** 	sendIntegerToNixie( isNegative, 0 );	// Is the temperature negative?
 5598               		.loc 3 1717 0
 5599 1bac 60E0      		ldi r22,0
 5600 1bae 8C2F      		mov r24,r28
 5601               	/* epilogue start */
1718:main.c        **** 
1719:main.c        **** }
 5602               		.loc 3 1719 0
 5603 1bb0 DF91      		pop r29
 5604               	.LVL520:
 5605 1bb2 CF91      		pop r28
 5606               	.LVL521:
 5607 1bb4 1F91      		pop r17
 5608 1bb6 FF90      		pop r15
 5609 1bb8 EF90      		pop r14
 5610 1bba DF90      		pop r13
 5611 1bbc CF90      		pop r12
 5612               	.LVL522:
1717:main.c        **** 	sendIntegerToNixie( isNegative, 0 );	// Is the temperature negative?
 5613               		.loc 3 1717 0
 5614 1bbe 0C94 0000 		jmp sendIntegerToNixie
 5615               	.LVL523:
 5616               		.cfi_endproc
 5617               	.LFE56:
 5619               	.global	nixiePrintTime
 5621               	nixiePrintTime:
 5622               	.LFB57:
1720:main.c        **** 
1721:main.c        **** 
1722:main.c        **** 
1723:main.c        **** 
1724:main.c        **** void nixiePrintTime( uint8_t doToggleDecimal )
1725:main.c        **** {
 5623               		.loc 3 1725 0
 5624               		.cfi_startproc
 5625               	.LVL524:
 5626 1bc2 1F93      		push r17
 5627               	.LCFI99:
 5628               		.cfi_def_cfa_offset 3
 5629               		.cfi_offset 17, -2
 5630 1bc4 CF93      		push r28
 5631               	.LCFI100:
 5632               		.cfi_def_cfa_offset 4
 5633               		.cfi_offset 28, -3
 5634 1bc6 DF93      		push r29
 5635               	.LCFI101:
 5636               		.cfi_def_cfa_offset 5
 5637               		.cfi_offset 29, -4
 5638               	/* prologue: function */
 5639               	/* frame size = 0 */
 5640               	/* stack size = 3 */
 5641               	.L__stack_usage = 3
 5642               	.LVL525:
1726:main.c        **** 	int myDecimal = 1;
1727:main.c        **** 	
1728:main.c        **** 	if( doToggleDecimal ){			// Toggle the nixie Decimal point.
 5643               		.loc 3 1728 0
 5644 1bc8 8823      		tst r24
 5645 1bca 01F0      		breq .L350
1729:main.c        **** 		if( seconds % 2 == 0 ){
 5646               		.loc 3 1729 0
 5647 1bcc 8091 0000 		lds r24,seconds
 5648               	.LVL526:
 5649 1bd0 8095      		com r24
1730:main.c        **** 			myDecimal = 1;
1731:main.c        **** 		}
1732:main.c        **** 		else{
1733:main.c        **** 			myDecimal = 0;
 5650               		.loc 3 1733 0
 5651 1bd2 8170      		andi r24,1
 5652 1bd4 C82F      		mov r28,r24
 5653 1bd6 00C0      		rjmp .L347
 5654               	.LVL527:
 5655               	.L350:
1734:main.c        **** 			}
1735:main.c        **** 		}else{
1736:main.c        **** 			myDecimal = 1;	// Else, they are steady ON.	
 5656               		.loc 3 1736 0
 5657 1bd8 C1E0      		ldi r28,lo8(1)
 5658 1bda D0E0      		ldi r29,0
 5659               	.LVL528:
 5660               	.L347:
1737:main.c        **** 	}
1738:main.c        **** 	
1739:main.c        **** 	
1740:main.c        **** 	// Seconds
1741:main.c        **** 	// It can happen that nixiePrintTime() is called before updateDateTime() has had a change to roll 
1742:main.c        **** 	// In which case seconds here can be >= 60.  This does not effect the determinism or accuracy of t
1743:main.c        **** 	// However, it may be disturbing to some people to see 60 seconds displayed on a clock when it sho
1744:main.c        **** 	// We will adjust the 10's of seconds below, the one's of seconds will take care of themselves.
1745:main.c        **** 	 
1746:main.c        **** 	uint8_t tens = seconds;
 5661               		.loc 3 1746 0
 5662 1bdc 2091 0000 		lds r18,seconds
 5663               	.LVL529:
1747:main.c        **** 	uint8_t ones = tens;
1748:main.c        **** 				
1749:main.c        **** 	tens /= 10;		// Get the "ten's" of seconds.
 5664               		.loc 3 1749 0
 5665 1be0 822F      		mov r24,r18
 5666 1be2 6AE0      		ldi r22,lo8(10)
 5667 1be4 0E94 0000 		call __udivmodqi4
 5668 1be8 182F      		mov r17,r24
 5669               	.LVL530:
1750:main.c        **** 	if( tens > 5 )
 5670               		.loc 3 1750 0
 5671 1bea 8630      		cpi r24,lo8(6)
 5672 1bec 00F0      		brlo .L348
1751:main.c        **** 		tens = 0;	// Restrict the display to 0::59 seconds. ( Read above that this does not affect accura
 5673               		.loc 3 1751 0
 5674 1bee 10E0      		ldi r17,0
 5675               	.LVL531:
 5676               	.L348:
1752:main.c        **** 	ones %= 10;		// Get the "one's" of seconds
 5677               		.loc 3 1752 0
 5678 1bf0 DAE0      		ldi r29,lo8(10)
 5679 1bf2 822F      		mov r24,r18
 5680 1bf4 6D2F      		mov r22,r29
 5681 1bf6 0E94 0000 		call __udivmodqi4
 5682               	.LVL532:
 5683 1bfa 892F      		mov r24,r25
1753:main.c        **** 	
1754:main.c        **** 	sendIntegerToNixie( ones, 0 );
 5684               		.loc 3 1754 0
 5685 1bfc 60E0      		ldi r22,0
 5686 1bfe 0E94 0000 		call sendIntegerToNixie
 5687               	.LVL533:
1755:main.c        **** 	sendIntegerToNixie( tens, myDecimal );
 5688               		.loc 3 1755 0
 5689 1c02 6C2F      		mov r22,r28
 5690 1c04 812F      		mov r24,r17
 5691 1c06 0E94 0000 		call sendIntegerToNixie
 5692               	.LVL534:
1756:main.c        **** 	
1757:main.c        **** 	
1758:main.c        **** 	// Minutes
1759:main.c        **** 	tens = minutes;
 5693               		.loc 3 1759 0
 5694 1c0a 8091 0000 		lds r24,minutes
 5695               	.LVL535:
1760:main.c        **** 	ones = tens;
1761:main.c        **** 	
1762:main.c        **** 	tens /= 10;		// Get the "ten's" of minutes.
1763:main.c        **** 	ones %= 10;		// Get the "one's" of minutes
 5696               		.loc 3 1763 0
 5697 1c0e 6D2F      		mov r22,r29
 5698 1c10 0E94 0000 		call __udivmodqi4
 5699               	.LVL536:
 5700 1c14 D82F      		mov r29,r24
 5701 1c16 892F      		mov r24,r25
 5702               	.LVL537:
1764:main.c        **** 	
1765:main.c        **** 	sendIntegerToNixie( ones, 0 );
 5703               		.loc 3 1765 0
 5704 1c18 60E0      		ldi r22,0
 5705 1c1a 0E94 0000 		call sendIntegerToNixie
 5706               	.LVL538:
1766:main.c        **** 	sendIntegerToNixie( tens, myDecimal );
 5707               		.loc 3 1766 0
 5708 1c1e 6C2F      		mov r22,r28
 5709 1c20 8D2F      		mov r24,r29
 5710 1c22 0E94 0000 		call sendIntegerToNixie
 5711               	.LVL539:
1767:main.c        **** 	
1768:main.c        **** 	
1769:main.c        **** 	// Hours
1770:main.c        **** 	uint8_t myHours = hours;
 5712               		.loc 3 1770 0
 5713 1c26 8091 0000 		lds r24,hours
 5714               	.LVL540:
1771:main.c        **** 	
1772:main.c        **** 	if( miltime == 0 && hours > 12 )
 5715               		.loc 3 1772 0
 5716 1c2a 9091 0000 		lds r25,miltime
 5717 1c2e 9111      		cpse r25,__zero_reg__
 5718 1c30 00C0      		rjmp .L349
 5719               		.loc 3 1772 0 is_stmt 0 discriminator 1
 5720 1c32 8D30      		cpi r24,lo8(13)
 5721 1c34 00F0      		brlo .L349
1773:main.c        **** 		myHours -= 12;
 5722               		.loc 3 1773 0 is_stmt 1
 5723 1c36 8C50      		subi r24,lo8(-(-12))
 5724               	.LVL541:
 5725               	.L349:
1774:main.c        **** 		
1775:main.c        **** 	tens = myHours;
1776:main.c        **** 	ones = tens;
1777:main.c        **** 	
1778:main.c        **** 	tens /= 10;		// Get the "ten's" of hours.
1779:main.c        **** 	ones %= 10;		// Get the "one's" of hours.
 5726               		.loc 3 1779 0
 5727 1c38 6AE0      		ldi r22,lo8(10)
 5728 1c3a 0E94 0000 		call __udivmodqi4
 5729               	.LVL542:
 5730 1c3e C82F      		mov r28,r24
 5731 1c40 892F      		mov r24,r25
 5732               	.LVL543:
1780:main.c        **** 	
1781:main.c        **** 	sendIntegerToNixie( ones, 0 );
 5733               		.loc 3 1781 0
 5734 1c42 60E0      		ldi r22,0
 5735 1c44 0E94 0000 		call sendIntegerToNixie
 5736               	.LVL544:
1782:main.c        **** 	sendIntegerToNixie( tens, 0 );
 5737               		.loc 3 1782 0
 5738 1c48 60E0      		ldi r22,0
 5739 1c4a 8C2F      		mov r24,r28
 5740               	/* epilogue start */
1783:main.c        **** 
1784:main.c        **** }
 5741               		.loc 3 1784 0
 5742 1c4c DF91      		pop r29
 5743 1c4e CF91      		pop r28
 5744               	.LVL545:
 5745 1c50 1F91      		pop r17
1782:main.c        **** 	sendIntegerToNixie( tens, 0 );
 5746               		.loc 3 1782 0
 5747 1c52 0C94 0000 		jmp sendIntegerToNixie
 5748               	.LVL546:
 5749               		.cfi_endproc
 5750               	.LFE57:
 5752               	.global	nixiePrintDate
 5754               	nixiePrintDate:
 5755               	.LFB58:
1785:main.c        **** 
1786:main.c        **** 
1787:main.c        **** 
1788:main.c        **** 
1789:main.c        **** void nixiePrintDate( void )
1790:main.c        **** {
 5756               		.loc 3 1790 0
 5757               		.cfi_startproc
 5758 1c56 0F93      		push r16
 5759               	.LCFI102:
 5760               		.cfi_def_cfa_offset 3
 5761               		.cfi_offset 16, -2
 5762 1c58 1F93      		push r17
 5763               	.LCFI103:
 5764               		.cfi_def_cfa_offset 4
 5765               		.cfi_offset 17, -3
 5766 1c5a CF93      		push r28
 5767               	.LCFI104:
 5768               		.cfi_def_cfa_offset 5
 5769               		.cfi_offset 28, -4
 5770 1c5c DF93      		push r29
 5771               	.LCFI105:
 5772               		.cfi_def_cfa_offset 6
 5773               		.cfi_offset 29, -5
 5774               	/* prologue: function */
 5775               	/* frame size = 0 */
 5776               	/* stack size = 4 */
 5777               	.L__stack_usage = 4
1791:main.c        **** 	// Printing the date in YY.MM.DD format to the nixies
1792:main.c        **** 	
1793:main.c        **** 	// Print the day.
1794:main.c        **** 	uint8_t ones = day;
 5778               		.loc 3 1794 0
 5779 1c5e 8091 0000 		lds r24,day
 5780               	.LVL547:
1795:main.c        **** 	uint8_t tens = ones;
1796:main.c        **** 				
1797:main.c        **** 	tens /= 10;		// Get the "ten's" of days.
1798:main.c        **** 	ones %= 10;		// Get the "one's" of days.
 5781               		.loc 3 1798 0
 5782 1c62 CAE0      		ldi r28,lo8(10)
 5783 1c64 6C2F      		mov r22,r28
 5784 1c66 0E94 0000 		call __udivmodqi4
 5785               	.LVL548:
 5786 1c6a D82F      		mov r29,r24
 5787 1c6c 892F      		mov r24,r25
 5788               	.LVL549:
1799:main.c        **** 	
1800:main.c        **** 	sendIntegerToNixie( ones, 0 );
 5789               		.loc 3 1800 0
 5790 1c6e 60E0      		ldi r22,0
 5791 1c70 0E94 0000 		call sendIntegerToNixie
 5792               	.LVL550:
1801:main.c        **** 	sendIntegerToNixie( tens, 1 );
 5793               		.loc 3 1801 0
 5794 1c74 61E0      		ldi r22,lo8(1)
 5795 1c76 8D2F      		mov r24,r29
 5796 1c78 0E94 0000 		call sendIntegerToNixie
 5797               	.LVL551:
1802:main.c        **** 	
1803:main.c        **** 	
1804:main.c        **** 	// Print the month.
1805:main.c        **** 	 ones = month;
 5798               		.loc 3 1805 0
 5799 1c7c 8091 0000 		lds r24,month
 5800               	.LVL552:
1806:main.c        **** 	 tens = ones;
1807:main.c        **** 				
1808:main.c        **** 	tens /= 10;		// Get the "ten's" of months.
1809:main.c        **** 	ones %= 10;		// Get the "one's" of months.
 5801               		.loc 3 1809 0
 5802 1c80 6C2F      		mov r22,r28
 5803 1c82 0E94 0000 		call __udivmodqi4
 5804               	.LVL553:
 5805 1c86 C82F      		mov r28,r24
 5806 1c88 892F      		mov r24,r25
 5807               	.LVL554:
1810:main.c        **** 	
1811:main.c        **** 	sendIntegerToNixie( ones, 0 );
 5808               		.loc 3 1811 0
 5809 1c8a 60E0      		ldi r22,0
 5810 1c8c 0E94 0000 		call sendIntegerToNixie
 5811               	.LVL555:
1812:main.c        **** 	sendIntegerToNixie( tens, 1 );
 5812               		.loc 3 1812 0
 5813 1c90 61E0      		ldi r22,lo8(1)
 5814 1c92 8C2F      		mov r24,r28
 5815 1c94 0E94 0000 		call sendIntegerToNixie
 5816               	.LVL556:
1813:main.c        **** 
1814:main.c        **** 	
1815:main.c        **** 	// Print the Year.
1816:main.c        **** 	uint16_t myYear = year;
 5817               		.loc 3 1816 0
 5818 1c98 8091 0000 		lds r24,year
 5819 1c9c 9091 0000 		lds r25,year+1
 5820               	.LVL557:
1817:main.c        **** 	
1818:main.c        **** 	ones = myYear % 10;   
 5821               		.loc 3 1818 0
 5822 1ca0 CAE0      		ldi r28,lo8(10)
 5823 1ca2 D0E0      		ldi r29,0
 5824 1ca4 BE01      		movw r22,r28
 5825 1ca6 0E94 0000 		call __udivmodhi4
 5826               	.LVL558:
 5827 1caa 8B01      		movw r16,r22
1819:main.c        ****     myYear /= 10;
1820:main.c        ****     tens = myYear % 10;
1821:main.c        ****     
1822:main.c        **** 	sendIntegerToNixie( ones, 0 );		// Display the digits.
 5828               		.loc 3 1822 0
 5829 1cac 60E0      		ldi r22,0
 5830               	.LVL559:
 5831 1cae 0E94 0000 		call sendIntegerToNixie
 5832               	.LVL560:
1820:main.c        ****     tens = myYear % 10;
 5833               		.loc 3 1820 0
 5834 1cb2 C801      		movw r24,r16
 5835 1cb4 BE01      		movw r22,r28
 5836 1cb6 0E94 0000 		call __udivmodhi4
1823:main.c        **** 	sendIntegerToNixie( tens, 0 );		
 5837               		.loc 3 1823 0
 5838 1cba 60E0      		ldi r22,0
 5839               	/* epilogue start */
1824:main.c        **** 	
1825:main.c        **** }
 5840               		.loc 3 1825 0
 5841 1cbc DF91      		pop r29
 5842 1cbe CF91      		pop r28
 5843 1cc0 1F91      		pop r17
 5844 1cc2 0F91      		pop r16
 5845               	.LVL561:
1823:main.c        **** 	sendIntegerToNixie( tens, 0 );		
 5846               		.loc 3 1823 0
 5847 1cc4 0C94 0000 		jmp sendIntegerToNixie
 5848               	.LVL562:
 5849               		.cfi_endproc
 5850               	.LFE58:
 5852               	.global	nixiePrintAcFrequency
 5854               	nixiePrintAcFrequency:
 5855               	.LFB59:
1826:main.c        **** 
1827:main.c        **** 
1828:main.c        **** 
1829:main.c        **** 
1830:main.c        **** 
1831:main.c        **** 
1832:main.c        **** void nixiePrintAcFrequency( void )
1833:main.c        **** {
 5856               		.loc 3 1833 0
 5857               		.cfi_startproc
 5858 1cc8 AF92      		push r10
 5859               	.LCFI106:
 5860               		.cfi_def_cfa_offset 3
 5861               		.cfi_offset 10, -2
 5862 1cca BF92      		push r11
 5863               	.LCFI107:
 5864               		.cfi_def_cfa_offset 4
 5865               		.cfi_offset 11, -3
 5866 1ccc CF92      		push r12
 5867               	.LCFI108:
 5868               		.cfi_def_cfa_offset 5
 5869               		.cfi_offset 12, -4
 5870 1cce DF92      		push r13
 5871               	.LCFI109:
 5872               		.cfi_def_cfa_offset 6
 5873               		.cfi_offset 13, -5
 5874 1cd0 EF92      		push r14
 5875               	.LCFI110:
 5876               		.cfi_def_cfa_offset 7
 5877               		.cfi_offset 14, -6
 5878 1cd2 FF92      		push r15
 5879               	.LCFI111:
 5880               		.cfi_def_cfa_offset 8
 5881               		.cfi_offset 15, -7
 5882 1cd4 0F93      		push r16
 5883               	.LCFI112:
 5884               		.cfi_def_cfa_offset 9
 5885               		.cfi_offset 16, -8
 5886 1cd6 1F93      		push r17
 5887               	.LCFI113:
 5888               		.cfi_def_cfa_offset 10
 5889               		.cfi_offset 17, -9
 5890 1cd8 CF93      		push r28
 5891               	.LCFI114:
 5892               		.cfi_def_cfa_offset 11
 5893               		.cfi_offset 28, -10
 5894 1cda DF93      		push r29
 5895               	.LCFI115:
 5896               		.cfi_def_cfa_offset 12
 5897               		.cfi_offset 29, -11
 5898               	/* prologue: function */
 5899               	/* frame size = 0 */
 5900               	/* stack size = 10 */
 5901               	.L__stack_usage = 10
1834:main.c        **** 	uint32_t myFrequency = acFrequency * 1000;	// Shift everything over 3 decimal places.
 5902               		.loc 3 1834 0
 5903 1cdc 6091 0000 		lds r22,acFrequency
 5904 1ce0 7091 0000 		lds r23,acFrequency+1
 5905 1ce4 8091 0000 		lds r24,acFrequency+2
 5906 1ce8 9091 0000 		lds r25,acFrequency+3
 5907 1cec 20E0      		ldi r18,0
 5908 1cee 30E0      		ldi r19,0
 5909 1cf0 4AE7      		ldi r20,lo8(122)
 5910 1cf2 54E4      		ldi r21,lo8(68)
 5911 1cf4 0E94 0000 		call __mulsf3
 5912               	.LVL563:
 5913 1cf8 0E94 0000 		call __fixunssfsi
 5914               	.LVL564:
 5915 1cfc B62E      		mov r11,r22
 5916 1cfe A72E      		mov r10,r23
 5917 1d00 182F      		mov r17,r24
 5918 1d02 092F      		mov r16,r25
 5919               	.LVL565:
1835:main.c        **** 	uint8_t intToSend = 0;						// The extracted digit to send to the nixie.
1836:main.c        **** 	
1837:main.c        **** 	// Loop 5 times because we have 5 digits to display.
1838:main.c        **** 	for( int i = 0; i < 5; i++ )
 5920               		.loc 3 1838 0
 5921 1d04 C0E0      		ldi r28,0
 5922 1d06 D0E0      		ldi r29,0
 5923               	.LBB307:
 5924               	.LBB308:
1839:main.c        **** 	{
1840:main.c        **** 		uint8_t myDecimal = 0;
1841:main.c        **** 		
1842:main.c        **** 		if( i == 2 ){		// put a decimal point in the right spot.
1843:main.c        **** 			myDecimal = 1;
1844:main.c        **** 		}else{
1845:main.c        **** 			myDecimal = 0;
1846:main.c        **** 		}
1847:main.c        **** 		
1848:main.c        **** 		intToSend = myFrequency % 10;				// Extract the rightmost digit.
 5925               		.loc 3 1848 0
 5926 1d08 4AE0      		ldi r20,lo8(10)
 5927 1d0a C42E      		mov r12,r20
 5928 1d0c D12C      		mov r13,__zero_reg__
 5929 1d0e E12C      		mov r14,__zero_reg__
 5930 1d10 F12C      		mov r15,__zero_reg__
 5931               	.LVL566:
 5932               	.L355:
 5933 1d12 6B2D      		mov r22,r11
 5934 1d14 7A2D      		mov r23,r10
 5935 1d16 812F      		mov r24,r17
 5936 1d18 902F      		mov r25,r16
 5937 1d1a A701      		movw r20,r14
 5938 1d1c 9601      		movw r18,r12
 5939 1d1e 0E94 0000 		call __udivmodsi4
 5940 1d22 862F      		mov r24,r22
 5941               	.LVL567:
1849:main.c        **** 		myFrequency /= 10;							// Shift right.
 5942               		.loc 3 1849 0
 5943 1d24 B22E      		mov r11,r18
 5944 1d26 A32E      		mov r10,r19
 5945 1d28 142F      		mov r17,r20
 5946 1d2a 052F      		mov r16,r21
 5947               	.LVL568:
1842:main.c        **** 		if( i == 2 ){		// put a decimal point in the right spot.
 5948               		.loc 3 1842 0
 5949 1d2c 61E0      		ldi r22,lo8(1)
 5950               	.LVL569:
 5951 1d2e C230      		cpi r28,2
 5952 1d30 D105      		cpc r29,__zero_reg__
 5953 1d32 01F0      		breq .L354
 5954 1d34 60E0      		ldi r22,0
 5955               	.L354:
1850:main.c        **** 		sendIntegerToNixie( intToSend, myDecimal );	// And print it to the nixie tubes.
 5956               		.loc 3 1850 0
 5957 1d36 0E94 0000 		call sendIntegerToNixie
 5958               	.LVL570:
 5959               	.LBE308:
1838:main.c        **** 	for( int i = 0; i < 5; i++ )
 5960               		.loc 3 1838 0
 5961 1d3a 2196      		adiw r28,1
 5962               	.LVL571:
 5963 1d3c C530      		cpi r28,5
 5964 1d3e D105      		cpc r29,__zero_reg__
 5965 1d40 01F4      		brne .L355
 5966               	.LVL572:
 5967               	.LBE307:
 5968               	.LBB309:
 5969               	.LBB310:
1562:main.c        **** 			shiftByteOut( 0b00000000 );
 5970               		.loc 3 1562 0
 5971 1d42 80E0      		ldi r24,0
 5972               	/* epilogue start */
 5973               	.LBE310:
 5974               	.LBE309:
1851:main.c        **** 	}
1852:main.c        **** 	
1853:main.c        **** 	sendIntegerToNixie( 0, 0 );		//  Send an extra "0" to shift everything "right" one.
1854:main.c        **** 
1855:main.c        **** }
 5975               		.loc 3 1855 0
 5976 1d44 DF91      		pop r29
 5977 1d46 CF91      		pop r28
 5978               	.LVL573:
 5979 1d48 1F91      		pop r17
 5980 1d4a 0F91      		pop r16
 5981 1d4c FF90      		pop r15
 5982 1d4e EF90      		pop r14
 5983 1d50 DF90      		pop r13
 5984 1d52 CF90      		pop r12
 5985 1d54 BF90      		pop r11
 5986 1d56 AF90      		pop r10
 5987               	.LBB312:
 5988               	.LBB311:
1562:main.c        **** 			shiftByteOut( 0b00000000 );
 5989               		.loc 3 1562 0
 5990 1d58 0C94 0000 		jmp shiftByteOut
 5991               	.LVL574:
 5992               	.LBE311:
 5993               	.LBE312:
 5994               		.cfi_endproc
 5995               	.LFE59:
 5997               		.section	.text.startup,"ax",@progbits
 5998               	.global	main
 6000               	main:
 6001               	.LFB13:
 210:main.c        **** {
 6002               		.loc 3 210 0
 6003               		.cfi_startproc
 6004               	/* prologue: function */
 6005               	/* frame size = 0 */
 6006               	/* stack size = 0 */
 6007               	.L__stack_usage = 0
 211:main.c        ****     cli();
 6008               		.loc 3 211 0
 6009               	/* #APP */
 6010               	 ;  211 "main.c" 1
 6011 0000 F894      		cli
 6012               	 ;  0 "" 2
 212:main.c        ****     ioInit();
 6013               		.loc 3 212 0
 6014               	/* #NOAPP */
 6015 0002 0E94 0000 		call ioInit
 6016               	.LVL575:
 213:main.c        ****     adcInit();
 6017               		.loc 3 213 0
 6018 0006 0E94 0000 		call adcInit
 6019               	.LVL576:
 214:main.c        ****     boostConverterInit();
 6020               		.loc 3 214 0
 6021 000a 0E94 0000 		call boostConverterInit
 6022               	.LVL577:
 215:main.c        ****     rtcInit();
 6023               		.loc 3 215 0
 6024 000e 0E94 0000 		call rtcInit
 6025               	.LVL578:
 216:main.c        ****     uartInit();
 6026               		.loc 3 216 0
 6027 0012 0E94 0000 		call uartInit
 6028               	.LVL579:
 217:main.c        ****     extInterruptInit();
 6029               		.loc 3 217 0
 6030 0016 0E94 0000 		call extInterruptInit
 6031               	.LVL580:
 218:main.c        ****     readEepromToVars();  
 6032               		.loc 3 218 0
 6033 001a 0E94 0000 		call readEepromToVars
 6034               	.LVL581:
 219:main.c        ****     sei();
 6035               		.loc 3 219 0
 6036               	/* #APP */
 6037               	 ;  219 "main.c" 1
 6038 001e 7894      		sei
 6039               	 ;  0 "" 2
 221:main.c        ****     uartWelcome();
 6040               		.loc 3 221 0
 6041               	/* #NOAPP */
 6042 0020 0E94 0000 		call uartWelcome
 6043               	.LVL582:
 6044               	.LBB313:
 6045               	.LBB314:
 6046               	.LBB315:
 6047               	.LBB316:
 6048               		.loc 2 105 0
 6049 0024 C9E9      		ldi r28,lo8(-103)
 6050 0026 D1E0      		ldi r29,lo8(1)
 6051               	.L372:
 6052               	.LBE316:
 6053               	.LBE315:
 6054               	.LBE314:
 6055               	.LBE313:
 227:main.c        ****     	updateAcFrequency();			// Every AC_FRQ_FILT_SEC seconds, compute the average.
 6056               		.loc 3 227 0
 6057 0028 0E94 0000 		call updateAcFrequency
 6058               	.LVL583:
 228:main.c        ****     	updateTemperatureFilter( 20 );	// FIR averaging filter for the DS18b20.
 6059               		.loc 3 228 0
 6060 002c 84E1      		ldi r24,lo8(20)
 6061 002e 0E94 0000 		call updateTemperatureFilter
 6062               	.LVL584:
 229:main.c        ****         updateNixieOutputState();		// Turns ON or OFF the nixie tubes based on input power and slee
 6063               		.loc 3 229 0
 6064 0032 0E94 0000 		call updateNixieOutputState
 6065               	.LVL585:
 230:main.c        ****       	checkSerialIn();				// Is there new serial data available?
 6066               		.loc 3 230 0
 6067 0036 0E94 0000 		call checkSerialIn
 6068               	.LVL586:
 231:main.c        **** 		updateDateTime();				// Keep track of the current date and time.
 6069               		.loc 3 231 0
 6070 003a 0E94 0000 		call updateDateTime
 6071               	.LVL587:
 234:main.c        ****         if( seconds != prevSeconds)
 6072               		.loc 3 234 0
 6073 003e 9091 0000 		lds r25,seconds
 6074 0042 8091 0000 		lds r24,prevSeconds
 6075 0046 9817      		cp r25,r24
 6076 0048 01F0      		breq .L361
 236:main.c        ****             nixiePrintTime( 1 );	// Display the current time on the nixie tubes and toggle the deci
 6077               		.loc 3 236 0
 6078 004a 81E0      		ldi r24,lo8(1)
 6079 004c 0E94 0000 		call nixiePrintTime
 6080               	.LVL588:
 237:main.c        ****             prevSeconds = seconds;
 6081               		.loc 3 237 0
 6082 0050 8091 0000 		lds r24,seconds
 6083 0054 8093 0000 		sts prevSeconds,r24
 6084               	.L361:
 248:main.c        ****         if( minutes != prevMinutes)
 6085               		.loc 3 248 0
 6086 0058 9091 0000 		lds r25,minutes
 6087 005c 8091 0000 		lds r24,prevMinutes
 6088 0060 9817      		cp r25,r24
 6089 0062 01F4      		brne .+2
 6090 0064 00C0      		rjmp .L362
 250:main.c        ****         	cathodePoisonFlag = 1;		// Set every minute.  Cleared in checkCathodePoison(). 
 6091               		.loc 3 250 0
 6092 0066 81E0      		ldi r24,lo8(1)
 6093 0068 8093 0000 		sts cathodePoisonFlag,r24
 252:main.c        ****             serialPrintDateTime();
 6094               		.loc 3 252 0
 6095 006c 0E94 0000 		call serialPrintDateTime
 6096               	.LVL589:
 253:main.c        ****             serialPrintTemperature();
 6097               		.loc 3 253 0
 6098 0070 0E94 0000 		call serialPrintTemperature
 6099               	.LVL590:
 254:main.c        ****             serialPrintAcFrequency();
 6100               		.loc 3 254 0
 6101 0074 0E94 0000 		call serialPrintAcFrequency
 6102               	.LVL591:
 255:main.c        ****             uart_puts(RETURN_NEWLINE);
 6103               		.loc 3 255 0
 6104 0078 80E0      		ldi r24,lo8(.LC3)
 6105 007a 90E0      		ldi r25,hi8(.LC3)
 6106 007c 0E94 0000 		call uart_puts
 6107               	.LVL592:
 259:main.c        ****             if( showdate ){
 6108               		.loc 3 259 0
 6109 0080 8091 0000 		lds r24,showdate
 6110 0084 8111      		cpse r24,__zero_reg__
 6111 0086 00C0      		rjmp .L363
 6112               	.L367:
 265:main.c        ****            	if( showtherm ){
 6113               		.loc 3 265 0
 6114 0088 8091 0000 		lds r24,showtherm
 6115 008c 8823      		tst r24
 6116 008e 01F0      		breq .L365
 6117 0090 00C0      		rjmp .L364
 6118               	.L363:
 260:main.c        ****             	nixiePrintDate();
 6119               		.loc 3 260 0
 6120 0092 0E94 0000 		call nixiePrintDate
 6121               	.LVL593:
 6122 0096 80E5      		ldi r24,lo8(80)
 6123 0098 93EC      		ldi r25,lo8(-61)
 6124               	.LVL594:
 6125               	.L366:
 6126               	.LBB320:
 6127               	.LBB319:
 6128               	.LBB318:
 6129               	.LBB317:
 6130               		.loc 2 105 0
 6131 009a FE01      		movw r30,r28
 6132               	/* #APP */
 6133               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 6134 009c 3197      		1: sbiw r30,1
 6135 009e 01F4      		brne 1b
 6136               	 ;  0 "" 2
 6137               	.LVL595:
 6138               	/* #NOAPP */
 6139 00a0 0197      		sbiw r24,1
 6140               	.LBE317:
 6141               	.LBE318:
 174:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 6142               		.loc 4 174 0
 6143 00a2 01F4      		brne .L366
 6144 00a4 00C0      		rjmp .L367
 6145               	.LVL596:
 6146               	.L365:
 6147               	.LBE319:
 6148               	.LBE320:
 271:main.c        ****            	if( showfreq ){
 6149               		.loc 3 271 0
 6150 00a6 8091 0000 		lds r24,showfreq
 6151 00aa 8823      		tst r24
 6152 00ac 01F0      		breq .L369
 6153 00ae 00C0      		rjmp .L368
 6154               	.L364:
 266:main.c        ****            		nixiePrintTemperature();
 6155               		.loc 3 266 0
 6156 00b0 0E94 0000 		call nixiePrintTemperature
 6157               	.LVL597:
 6158 00b4 80E5      		ldi r24,lo8(80)
 6159 00b6 93EC      		ldi r25,lo8(-61)
 6160               	.LVL598:
 6161               	.L370:
 6162               	.LBB321:
 6163               	.LBB322:
 6164               	.LBB323:
 6165               	.LBB324:
 6166               		.loc 2 105 0
 6167 00b8 FE01      		movw r30,r28
 6168               	/* #APP */
 6169               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 6170 00ba 3197      		1: sbiw r30,1
 6171 00bc 01F4      		brne 1b
 6172               	 ;  0 "" 2
 6173               	.LVL599:
 6174               	/* #NOAPP */
 6175 00be 0197      		sbiw r24,1
 6176               	.LBE324:
 6177               	.LBE323:
 174:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 6178               		.loc 4 174 0
 6179 00c0 01F4      		brne .L370
 6180 00c2 00C0      		rjmp .L365
 6181               	.LVL600:
 6182               	.L369:
 6183               	.LBE322:
 6184               	.LBE321:
 276:main.c        ****             prevMinutes = minutes;   
 6185               		.loc 3 276 0
 6186 00c4 8091 0000 		lds r24,minutes
 6187 00c8 8093 0000 		sts prevMinutes,r24
 6188 00cc 00C0      		rjmp .L362
 6189               	.L368:
 272:main.c        ****            		nixiePrintAcFrequency();
 6190               		.loc 3 272 0
 6191 00ce 0E94 0000 		call nixiePrintAcFrequency
 6192               	.LVL601:
 6193 00d2 80E5      		ldi r24,lo8(80)
 6194 00d4 93EC      		ldi r25,lo8(-61)
 6195               	.LVL602:
 6196               	.L371:
 6197               	.LBB325:
 6198               	.LBB326:
 6199               	.LBB327:
 6200               	.LBB328:
 6201               		.loc 2 105 0
 6202 00d6 FE01      		movw r30,r28
 6203               	/* #APP */
 6204               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 6205 00d8 3197      		1: sbiw r30,1
 6206 00da 01F4      		brne 1b
 6207               	 ;  0 "" 2
 6208               	.LVL603:
 6209               	/* #NOAPP */
 6210 00dc 0197      		sbiw r24,1
 6211               	.LBE328:
 6212               	.LBE327:
 174:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 6213               		.loc 4 174 0
 6214 00de 01F4      		brne .L371
 6215 00e0 00C0      		rjmp .L369
 6216               	.LVL604:
 6217               	.L362:
 6218               	.LBE326:
 6219               	.LBE325:
 279:main.c        ****         checkCathodePoison();			// do the antipoison routine if ready.
 6220               		.loc 3 279 0
 6221 00e2 0E94 0000 		call checkCathodePoison
 6222               	.LVL605:
 281:main.c        ****     }
 6223               		.loc 3 281 0
 6224 00e6 00C0      		rjmp .L372
 6225               		.cfi_endproc
 6226               	.LFE13:
 6228               	.global	cathodePoisonFlag
 6229               		.section .bss
 6232               	cathodePoisonFlag:
 6233 0000 00        		.zero	1
 6234               	.global	acFreqFlag
 6237               	acFreqFlag:
 6238 0001 00        		.zero	1
 6239               	.global	acFrequency
 6242               	acFrequency:
 6243 0002 0000 0000 		.zero	4
 6244               	.global	acZeroCrossSnapshot
 6247               	acZeroCrossSnapshot:
 6248 0006 0000      		.zero	2
 6249               	.global	acZeroCrossCounter
 6252               	acZeroCrossCounter:
 6253 0008 0000      		.zero	2
 6254               		.comm	adc_raw,4,1
 6255               	.global	boostLowPwm
 6256               		.data
 6259               	boostLowPwm:
 6260 0000 1E        		.byte	30
 6261               	.global	boostHighPwm
 6264               	boostHighPwm:
 6265 0001 50        		.byte	80
 6266               	.global	boostConverterPwm
 6267               		.section .bss
 6270               	boostConverterPwm:
 6271 000a 00        		.zero	1
 6272               		.comm	movingAverageArray,24,1
 6273               	.global	arraySum
 6276               	arraySum:
 6277 000b 0000 0000 		.zero	4
 6278               	.global	averageCelsiusTemperature
 6279               		.data
 6282               	averageCelsiusTemperature:
 6283 0002 00        		.byte	0
 6284 0003 00        		.byte	0
 6285 0004 C6        		.byte	-58
 6286 0005 42        		.byte	66
 6287               	.global	celsiusTemperature
 6290               	celsiusTemperature:
 6291 0006 00        		.byte	0
 6292 0007 00        		.byte	0
 6293 0008 C6        		.byte	-58
 6294 0009 42        		.byte	66
 6295               	.global	ee_nixiesleepend
 6296               		.section	.eeprom,"aw",@progbits
 6299               	ee_nixiesleepend:
 6300 0000 0000 0000 		.zero	4
 6301               	.global	nixiesleepend
 6302               		.section .bss
 6305               	nixiesleepend:
 6306 000f 0000 0000 		.zero	4
 6307               	.global	ee_nixiesleepstart
 6308               		.section	.eeprom
 6311               	ee_nixiesleepstart:
 6312 0004 0000 0000 		.zero	4
 6313               	.global	nixiesleepstart
 6314               		.section .bss
 6317               	nixiesleepstart:
 6318 0013 0000 0000 		.zero	4
 6319               	.global	ee_toggleled
 6320               		.section	.eeprom
 6323               	ee_toggleled:
 6324 0008 01        		.byte	1
 6325               	.global	toggleled
 6326               		.data
 6329               	toggleled:
 6330 000a 01        		.byte	1
 6331               	.global	ee_xtalisfast
 6332               		.section	.eeprom
 6335               	ee_xtalisfast:
 6336 0009 01        		.byte	1
 6337               	.global	xtalisfast
 6338               		.data
 6341               	xtalisfast:
 6342 000b 01        		.byte	1
 6343               	.global	ee_acclock
 6344               		.section	.eeprom
 6347               	ee_acclock:
 6348 000a 01        		.byte	1
 6349               	.global	acclock
 6350               		.data
 6353               	acclock:
 6354 000c 01        		.byte	1
 6355               	.global	ee_doecho
 6356               		.section	.eeprom
 6359               	ee_doecho:
 6360 000b 01        		.byte	1
 6361               	.global	doecho
 6362               		.data
 6365               	doecho:
 6366 000d 01        		.byte	1
 6367               	.global	ee_celsius
 6368               		.section	.eeprom
 6371               	ee_celsius:
 6372 000c 01        		.byte	1
 6373               	.global	celsius
 6374               		.data
 6377               	celsius:
 6378 000e 01        		.byte	1
 6379               	.global	ee_showdate
 6380               		.section	.eeprom
 6383               	ee_showdate:
 6384 000d 00        		.zero	1
 6385               	.global	showdate
 6386               		.section .bss
 6389               	showdate:
 6390 0017 00        		.zero	1
 6391               	.global	ee_showfreq
 6392               		.section	.eeprom
 6395               	ee_showfreq:
 6396 000e 00        		.zero	1
 6397               	.global	showfreq
 6398               		.section .bss
 6401               	showfreq:
 6402 0018 00        		.zero	1
 6403               	.global	ee_showtherm
 6404               		.section	.eeprom
 6407               	ee_showtherm:
 6408 000f 00        		.zero	1
 6409               	.global	showtherm
 6410               		.section .bss
 6413               	showtherm:
 6414 0019 00        		.zero	1
 6415               	.global	ee_miltime
 6416               		.section	.eeprom
 6419               	ee_miltime:
 6420 0010 01        		.byte	1
 6421               	.global	miltime
 6422               		.data
 6425               	miltime:
 6426 000f 01        		.byte	1
 6427               	.global	prevMinutes
 6428               		.section .bss
 6431               	prevMinutes:
 6432 001a 00        		.zero	1
 6433               	.global	prevSeconds
 6436               	prevSeconds:
 6437 001b 00        		.zero	1
 6438               	.global	ee_mscal
 6439               		.section	.eeprom
 6442               	ee_mscal:
 6443 0011 0000 0000 		.zero	4
 6444               	.global	mscal
 6445               		.section .bss
 6448               	mscal:
 6449 001c 0000 0000 		.zero	4
 6450               	.global	seconds
 6451               		.data
 6454               	seconds:
 6455 0010 1E        		.byte	30
 6456               	.global	year
 6459               	year:
 6460 0011 DF07      		.word	2015
 6461               	.global	month
 6464               	month:
 6465 0013 02        		.byte	2
 6466               	.global	day
 6469               	day:
 6470 0014 01        		.byte	1
 6471               	.global	minutes
 6474               	minutes:
 6475 0015 0A        		.byte	10
 6476               	.global	hours
 6479               	hours:
 6480 0016 0A        		.byte	10
 6481               	.global	serialInInteger
 6482               		.section .bss
 6485               	serialInInteger:
 6486 0020 0000      		.zero	2
 6487               		.comm	printBuffer,100,1
 6488               		.comm	myUartString,100,1
 6489               		.comm	uartString,100,1
 6490               	.global	uartStringIndex
 6493               	uartStringIndex:
 6494 0022 00        		.zero	1
 6495               	.global	SERIAL_NUMBER
 6496               		.section	.rodata
 6499               	SERIAL_NUMBER:
 6500 000d 6400      		.word	100
 6501               		.local	input_index.2181
 6502               		.comm	input_index.2181,1,1
 6503               		.local	timebaseCounter.2187
 6504               		.comm	timebaseCounter.2187,1,1
 6505               		.section	.progmem.data,"a",@progbits
 6508               	__c.2230:
 6509 0000 5541 5254 		.string	"UART Frame Error: "
 6509      2046 7261 
 6509      6D65 2045 
 6509      7272 6F72 
 6509      3A20 00
 6512               	__c.2232:
 6513 0013 5541 5254 		.string	"UART Overrun Error: "
 6513      204F 7665 
 6513      7272 756E 
 6513      2045 7272 
 6513      6F72 3A20 
 6516               	__c.2234:
 6517 0028 4275 6666 		.string	"Buffer overflow error: "
 6517      6572 206F 
 6517      7665 7266 
 6517      6C6F 7720 
 6517      6572 726F 
 6518               		.local	milliSeconds.2247
 6519               		.comm	milliSeconds.2247,2,1
 6520               		.local	clockCalCounter.2248
 6521               		.comm	clockCalCounter.2248,4,1
 6522               		.local	acFreqFiltCtr.2250
 6523               		.comm	acFreqFiltCtr.2250,2,1
 6524               		.text
 6525               	.Letext0:
 6526               		.file 5 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/stdint.h"
 6527               		.file 6 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/string.h"
 6528               		.file 7 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/stdlib.h"
 6529               		.file 8 "uart.h"
 6530               		.file 9 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/avr/eeprom.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:4      *ABS*:000000000000003f __SREG__
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:12     .text:0000000000000000 ds18b20_reset
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:108    .text:0000000000000024 ds18b20_writebit
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:176    .text:000000000000003e ds18b20_readbit
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:258    .text:0000000000000060 ds18b20_writebyte
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:305    .text:000000000000007e ds18b20_readbyte
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:363    .text:00000000000000a4 ds18b20_gettemp
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:513    .text:0000000000000154 ioInit
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:548    .text:0000000000000170 extInterruptInit
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:567    .text:000000000000017c rtcInit
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:598    .text:000000000000019c adcInit
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:624    .text:00000000000001b4 boostConverterInit
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:646    .text:00000000000001c2 __vector_21
                             .bss:0000000000000023 input_index.2181
                            *COM*:0000000000000004 adc_raw
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:723    .text:000000000000021c __vector_3
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6502   .bss:0000000000000024 timebaseCounter.2187
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6353   .data:000000000000000c acclock
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6454   .data:0000000000000010 seconds
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6252   .bss:0000000000000008 acZeroCrossCounter
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:788    .text:000000000000026e toggle_led
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:806    .text:0000000000000276 blip_led
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:843    .text:0000000000000284 is_switch_pressed
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:877    .text:000000000000029e splitString
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:943    .text:00000000000002e6 copy_command
                            *COM*:0000000000000064 uartString
                            *COM*:0000000000000064 myUartString
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:977    .text:0000000000000308 inRange
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:1037   .text:0000000000000334 print_value
                            *COM*:0000000000000064 printBuffer
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:1090   .text:0000000000000364 print_csv
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:1144   .text:000000000000038c uart_ok
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:1181   .text:000000000000039c uartWelcome
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:1264   .text:000000000000040c uartInit
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:1286   .text:0000000000000414 serialPrintDateTime
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6459   .data:0000000000000011 year
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6464   .data:0000000000000013 month
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6469   .data:0000000000000014 day
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6425   .data:000000000000000f miltime
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6479   .data:0000000000000016 hours
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6474   .data:0000000000000015 minutes
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:1420   .text:00000000000004f0 isLeapYear
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:1483   .text:000000000000052a updateDateTime
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:1622   .text:00000000000005fe dayOfWeek
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:1701   .text:0000000000000664 readTemperature
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6290   .data:0000000000000006 celsiusTemperature
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:1730   .text:0000000000000688 updateBoostConverter
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6259   .data:0000000000000000 boostLowPwm
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6264   .data:0000000000000001 boostHighPwm
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6270   .bss:000000000000000a boostConverterPwm
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:1765   .text:00000000000006a6 updateTemperatureFilter
                            *COM*:0000000000000018 movingAverageArray
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6276   .bss:000000000000000b arraySum
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6282   .data:0000000000000002 averageCelsiusTemperature
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:1903   .text:000000000000076e serialPrintTemperature
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6377   .data:000000000000000e celsius
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:1976   .text:00000000000007d0 serialPrintAcFrequency
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6242   .bss:0000000000000002 acFrequency
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:2021   .text:0000000000000800 readEepromToVars
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6442   .eeprom:0000000000000011 ee_mscal
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6448   .bss:000000000000001c mscal
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6311   .eeprom:0000000000000004 ee_nixiesleepstart
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6317   .bss:0000000000000013 nixiesleepstart
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6299   .eeprom:0000000000000000 ee_nixiesleepend
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6305   .bss:000000000000000f nixiesleepend
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6419   .eeprom:0000000000000010 ee_miltime
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6407   .eeprom:000000000000000f ee_showtherm
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6413   .bss:0000000000000019 showtherm
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6395   .eeprom:000000000000000e ee_showfreq
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6401   .bss:0000000000000018 showfreq
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6383   .eeprom:000000000000000d ee_showdate
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6389   .bss:0000000000000017 showdate
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6371   .eeprom:000000000000000c ee_celsius
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6359   .eeprom:000000000000000b ee_doecho
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6365   .data:000000000000000d doecho
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6347   .eeprom:000000000000000a ee_acclock
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6335   .eeprom:0000000000000009 ee_xtalisfast
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6341   .data:000000000000000b xtalisfast
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6323   .eeprom:0000000000000008 ee_toggleled
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6329   .data:000000000000000a toggleled
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:2116   .text:00000000000008b6 updateVarsToEeprom
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:2308   .text:000000000000096a process_command
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:3969   .text:000000000000140a checkSerialIn
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6508   .progmem.data:0000000000000000 __c.2230
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6512   .progmem.data:0000000000000013 __c.2232
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6516   .progmem.data:0000000000000028 __c.2234
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6493   .bss:0000000000000022 uartStringIndex
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:4077   .text:0000000000001484 acPowerOk
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:4099   .text:0000000000001492 __vector_11
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6504   .bss:0000000000000025 milliSeconds.2247
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6519   .bss:0000000000000027 clockCalCounter.2248
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6521   .bss:000000000000002b acFreqFiltCtr.2250
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6247   .bss:0000000000000006 acZeroCrossSnapshot
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6237   .bss:0000000000000001 acFreqFlag
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:4345   .text:000000000000163a turnOnOffBoostConverter
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:4382   .text:0000000000001650 updateNixieOutputState
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:4493   .text:00000000000016e2 updateAcFrequency
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:4556   .text:000000000000175c shiftRegisterPulse
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:4574   .text:0000000000001762 shiftRegisterSetOutput
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:4592   .text:0000000000001768 shiftByteOut
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:4667   .text:00000000000017a6 sendIntegerToNixie
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:4866   .text:0000000000001856 antiCathodePoisonPattern
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:5320   .text:0000000000001a2e checkCathodePoison
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6232   .bss:0000000000000000 cathodePoisonFlag
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:5416   .text:0000000000001ab0 nixiePrintTemperature
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:5621   .text:0000000000001bc2 nixiePrintTime
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:5754   .text:0000000000001c56 nixiePrintDate
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:5854   .text:0000000000001cc8 nixiePrintAcFrequency
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6000   .text.startup:0000000000000000 main
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6436   .bss:000000000000001b prevSeconds
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6431   .bss:000000000000001a prevMinutes
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6485   .bss:0000000000000020 serialInInteger
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccPzvur6.s:6499   .rodata:000000000000000d SERIAL_NUMBER

UNDEFINED SYMBOLS
__floatsisf
__floatunsisf
__mulsf3
__addsf3
strchr
strcpy
atol
ultoa
uart_puts
uart_init
itoa
uart_putc
__udivmodhi4
__divmodhi4
__divsf3
__udivmodqi4
dtostrf
__eerd_dword_m328p
__eerd_byte_m328p
__eeupd_dword_m328p
__eeupd_byte_m328p
strcasestr
strstr
uart_getc
uart_puts_p
__ltsf2
__gtsf2
__fixunssfsi
__gesf2
__subsf3
__udivmodsi4
__do_copy_data
__do_clear_bss
