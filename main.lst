   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	ds18b20_reset
  12               	ds18b20_reset:
  13               	.LFB7:
  14               		.file 1 "ds18b20.c"
   1:ds18b20.c     **** /*
   2:ds18b20.c     **** ds18b20 lib 0x01
   3:ds18b20.c     **** 
   4:ds18b20.c     **** copyright (c) Davide Gironi, 2012
   5:ds18b20.c     **** 
   6:ds18b20.c     **** Released under GPLv3.
   7:ds18b20.c     **** Please refer to LICENSE file for licensing information.
   8:ds18b20.c     **** */
   9:ds18b20.c     **** 
  10:ds18b20.c     **** #include <avr/io.h>
  11:ds18b20.c     **** #include <util/delay.h>
  12:ds18b20.c     **** 
  13:ds18b20.c     **** #include "ds18b20.h"
  14:ds18b20.c     **** 
  15:ds18b20.c     **** /*
  16:ds18b20.c     ****  * ds18b20 init
  17:ds18b20.c     ****  */
  18:ds18b20.c     **** uint8_t ds18b20_reset(void) {
  15               		.loc 1 18 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  19:ds18b20.c     **** 	uint8_t i;
  20:ds18b20.c     **** 
  21:ds18b20.c     **** 	//low for 480us
  22:ds18b20.c     **** 	DS18B20_PORT &= ~ (1<<DS18B20_DQ); //low
  21               		.loc 1 22 0
  22 0000 4598      		cbi 0x8,5
  23:ds18b20.c     **** 	DS18B20_DDR |= (1<<DS18B20_DQ); //output
  23               		.loc 1 23 0
  24 0002 3D9A      		sbi 0x7,5
  25               	.LVL0:
  26               	.LBB175:
  27               	.LBB176:
  28               	.LBB177:
  29               	.LBB178:
  30               	.LBB179:
  31               	.LBB180:
  32               		.file 2 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h"
   1:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****    All rights reserved.
   4:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
   5:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
   8:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  11:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****      distribution.
  15:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  16:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  20:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  32:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h 2143 2010-06-08 21:19:51Z joerg_wunsch $ */
  33:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  34:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  37:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  39:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  40:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  41:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  42:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** #endif
  43:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  44:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** /** \file */
  45:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     \code
  47:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  48:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     \endcode
  49:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  50:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  51:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  57:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  58:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  61:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  62:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     to the overall delay time.
  64:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  65:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  67:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** */
  68:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  69:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  71:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     register.
  76:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  77:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     can be achieved.
  79:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** */
  80:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** void
  81:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** {
  83:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 	);
  89:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** }
  90:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  91:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  93:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     counter register pair.
  98:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 
  99:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h ****  */
 102:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** void
 103:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** {
 105:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  33               		.loc 2 105 0
  34 0004 8EEA      		ldi r24,lo8(-82)
  35 0006 97E0      		ldi r25,lo8(7)
  36               	/* #APP */
  37               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
  38 0008 0197      		1: sbiw r24,1
  39 000a 01F4      		brne 1b
  40               	 ;  0 "" 2
  41               	.LVL1:
  42               	/* #NOAPP */
  43               	.LBE180:
  44               	.LBE179:
  45               	.LBE178:
  46               	.LBE177:
  47               	.LBE176:
  48               	.LBE175:
  24:ds18b20.c     **** 	_delay_us(480);
  25:ds18b20.c     **** 
  26:ds18b20.c     **** 	//release line and wait for 60uS
  27:ds18b20.c     **** 	DS18B20_DDR &= ~(1<<DS18B20_DQ); //input
  49               		.loc 1 27 0
  50 000c 3D98      		cbi 0x7,5
  51               	.LVL2:
  52               	.LBB181:
  53               	.LBB182:
  54               	.LBB183:
  55               	.LBB184:
  56               	.LBB185:
  57               	.LBB186:
  58               		.loc 2 105 0
  59 000e 85EF      		ldi r24,lo8(-11)
  60 0010 90E0      		ldi r25,0
  61               	/* #APP */
  62               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
  63 0012 0197      		1: sbiw r24,1
  64 0014 01F4      		brne 1b
  65               	 ;  0 "" 2
  66               	.LVL3:
  67               	/* #NOAPP */
  68               	.LBE186:
  69               	.LBE185:
  70               	.LBE184:
  71               	.LBE183:
  72               	.LBE182:
  73               	.LBE181:
  28:ds18b20.c     **** 	_delay_us(60);
  29:ds18b20.c     **** 
  30:ds18b20.c     **** 	//get value and wait 420us
  31:ds18b20.c     **** 	i = (DS18B20_PIN & (1<<DS18B20_DQ));
  74               		.loc 1 31 0
  75 0016 86B1      		in r24,0x6
  76               	.LVL4:
  77               	.LBB187:
  78               	.LBB188:
  79               	.LBB189:
  80               	.LBB190:
  81               	.LBB191:
  82               	.LBB192:
  83               		.loc 2 105 0
  84 0018 E8EB      		ldi r30,lo8(-72)
  85 001a F6E0      		ldi r31,lo8(6)
  86               	/* #APP */
  87               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
  88 001c 3197      		1: sbiw r30,1
  89 001e 01F4      		brne 1b
  90               	 ;  0 "" 2
  91               	.LVL5:
  92               	/* #NOAPP */
  93               	.LBE192:
  94               	.LBE191:
  95               	.LBE190:
  96               	.LBE189:
  97               	.LBE188:
  98               	.LBE187:
  32:ds18b20.c     **** 	_delay_us(420);
  33:ds18b20.c     **** 
  34:ds18b20.c     **** 	//return the read value, 0=ok, 1=error
  35:ds18b20.c     **** 	return i;
  36:ds18b20.c     **** }
  99               		.loc 1 36 0
 100 0020 8072      		andi r24,lo8(32)
 101               	.LVL6:
 102 0022 0895      		ret
 103               		.cfi_endproc
 104               	.LFE7:
 106               	.global	ds18b20_writebit
 108               	ds18b20_writebit:
 109               	.LFB8:
  37:ds18b20.c     **** 
  38:ds18b20.c     **** /*
  39:ds18b20.c     ****  * write one bit
  40:ds18b20.c     ****  */
  41:ds18b20.c     **** void ds18b20_writebit(uint8_t bit){
 110               		.loc 1 41 0
 111               		.cfi_startproc
 112               	.LVL7:
 113               	/* prologue: function */
 114               	/* frame size = 0 */
 115               	/* stack size = 0 */
 116               	.L__stack_usage = 0
  42:ds18b20.c     **** 	//low for 1uS
  43:ds18b20.c     **** 	DS18B20_PORT &= ~ (1<<DS18B20_DQ); //low
 117               		.loc 1 43 0
 118 0024 4598      		cbi 0x8,5
  44:ds18b20.c     **** 	DS18B20_DDR |= (1<<DS18B20_DQ); //output
 119               		.loc 1 44 0
 120 0026 3D9A      		sbi 0x7,5
 121               	.LVL8:
 122               	.LBB193:
 123               	.LBB194:
 124               	.LBB195:
 125               	.LBB196:
  83:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 126               		.loc 2 83 0
 127 0028 95E0      		ldi r25,lo8(5)
 128               	/* #APP */
 129               	 ;  83 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 130 002a 9A95      		1: dec r25
 131 002c 01F4      		brne 1b
 132               	 ;  0 "" 2
 133               	.LVL9:
 134               	/* #NOAPP */
 135               	.LBE196:
 136               	.LBE195:
 137               	.LBE194:
 138               	.LBE193:
  45:ds18b20.c     **** 	_delay_us(1);
  46:ds18b20.c     **** 
  47:ds18b20.c     **** 	//if we want to write 1, release the line (if not will keep low)
  48:ds18b20.c     **** 	if(bit)
 139               		.loc 1 48 0
 140 002e 8111      		cpse r24,__zero_reg__
  49:ds18b20.c     **** 		DS18B20_DDR &= ~(1<<DS18B20_DQ); //input
 141               		.loc 1 49 0
 142 0030 3D98      		cbi 0x7,5
 143               	.L3:
 144               	.LVL10:
 145               	.LBB197:
 146               	.LBB198:
 147               	.LBB199:
 148               	.LBB200:
 149               	.LBB201:
 150               	.LBB202:
 151               		.loc 2 105 0
 152 0032 85EF      		ldi r24,lo8(-11)
 153 0034 90E0      		ldi r25,0
 154               	.LVL11:
 155               	/* #APP */
 156               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 157 0036 0197      		1: sbiw r24,1
 158 0038 01F4      		brne 1b
 159               	 ;  0 "" 2
 160               	.LVL12:
 161               	/* #NOAPP */
 162               	.LBE202:
 163               	.LBE201:
 164               	.LBE200:
 165               	.LBE199:
 166               	.LBE198:
 167               	.LBE197:
  50:ds18b20.c     **** 
  51:ds18b20.c     **** 	//wait 60uS and release the line
  52:ds18b20.c     **** 	_delay_us(60);
  53:ds18b20.c     **** 	DS18B20_DDR &= ~(1<<DS18B20_DQ); //input
 168               		.loc 1 53 0
 169 003a 3D98      		cbi 0x7,5
 170 003c 0895      		ret
 171               		.cfi_endproc
 172               	.LFE8:
 174               	.global	ds18b20_readbit
 176               	ds18b20_readbit:
 177               	.LFB9:
  54:ds18b20.c     **** }
  55:ds18b20.c     **** 
  56:ds18b20.c     **** /*
  57:ds18b20.c     ****  * read one bit
  58:ds18b20.c     ****  */
  59:ds18b20.c     **** uint8_t ds18b20_readbit(void){
 178               		.loc 1 59 0
 179               		.cfi_startproc
 180               	/* prologue: function */
 181               	/* frame size = 0 */
 182               	/* stack size = 0 */
 183               	.L__stack_usage = 0
 184               	.LVL13:
  60:ds18b20.c     **** 	uint8_t bit=0;
  61:ds18b20.c     **** 
  62:ds18b20.c     **** 	//low for 1uS
  63:ds18b20.c     **** 	DS18B20_PORT &= ~ (1<<DS18B20_DQ); //low
 185               		.loc 1 63 0
 186 003e 4598      		cbi 0x8,5
  64:ds18b20.c     **** 	DS18B20_DDR |= (1<<DS18B20_DQ); //output
 187               		.loc 1 64 0
 188 0040 3D9A      		sbi 0x7,5
 189               	.LVL14:
 190               	.LBB203:
 191               	.LBB204:
 192               	.LBB205:
 193               	.LBB206:
  83:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 194               		.loc 2 83 0
 195 0042 85E0      		ldi r24,lo8(5)
 196               	/* #APP */
 197               	 ;  83 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 198 0044 8A95      		1: dec r24
 199 0046 01F4      		brne 1b
 200               	 ;  0 "" 2
 201               	.LVL15:
 202               	/* #NOAPP */
 203               	.LBE206:
 204               	.LBE205:
 205               	.LBE204:
 206               	.LBE203:
  65:ds18b20.c     **** 	_delay_us(1);
  66:ds18b20.c     **** 
  67:ds18b20.c     **** 	//release line and wait for 14uS
  68:ds18b20.c     **** 	DS18B20_DDR &= ~(1<<DS18B20_DQ); //input
 207               		.loc 1 68 0
 208 0048 3D98      		cbi 0x7,5
 209               	.LVL16:
 210               	.LBB207:
 211               	.LBB208:
 212               	.LBB209:
 213               	.LBB210:
  83:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 214               		.loc 2 83 0
 215 004a 8CE4      		ldi r24,lo8(76)
 216               	/* #APP */
 217               	 ;  83 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 218 004c 8A95      		1: dec r24
 219 004e 01F4      		brne 1b
 220               	 ;  0 "" 2
 221               	.LVL17:
 222               	/* #NOAPP */
 223               	.LBE210:
 224               	.LBE209:
 225               	.LBE208:
 226               	.LBE207:
  69:ds18b20.c     **** 	_delay_us(14);
  70:ds18b20.c     **** 
  71:ds18b20.c     **** 	//read the value
  72:ds18b20.c     **** 	if(DS18B20_PIN & (1<<DS18B20_DQ))
 227               		.loc 1 72 0
 228 0050 86B1      		in r24,0x6
 229               	.LVL18:
 230               	.LBB211:
 231               	.LBB212:
 232               	.LBB213:
 233               	.LBB214:
  83:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 234               		.loc 2 83 0
 235 0052 95EF      		ldi r25,lo8(-11)
 236               	/* #APP */
 237               	 ;  83 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 238 0054 9A95      		1: dec r25
 239 0056 01F4      		brne 1b
 240               	 ;  0 "" 2
 241               	.LVL19:
 242               	/* #NOAPP */
 243               	.LBE214:
 244               	.LBE213:
 245               	.LBE212:
 246               	.LBE211:
  73:ds18b20.c     **** 		bit=1;
  74:ds18b20.c     **** 
  75:ds18b20.c     **** 	//wait 45uS and return read value
  76:ds18b20.c     **** 	_delay_us(45);
  77:ds18b20.c     **** 	return bit;
  78:ds18b20.c     **** }
 247               		.loc 1 78 0
 248 0058 85FB      		bst r24,5
 249 005a 8827      		clr r24
 250 005c 80F9      		bld r24,0
 251               	.LVL20:
 252 005e 0895      		ret
 253               		.cfi_endproc
 254               	.LFE9:
 256               	.global	ds18b20_writebyte
 258               	ds18b20_writebyte:
 259               	.LFB10:
  79:ds18b20.c     **** 
  80:ds18b20.c     **** /*
  81:ds18b20.c     ****  * write one byte
  82:ds18b20.c     ****  */
  83:ds18b20.c     **** void ds18b20_writebyte(uint8_t byte){
 260               		.loc 1 83 0
 261               		.cfi_startproc
 262               	.LVL21:
 263 0060 CF93      		push r28
 264               	.LCFI0:
 265               		.cfi_def_cfa_offset 3
 266               		.cfi_offset 28, -2
 267 0062 DF93      		push r29
 268               	.LCFI1:
 269               		.cfi_def_cfa_offset 4
 270               		.cfi_offset 29, -3
 271               	/* prologue: function */
 272               	/* frame size = 0 */
 273               	/* stack size = 2 */
 274               	.L__stack_usage = 2
 275 0064 D82F      		mov r29,r24
 276               	.LVL22:
  84:ds18b20.c     **** 	uint8_t i=8;
  85:ds18b20.c     **** 	while(i--){
 277               		.loc 1 85 0
 278 0066 C9E0      		ldi r28,lo8(9)
 279 0068 00C0      		rjmp .L9
 280               	.LVL23:
 281               	.L10:
  86:ds18b20.c     **** 		ds18b20_writebit(byte&1);
 282               		.loc 1 86 0
 283 006a 8D2F      		mov r24,r29
 284 006c 8170      		andi r24,lo8(1)
 285 006e 0E94 0000 		call ds18b20_writebit
 286               	.LVL24:
  87:ds18b20.c     **** 		byte >>= 1;
 287               		.loc 1 87 0
 288 0072 D695      		lsr r29
 289               	.LVL25:
 290               	.L9:
 291 0074 C150      		subi r28,lo8(-(-1))
  85:ds18b20.c     **** 	while(i--){
 292               		.loc 1 85 0 discriminator 1
 293 0076 01F4      		brne .L10
 294               	/* epilogue start */
  88:ds18b20.c     **** 	}
  89:ds18b20.c     **** }
 295               		.loc 1 89 0
 296 0078 DF91      		pop r29
 297               	.LVL26:
 298 007a CF91      		pop r28
 299 007c 0895      		ret
 300               		.cfi_endproc
 301               	.LFE10:
 303               	.global	ds18b20_readbyte
 305               	ds18b20_readbyte:
 306               	.LFB11:
  90:ds18b20.c     **** 
  91:ds18b20.c     **** /*
  92:ds18b20.c     ****  * read one byte
  93:ds18b20.c     ****  */
  94:ds18b20.c     **** uint8_t ds18b20_readbyte(void){
 307               		.loc 1 94 0
 308               		.cfi_startproc
 309 007e CF93      		push r28
 310               	.LCFI2:
 311               		.cfi_def_cfa_offset 3
 312               		.cfi_offset 28, -2
 313 0080 DF93      		push r29
 314               	.LCFI3:
 315               		.cfi_def_cfa_offset 4
 316               		.cfi_offset 29, -3
 317               	/* prologue: function */
 318               	/* frame size = 0 */
 319               	/* stack size = 2 */
 320               	.L__stack_usage = 2
 321               	.LVL27:
  95:ds18b20.c     **** 	uint8_t i=8, n=0;
  96:ds18b20.c     **** 	while(i--){
 322               		.loc 1 96 0
 323 0082 D9E0      		ldi r29,lo8(9)
  95:ds18b20.c     **** 	uint8_t i=8, n=0;
 324               		.loc 1 95 0
 325 0084 C0E0      		ldi r28,0
 326               		.loc 1 96 0
 327 0086 00C0      		rjmp .L12
 328               	.LVL28:
 329               	.L13:
  97:ds18b20.c     **** 		n >>= 1;
  98:ds18b20.c     **** 		n |= (ds18b20_readbit()<<7);
 330               		.loc 1 98 0
 331 0088 0E94 0000 		call ds18b20_readbit
 332               	.LVL29:
 333 008c 20E8      		ldi r18,lo8(-128)
 334 008e 829F      		mul r24,r18
 335 0090 C001      		movw r24,r0
 336 0092 1124      		clr __zero_reg__
  97:ds18b20.c     **** 		n >>= 1;
 337               		.loc 1 97 0
 338 0094 C695      		lsr r28
 339               	.LVL30:
 340               		.loc 1 98 0
 341 0096 C82B      		or r28,r24
 342               	.LVL31:
 343               	.L12:
 344 0098 D150      		subi r29,lo8(-(-1))
  96:ds18b20.c     **** 	while(i--){
 345               		.loc 1 96 0 discriminator 1
 346 009a 01F4      		brne .L13
  99:ds18b20.c     **** 	}
 100:ds18b20.c     **** 	return n;
 101:ds18b20.c     **** }
 347               		.loc 1 101 0
 348 009c 8C2F      		mov r24,r28
 349               	/* epilogue start */
 350 009e DF91      		pop r29
 351 00a0 CF91      		pop r28
 352               	.LVL32:
 353 00a2 0895      		ret
 354               		.cfi_endproc
 355               	.LFE11:
 357               	.global	__floatsisf
 358               	.global	__floatunsisf
 359               	.global	__mulsf3
 360               	.global	__addsf3
 361               	.global	ds18b20_gettemp
 363               	ds18b20_gettemp:
 364               	.LFB12:
 102:ds18b20.c     **** 
 103:ds18b20.c     **** /*
 104:ds18b20.c     ****  * get temperature
 105:ds18b20.c     ****  */
 106:ds18b20.c     **** double ds18b20_gettemp(void) {
 365               		.loc 1 106 0
 366               		.cfi_startproc
 367 00a4 CF92      		push r12
 368               	.LCFI4:
 369               		.cfi_def_cfa_offset 3
 370               		.cfi_offset 12, -2
 371 00a6 DF92      		push r13
 372               	.LCFI5:
 373               		.cfi_def_cfa_offset 4
 374               		.cfi_offset 13, -3
 375 00a8 EF92      		push r14
 376               	.LCFI6:
 377               		.cfi_def_cfa_offset 5
 378               		.cfi_offset 14, -4
 379 00aa FF92      		push r15
 380               	.LCFI7:
 381               		.cfi_def_cfa_offset 6
 382               		.cfi_offset 15, -5
 383 00ac 1F93      		push r17
 384               	.LCFI8:
 385               		.cfi_def_cfa_offset 7
 386               		.cfi_offset 17, -6
 387 00ae CF93      		push r28
 388               	.LCFI9:
 389               		.cfi_def_cfa_offset 8
 390               		.cfi_offset 28, -7
 391 00b0 DF93      		push r29
 392               	.LCFI10:
 393               		.cfi_def_cfa_offset 9
 394               		.cfi_offset 29, -8
 395               	/* prologue: function */
 396               	/* frame size = 0 */
 397               	/* stack size = 7 */
 398               	.L__stack_usage = 7
 399               	.LVL33:
 107:ds18b20.c     **** 	uint8_t temperature[2];
 108:ds18b20.c     **** 	int8_t digit;
 109:ds18b20.c     **** 	uint16_t decimal;
 110:ds18b20.c     **** 	double retd = 0;
 111:ds18b20.c     **** 
 112:ds18b20.c     **** 	ds18b20_reset(); //reset
 400               		.loc 1 112 0
 401 00b2 0E94 0000 		call ds18b20_reset
 402               	.LVL34:
 113:ds18b20.c     **** 	ds18b20_writebyte(DS18B20_CMD_SKIPROM); //skip ROM
 403               		.loc 1 113 0
 404 00b6 8CEC      		ldi r24,lo8(-52)
 405 00b8 0E94 0000 		call ds18b20_writebyte
 406               	.LVL35:
 114:ds18b20.c     **** 	ds18b20_writebyte(DS18B20_CMD_CONVERTTEMP); //start temperature conversion
 407               		.loc 1 114 0
 408 00bc 84E4      		ldi r24,lo8(68)
 409 00be 0E94 0000 		call ds18b20_writebyte
 410               	.LVL36:
 411               	.L15:
 115:ds18b20.c     **** 
 116:ds18b20.c     **** 	while(!ds18b20_readbit()); //wait until conversion is complete
 412               		.loc 1 116 0 discriminator 1
 413 00c2 0E94 0000 		call ds18b20_readbit
 414               	.LVL37:
 415 00c6 8823      		tst r24
 416 00c8 01F0      		breq .L15
 117:ds18b20.c     **** 
 118:ds18b20.c     **** 	ds18b20_reset(); //reset
 417               		.loc 1 118 0
 418 00ca 0E94 0000 		call ds18b20_reset
 419               	.LVL38:
 119:ds18b20.c     **** 	ds18b20_writebyte(DS18B20_CMD_SKIPROM); //skip ROM
 420               		.loc 1 119 0
 421 00ce 8CEC      		ldi r24,lo8(-52)
 422 00d0 0E94 0000 		call ds18b20_writebyte
 423               	.LVL39:
 120:ds18b20.c     **** 	ds18b20_writebyte(DS18B20_CMD_RSCRATCHPAD); //read scratchpad
 424               		.loc 1 120 0
 425 00d4 8EEB      		ldi r24,lo8(-66)
 426 00d6 0E94 0000 		call ds18b20_writebyte
 427               	.LVL40:
 121:ds18b20.c     **** 
 122:ds18b20.c     **** 	//read 2 byte from scratchpad
 123:ds18b20.c     **** 	temperature[0] = ds18b20_readbyte();
 428               		.loc 1 123 0
 429 00da 0E94 0000 		call ds18b20_readbyte
 430               	.LVL41:
 431 00de C82F      		mov r28,r24
 432               	.LVL42:
 124:ds18b20.c     **** 	temperature[1] = ds18b20_readbyte();
 433               		.loc 1 124 0
 434 00e0 0E94 0000 		call ds18b20_readbyte
 435               	.LVL43:
 436 00e4 182F      		mov r17,r24
 437               	.LVL44:
 125:ds18b20.c     **** 
 126:ds18b20.c     **** 	ds18b20_reset(); //reset
 438               		.loc 1 126 0
 439 00e6 0E94 0000 		call ds18b20_reset
 440               	.LVL45:
 127:ds18b20.c     **** 
 128:ds18b20.c     **** 	//store temperature integer digits
 129:ds18b20.c     **** 	digit = temperature[0]>>4;
 441               		.loc 1 129 0
 442 00ea 6C2F      		mov r22,r28
 443 00ec 6295      		swap r22
 444 00ee 6F70      		andi r22,lo8(15)
 445               	.LVL46:
 130:ds18b20.c     **** 	digit |= (temperature[1]&0x7)<<4;
 131:ds18b20.c     **** 
 132:ds18b20.c     **** 	//store temperature decimal digits
 133:ds18b20.c     **** 	decimal = temperature[0]&0xf;
 446               		.loc 1 133 0
 447 00f0 CF70      		andi r28,lo8(15)
 448               	.LVL47:
 449 00f2 D0E0      		ldi r29,0
 450               	.LVL48:
 130:ds18b20.c     **** 	digit |= (temperature[1]&0x7)<<4;
 451               		.loc 1 130 0
 452 00f4 1770      		andi r17,lo8(7)
 453               	.LVL49:
 454 00f6 20E1      		ldi r18,lo8(16)
 455 00f8 129F      		mul r17,r18
 456 00fa C001      		movw r24,r0
 457 00fc 1124      		clr __zero_reg__
 458 00fe 682B      		or r22,r24
 134:ds18b20.c     **** 	decimal *= DS18B20_DECIMALSTEPS;
 135:ds18b20.c     **** 
 136:ds18b20.c     **** 	//compose the double temperature value and return it
 137:ds18b20.c     **** 	retd = digit + decimal * 0.0001;
 459               		.loc 1 137 0
 460 0100 7727      		clr r23
 461 0102 67FD      		sbrc r22,7
 462 0104 7095      		com r23
 463 0106 872F      		mov r24,r23
 464 0108 972F      		mov r25,r23
 465 010a 0E94 0000 		call __floatsisf
 466               	.LVL50:
 467 010e 6B01      		movw r12,r22
 468 0110 7C01      		movw r14,r24
 134:ds18b20.c     **** 	decimal *= DS18B20_DECIMALSTEPS;
 469               		.loc 1 134 0
 470 0112 81E7      		ldi r24,lo8(113)
 471 0114 92E0      		ldi r25,lo8(2)
 472 0116 C89F      		mul r28,r24
 473 0118 B001      		movw r22,r0
 474 011a C99F      		mul r28,r25
 475 011c 700D      		add r23,r0
 476 011e D89F      		mul r29,r24
 477 0120 700D      		add r23,r0
 478 0122 1124      		clr r1
 479               	.LVL51:
 480               		.loc 1 137 0
 481 0124 80E0      		ldi r24,0
 482 0126 90E0      		ldi r25,0
 483 0128 0E94 0000 		call __floatunsisf
 484               	.LVL52:
 485 012c 27E1      		ldi r18,lo8(23)
 486 012e 37EB      		ldi r19,lo8(-73)
 487 0130 41ED      		ldi r20,lo8(-47)
 488 0132 58E3      		ldi r21,lo8(56)
 489 0134 0E94 0000 		call __mulsf3
 490               	.LVL53:
 491 0138 9B01      		movw r18,r22
 492 013a AC01      		movw r20,r24
 493 013c C701      		movw r24,r14
 494 013e B601      		movw r22,r12
 495 0140 0E94 0000 		call __addsf3
 496               	.LVL54:
 497               	/* epilogue start */
 138:ds18b20.c     **** 
 139:ds18b20.c     **** 	return retd;
 140:ds18b20.c     **** }
 498               		.loc 1 140 0
 499 0144 DF91      		pop r29
 500 0146 CF91      		pop r28
 501               	.LVL55:
 502 0148 1F91      		pop r17
 503 014a FF90      		pop r15
 504 014c EF90      		pop r14
 505 014e DF90      		pop r13
 506 0150 CF90      		pop r12
 507 0152 0895      		ret
 508               		.cfi_endproc
 509               	.LFE12:
 511               	.global	ioInit
 513               	ioInit:
 514               	.LFB14:
 515               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  ~~~~~~~~~~~~~~~~~~~******************** Program Description ********************~~~~~~~~~~~~~~~~~~
   3:main.c        ****  
   4:main.c        **** 	Program Title:	Nixie Clock
   5:main.c        **** 	Author:			Pete Mills
   6:main.c        **** 	Email:			mills.pete@gmail.com
   7:main.c        **** 	Website:        petemills.blogspot.com
   8:main.c        **** 	Version:		1.0
   9:main.c        **** 	Filename:		main.c
  10:main.c        **** 	License:		CC BY-NC-SA 3.0 ( Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported )
  11:main.c        ****  
  12:main.c        ****     Clock Description:
  13:main.c        ****     
  14:main.c        ****     This nixie clock is settable using a USB serial interface.  For details please refer to the use
  15:main.c        ****     manual at the above website.
  16:main.c        ****     
  17:main.c        ****     There is a PC app to simplify the setting of the clock.
  18:main.c        ****     
  19:main.c        ****     This clock provides a mechanism for xtal calibration so that it can keep time with it's own clo
  20:main.c        ****     It also has AC zero cross hardware and software to allow timekeeping with the incoming AC power
  21:main.c        ****     
  22:main.c        ****     This clock requires no external RTC and instead relies upon software to keep track of time, dat
  23:main.c        ****     leap year, day of the week, etc. 
  24:main.c        ****     
  25:main.c        ****     This clock keeps a running average of the ambient temperature with a DS18b20 sensor.
  26:main.c        ****     
  27:main.c        ****     The clock can calculate the frequency of the AC power line and display it.
  28:main.c        ****     
  29:main.c        ****     The boost converter for the HV DC supply is driven by the ATMega328.
  30:main.c        ****     
  31:main.c        ****  
  32:main.c        ****     Software:
  33:main.c        ****     This software may borrow from some of the example code listed below:
  34:main.c        ****     http://homepage.hispeed.ch/peterfleury/doxygen/avr-gcc-libraries/group__pfleury__uart.html
  35:main.c        ****     http://teslabs.com/openplayer/docs/docs/other/ds18b20_pre1.pdf
  36:main.c        ****     https://github.com/ColinBrosseau/AVR-UART-Parse-exemple
  37:main.c        ****  
  38:main.c        **** 	Hardware Description:
  39:main.c        **** 	
  40:main.c        **** 	Processor:	ATMega328
  41:main.c        **** 	F_CPU:		16384000 Hz
  42:main.c        **** 	
  43:main.c        **** 	Schematic at petemills.blogspot.com
  44:main.c        **** 	
  45:main.c        ****  ~~~~~~~~~~~~~~~~~~~******************** Program Description ********************~~~~~~~~~~~~~~~~~~
  46:main.c        ****  
  47:main.c        ****  
  48:main.c        ****  
  49:main.c        ****  
  50:main.c        ****  
  51:main.c        ****  ~~~~~~~~~~~~~~~~~~~~~******************** Fuse Settings ********************~~~~~~~~~~~~~~~~~~~~~~
  52:main.c        ****  
  53:main.c        **** 	Default		Description												Fuse Name / Setting
  54:main.c        **** 	
  55:main.c        **** 	CHANGED		External Crystal Osc.; 16K CK / 14 CK + 65 mS;			[ CKSEL = 1111 SUT = 11 ]
  56:main.c        **** 	UNCHANGED	Clock output on PORTB0; 								[ CKOUT = 0 ]
  57:main.c        **** 	CHANGED		Divide clock by 8 internally; 							[ CKDIV8 = 0 ]
  58:main.c        **** 	UNCHANGED	Boot Reset vector Enabled (default address=$0000); 		[ BOOTRST = 0 ]
  59:main.c        **** 	UNCHANGED	Boot Flash section size = 2048 words;					[ BOOTSZ = 00 ]
  60:main.c        **** 	UNCHANGED	Preserve EEPROM memory through the Chip Erase cycle;	[ EESAVE=0 ]
  61:main.c        **** 	UNCHANGED	Watch-dog Timer always on; 								[ WDTON = 0 ]
  62:main.c        **** 	UNCHANGED	Serial program downloading (SPI) enabled; 				[ SPIEN = 0 ]
  63:main.c        **** 	UNCHANGED	Debug Wire enable; 										[ DWEN = 0 ]
  64:main.c        **** 	UNCHANGED	Reset Disabled (Enable PC6 as i/o pin); 				[ RSTDISBL = 0 ]
  65:main.c        **** 	CHANGED		Brown-out detection level at VCC = 2.7v					[ BODLEVEL = 101 ]
  66:main.c        **** 	
  67:main.c        **** 	AVRDUDE_FUSES = -U lfuse:w:0xff:m -U hfuse:w:0xd9:m -U efuse:w:0xfd:m
  68:main.c        ****  
  69:main.c        ****  ~~~~~~~~~~~~~~~~~~~~~******************** Fuse Settings ********************~~~~~~~~~~~~~~~~~~~~~~
  70:main.c        ****  */
  71:main.c        **** 
  72:main.c        **** 
  73:main.c        **** 
  74:main.c        **** 
  75:main.c        **** 
  76:main.c        **** //~~~~~~~~~~~~~~~~~~~~~~******************** Includes ********************~~~~~~~~~~~~~~~~~~~~~~~~~
  77:main.c        **** 
  78:main.c        **** #include <stdlib.h>
  79:main.c        **** #include <avr/io.h>
  80:main.c        **** #define __DELAY_BACKWARD_COMPATIBLE__	// To allow passing of variables into delay functions.
  81:main.c        **** #include <util/delay.h>
  82:main.c        **** #include <avr/interrupt.h>
  83:main.c        **** #include <avr/pgmspace.h>
  84:main.c        **** #include <avr/eeprom.h>
  85:main.c        **** #include <string.h>
  86:main.c        **** 
  87:main.c        **** #include "uart.h"
  88:main.c        **** #include "main.h"
  89:main.c        **** #include "ds18b20.h"
  90:main.c        **** #include "ds18b20.c"
  91:main.c        **** 
  92:main.c        **** //~~~~~~~~~~~~~~~~~~~~~~******************** Includes ********************~~~~~~~~~~~~~~~~~~~~~~~~~
  93:main.c        **** 
  94:main.c        **** 
  95:main.c        **** 
  96:main.c        **** 
  97:main.c        **** 
  98:main.c        **** //~~~~~~~~~~~~~~~~~~~~~******************** Definitions ********************~~~~~~~~~~~~~~~~~~~~~~~
  99:main.c        **** 
 100:main.c        **** #define SW_1 			PD2		// Generic pushbutton switch.
 101:main.c        **** #define SER				PD3		// Shift registers.
 102:main.c        **** #define SRCLK			PD4		// Shift registers.
 103:main.c        **** #define RCLK			PD5		// Shift registers.
 104:main.c        **** #define F_BOOST			PD6		// Boost converter drive signal.
 105:main.c        **** #define LED 			PD7		// An LED for indication.
 106:main.c        **** 
 107:main.c        **** 
 108:main.c        **** 
 109:main.c        **** #define	AC_FREQ			PB0
 110:main.c        **** 
 111:main.c        **** // Analog inputs.
 112:main.c        **** #define PWR_OK			PC0		// adc_raw[0]
 113:main.c        **** #define HV_FEEDBACK		PC1		// adc_raw[1]
 114:main.c        **** #define BATT_VOLTAGE 	PC2		// adc_raw[2]
 115:main.c        **** #define	RECTIFIED_AC	PC3		// adc_raw[3]
 116:main.c        **** 
 117:main.c        **** #define TEMPERATURE_ARRAY_SIZE  6
 118:main.c        **** 
 119:main.c        **** #define UART_BAUD_RATE  57600
 120:main.c        **** 
 121:main.c        **** #define STRING_LENGTH   100		// UART parsing.
 122:main.c        **** #define CHAR_NEWLINE    '\n'
 123:main.c        **** #define CHAR_RETURN     '\r'
 124:main.c        **** #define RETURN_NEWLINE  "\r\n"
 125:main.c        **** 
 126:main.c        **** #define FIRST_ADC_INPUT 0		// lowest ADC channel to sample
 127:main.c        **** #define ADC_CHANNELS 	4		// number of ADC channels to sample
 128:main.c        **** #define ADC_VREF_TYPE 	64		// AVCC with external capacitor at AREF pin
 129:main.c        **** 
 130:main.c        **** #define AC_FRQ_FILT_SEC	60		// Number of seconds to collect zero crossings.  These zero crossings
 131:main.c        **** 								// will then be averaged anc computed to a frequency stored in acFrequency.
 132:main.c        **** 								
 133:main.c        **** #define AC_HERTZ		60		// number of AC cycles per second.  60 Hz (typ) North America, 50 Hz (typ) Eu
 134:main.c        **** 
 135:main.c        **** //~~~~~~~~~~~~~~~~~~~~~******************** Definitions ********************~~~~~~~~~~~~~~~~~~~~~~~
 136:main.c        **** 
 137:main.c        **** 
 138:main.c        **** 
 139:main.c        **** 
 140:main.c        **** 
 141:main.c        **** //~~~~~~~~~~~~~~~~~~~******************** Global Variables ********************~~~~~~~~~~~~~~~~~~~~
 142:main.c        **** 
 143:main.c        **** const int SERIAL_NUMBER = 100;  	// Start at 100.
 144:main.c        **** 
 145:main.c        **** 
 146:main.c        **** uint8_t uartStringIndex = 0; 
 147:main.c        **** unsigned char uartString[STRING_LENGTH];
 148:main.c        **** 
 149:main.c        **** char myUartString[STRING_LENGTH];   // A working copy of uartString.
 150:main.c        **** 
 151:main.c        **** char printBuffer[ 100 ];            // For UART print
 152:main.c        **** 
 153:main.c        **** uint16_t serialInInteger = 0;       // The parsed value of an serial input command.
 154:main.c        **** 
 155:main.c        **** uint8_t hours   = 10;				// these keep track of the current date and time.
 156:main.c        **** uint8_t minutes = 10;
 157:main.c        **** uint8_t day     = 1;
 158:main.c        **** uint8_t month   = 2;
 159:main.c        **** uint16_t year   = 2015;
 160:main.c        **** volatile uint8_t seconds = 30;
 161:main.c        **** 
 162:main.c        **** volatile uint32_t mscal = 0;	// F_CPU / (F_CPU * PPM_ERROR); if mscal == 0, disable adjustment
 163:main.c        **** uint32_t EEMEM ee_mscal = 0;	// For storing to eeprom.
 164:main.c        **** 
 165:main.c        **** 
 166:main.c        **** uint8_t prevSeconds = 0;		// For firing a function every x seconds.
 167:main.c        **** uint8_t prevMinutes = 0;		// For firing a function every x minutes.
 168:main.c        **** 
 169:main.c        **** uint8_t miltime = 1;        			// '1' to display 24-hour format, '0' to display 12-hour format
 170:main.c        **** uint8_t EEMEM ee_miltime = 1;			// for storing miltime to eeprom.
 171:main.c        **** uint8_t showtherm = 0;      			// '1' to display the temperature, '0' to have no temperature displa
 172:main.c        **** uint8_t EEMEM ee_showtherm = 0;			// For eeprom storage.
 173:main.c        **** uint8_t showfreq = 0;      				// '1' to display the AC line frequency, '0' to have no frequency di
 174:main.c        **** uint8_t EEMEM ee_showfreq = 0;			// For eeprom storage.
 175:main.c        **** uint8_t showdate = 0;					// '1' to show the date on the nixies every so often.  '0' to disable.
 176:main.c        **** uint8_t EEMEM ee_showdate = 0;			// For eeprom storage.
 177:main.c        **** uint8_t celsius = 1;        			// '1' to display temperature on the celsius scale, '0' for fahrenhe
 178:main.c        **** uint8_t EEMEM ee_celsius = 1;			// For eeprom storage.
 179:main.c        **** uint8_t doecho = 1;        				// '1' to echo back on the UART
 180:main.c        **** uint8_t EEMEM ee_doecho = 1;			// For eeprom storage.
 181:main.c        **** volatile uint8_t acclock = 1;       	// '1' to use the AC power line frequency as a timebase.  '0' 
 182:main.c        **** uint8_t EEMEM ee_acclock = 1;			// For eeprom storage.
 183:main.c        **** uint8_t xtalisfast = 1;     			// '1' if the crystal is running faster than "real time", 0 if slowe
 184:main.c        **** uint8_t EEMEM ee_xtalisfast = 1;		// For eeprom Storage.
 185:main.c        **** uint8_t toggleled = 1;     				// '1' to toggle the onboard LED at 1 Hz. "0" for LED OFF
 186:main.c        **** uint8_t EEMEM ee_toggleled = 1;			// For eeprom Storage.
 187:main.c        **** 
 188:main.c        **** uint32_t nixiesleepstart = 0;			// Value for shutting down the display on weekday nights.  24 hour 
 189:main.c        **** 										// Setting to 0 disables the feature.  A value of 1300 means 1:00 PM
 190:main.c        **** uint32_t EEMEM ee_nixiesleepstart = 0;	// For eeprom storage.
 191:main.c        **** uint32_t nixiesleepend = 0;				// This sets the time to turn on the nixies after being off since ni
 192:main.c        **** 										// The same 24 hr, no colon time format applies.  
 193:main.c        **** 										// Does not verify that the end time is after the start time.  You do.
 194:main.c        **** uint32_t EEMEM ee_nixiesleepend = 0;	// Storing to eeprom.
 195:main.c        **** 
 196:main.c        **** 
 197:main.c        **** double celsiusTemperature = 99.0;    		// The temperature read from the DS18b20 in celsius
 198:main.c        **** double averageCelsiusTemperature = 99.0;	// FIR filter for temperature.
 199:main.c        **** double arraySum = 0;						// FIR filter for temperature.
 200:main.c        **** 
 201:main.c        **** double movingAverageArray[ TEMPERATURE_ARRAY_SIZE ];
 202:main.c        **** 
 203:main.c        **** volatile uint8_t boostConverterPwm = 0;		// Current PWM value for the boost converter.
 204:main.c        **** volatile uint8_t boostHighPwm = 80;			// High PWM value for the boost converter.
 205:main.c        **** volatile uint8_t boostLowPwm = 30;			// Low PWM value for the boost converter.
 206:main.c        **** 
 207:main.c        **** volatile uint8_t adc_raw[ADC_CHANNELS];		// For storing the raw ADC counts of conversions.
 208:main.c        **** 
 209:main.c        **** volatile uint16_t acZeroCrossCounter = 0;	// For calculating the AC power line frequency.
 210:main.c        **** volatile uint16_t acZeroCrossSnapshot = 0;	// For evaluating the contents at a specific time point.
 211:main.c        **** volatile double acFrequency = 0.0;			// For calculating the AC power line frequency.
 212:main.c        **** volatile uint8_t acFreqFlag = 0;			// When set to "1" the contents of acFrequency contain the 
 213:main.c        **** 											// total number of zero crossings since the last measure.
 214:main.c        **** 
 215:main.c        **** uint8_t cathodePoisonFlag = 0;				// Flag to tell the app to run the anti-poison routine.
 216:main.c        **** 
 217:main.c        **** //~~~~~~~~~~~~~~~~~~~******************** Global Variables ********************~~~~~~~~~~~~~~~~~~~~
 218:main.c        **** 
 219:main.c        **** 
 220:main.c        **** 
 221:main.c        **** 
 222:main.c        **** //~~~~~~~~~~~~~~~~~~~~~~~~~******************** MAIN ********************~~~~~~~~~~~~~~~~~~~~~~~~~~
 223:main.c        **** 
 224:main.c        **** int main(void)
 225:main.c        **** {
 226:main.c        ****     cli();
 227:main.c        ****     ioInit();
 228:main.c        ****     adcInit();
 229:main.c        ****     boostConverterInit();
 230:main.c        ****     rtcInit();
 231:main.c        ****     uartInit();
 232:main.c        ****     extInterruptInit();
 233:main.c        ****     readEepromToVars();  
 234:main.c        ****     sei();
 235:main.c        ****     
 236:main.c        ****     uartWelcome();
 237:main.c        **** 
 238:main.c        **** 
 239:main.c        ****     while( 1 )
 240:main.c        ****     {
 241:main.c        ****     	
 242:main.c        ****     	updateAcFrequency();			// Every AC_FRQ_FILT_SEC seconds, compute the average.
 243:main.c        ****     	updateTemperatureFilter( 20 );	// FIR averaging filter for the DS18b20.
 244:main.c        ****         updateNixieOutputState();		// Turns ON or OFF the nixie tubes based on input power and slee
 245:main.c        ****       	checkSerialIn();				// Is there new serial data available?
 246:main.c        **** 		updateDateTime();				// Keep track of the current date and time.
 247:main.c        ****       
 248:main.c        ****         // If the time has changed, update the display.
 249:main.c        ****         if( seconds != prevSeconds)
 250:main.c        ****         {
 251:main.c        ****             nixiePrintTime( 1 );	// Display the current time on the nixie tubes and toggle the deci
 252:main.c        ****             prevSeconds = seconds;
 253:main.c        ****             
 254:main.c        ****         }
 255:main.c        **** 
 256:main.c        **** 
 257:main.c        ****         if( minutes != prevMinutes)
 258:main.c        ****         {
 259:main.c        ****         	cathodePoisonFlag = 1;		// Set every minute.  Cleared in checkCathodePoison(). 
 260:main.c        ****             
 261:main.c        ****             serialPrintDateTime();
 262:main.c        ****             serialPrintTemperature();
 263:main.c        ****             serialPrintAcFrequency();
 264:main.c        ****             uart_puts(RETURN_NEWLINE);
 265:main.c        **** 
 266:main.c        ****             
 267:main.c        ****             // On the nixie.
 268:main.c        ****             if( showdate ){
 269:main.c        ****             	nixiePrintDate();
 270:main.c        ****             	_delay_ms( 5000 );
 271:main.c        ****             }
 272:main.c        ****             
 273:main.c        ****             // On the nixie.
 274:main.c        ****            	if( showtherm ){
 275:main.c        ****            		nixiePrintTemperature();
 276:main.c        ****            		_delay_ms( 5000 );
 277:main.c        ****            	}
 278:main.c        ****            	
 279:main.c        ****            	// On the nixie.
 280:main.c        ****            	if( showfreq ){
 281:main.c        ****            		nixiePrintAcFrequency();
 282:main.c        ****            		_delay_ms( 5000 );
 283:main.c        ****            	}
 284:main.c        ****            
 285:main.c        ****             prevMinutes = minutes;   
 286:main.c        ****         }
 287:main.c        ****         
 288:main.c        ****         checkCathodePoison();			// do the antipoison routine if ready.
 289:main.c        ****         
 290:main.c        ****     }
 291:main.c        **** }
 292:main.c        **** //~~~~~~~~~~~~~~~~~~~~~~~~~******************** MAIN ********************~~~~~~~~~~~~~~~~~~~~~~~~~~
 293:main.c        **** 
 294:main.c        **** 
 295:main.c        **** 
 296:main.c        **** 
 297:main.c        **** void ioInit(void)
 298:main.c        **** {
 516               		.loc 3 298 0
 517               		.cfi_startproc
 518               	/* prologue: function */
 519               	/* frame size = 0 */
 520               	/* stack size = 0 */
 521               	.L__stack_usage = 0
 299:main.c        ****     //~~~~~~~~~~~~~~~~~~******************** Pin Configuration ********************~~~~~~~~~~~~~~~~
 300:main.c        ****     
 301:main.c        ****     // outputs
 302:main.c        ****     
 303:main.c        ****     DDRD |= ( ( 1 << SW_1 ) | ( 1 << SER ) | ( 1 << SRCLK ) | ( 1 << RCLK ) | ( 1 << F_BOOST ) | ( 
 522               		.loc 3 303 0
 523 0154 8AB1      		in r24,0xa
 524 0156 8C6F      		ori r24,lo8(-4)
 525 0158 8AB9      		out 0xa,r24
 304:main.c        ****     PORTD &= ~( ( 1 << SW_1 ) | ( 1 << SER ) | ( 1 << SRCLK ) | ( 1 << RCLK ) |( 1 << F_BOOST ) | (
 526               		.loc 3 304 0
 527 015a 8BB1      		in r24,0xb
 528 015c 8370      		andi r24,lo8(3)
 529 015e 8BB9      		out 0xb,r24
 305:main.c        ****     
 306:main.c        ****     
 307:main.c        ****     // inputs
 308:main.c        ****     
 309:main.c        ****     DDRD &= ~( 1 << SW_1 );	// set pin to 0 for input
 530               		.loc 3 309 0
 531 0160 5298      		cbi 0xa,2
 310:main.c        ****     PORTD |= ( 1 << SW_1 );	// enable internal pullup
 532               		.loc 3 310 0
 533 0162 5A9A      		sbi 0xb,2
 311:main.c        ****     
 312:main.c        ****     DDRB &= ~( 1 << AC_FREQ );	// set pin to 0 for input
 534               		.loc 3 312 0
 535 0164 2098      		cbi 0x4,0
 313:main.c        ****     PORTB |= ( 1 << AC_FREQ );	// enable internal pullup
 536               		.loc 3 313 0
 537 0166 289A      		sbi 0x5,0
 314:main.c        ****     
 315:main.c        ****     DDRC &= ~( ( 1 << PWR_OK ) | ( 1 << HV_FEEDBACK ) | ( 1 << BATT_VOLTAGE ) | ( 1 << RECTIFIED_AC
 538               		.loc 3 315 0
 539 0168 87B1      		in r24,0x7
 540 016a 807F      		andi r24,lo8(-16)
 541 016c 87B9      		out 0x7,r24
 542 016e 0895      		ret
 543               		.cfi_endproc
 544               	.LFE14:
 546               	.global	extInterruptInit
 548               	extInterruptInit:
 549               	.LFB15:
 316:main.c        ****     
 317:main.c        ****     //~~~~~~~~~~~~~~~~~~******************** Pin Configuration ********************~~~~~~~~~~~~~~~~
 318:main.c        **** }
 319:main.c        **** 
 320:main.c        **** 
 321:main.c        **** 
 322:main.c        **** 
 323:main.c        **** 
 324:main.c        **** void extInterruptInit( void )
 325:main.c        **** {
 550               		.loc 3 325 0
 551               		.cfi_startproc
 552               	/* prologue: function */
 553               	/* frame size = 0 */
 554               	/* stack size = 0 */
 555               	.L__stack_usage = 0
 326:main.c        **** 	//~~~~~~~~~~~~~~~~~~************** External Interrupt Configuration ************~~~~~~~~~~~~~~~~~~
 327:main.c        **** 
 328:main.c        ****     PCICR = 0x01; 	// Allow pin change interrupts.
 556               		.loc 3 328 0
 557 0170 81E0      		ldi r24,lo8(1)
 558 0172 8093 6800 		sts 104,r24
 329:main.c        ****     PCMSK0 = 0x01; 	// Enable interrupts specifically for pin PCINT0 
 559               		.loc 3 329 0
 560 0176 8093 6B00 		sts 107,r24
 561 017a 0895      		ret
 562               		.cfi_endproc
 563               	.LFE15:
 565               	.global	rtcInit
 567               	rtcInit:
 568               	.LFB16:
 330:main.c        ****     
 331:main.c        ****     //~~~~~~~~~~~~~~~~~~************** External Interrupt Configuration ************~~~~~~~~~~~~~~~
 332:main.c        **** }
 333:main.c        **** 
 334:main.c        **** 
 335:main.c        **** 
 336:main.c        **** 
 337:main.c        **** 
 338:main.c        **** void rtcInit( void )
 339:main.c        **** {
 569               		.loc 3 339 0
 570               		.cfi_startproc
 571               	/* prologue: function */
 572               	/* frame size = 0 */
 573               	/* stack size = 0 */
 574               	.L__stack_usage = 0
 340:main.c        **** 	//~~~~~~~~~~~~~~~~~~***************** RTC Timer Configuration *****************~~~~~~~~~~~~~~~~~~~
 341:main.c        **** 
 342:main.c        ****     OCR1AH = 0;                 // Interrupt at 1.000 kHz, 0.001 S.
 575               		.loc 3 342 0
 576 017c 1092 8900 		sts 137,__zero_reg__
 343:main.c        ****     OCR1AL = 63;                // Decimal 63, one less than 64000/1000 because 0 and top are count
 577               		.loc 3 343 0
 578 0180 8FE3      		ldi r24,lo8(63)
 579 0182 8093 8800 		sts 136,r24
 344:main.c        ****     TIMSK1 |= ( 1 << OCIE1A );  // enable OCR1A match interrupt
 580               		.loc 3 344 0
 581 0186 EFE6      		ldi r30,lo8(111)
 582 0188 F0E0      		ldi r31,0
 583 018a 8081      		ld r24,Z
 584 018c 8260      		ori r24,lo8(2)
 585 018e 8083      		st Z,r24
 345:main.c        ****     TCCR1B |= (( 1 << WGM12 ) | ( 1 << CS12 ));	// start timer, CTC mode OCR1A match, ck/div by 256
 586               		.loc 3 345 0
 587 0190 E1E8      		ldi r30,lo8(-127)
 588 0192 F0E0      		ldi r31,0
 589 0194 8081      		ld r24,Z
 590 0196 8C60      		ori r24,lo8(12)
 591 0198 8083      		st Z,r24
 592 019a 0895      		ret
 593               		.cfi_endproc
 594               	.LFE16:
 596               	.global	adcInit
 598               	adcInit:
 599               	.LFB17:
 346:main.c        ****     
 347:main.c        ****     //~~~~~~~~~~~~~~~~~~***************** RTC Timer Configuration *****************~~~~~~~~~~~~~~~~
 348:main.c        **** }
 349:main.c        **** 
 350:main.c        **** 
 351:main.c        **** 
 352:main.c        **** 
 353:main.c        **** 
 354:main.c        **** void adcInit( void )
 355:main.c        **** {
 600               		.loc 3 355 0
 601               		.cfi_startproc
 602               	/* prologue: function */
 603               	/* frame size = 0 */
 604               	/* stack size = 0 */
 605               	.L__stack_usage = 0
 356:main.c        **** 	//~~~~~~~~~~~~~~~~~~******************** ADC Configuration ********************~~~~~~~~~~~~~~~~~~~
 357:main.c        **** 
 358:main.c        ****   	// ADC clock prescale of 1/128 for 128 kHz
 359:main.c        ****   	ADCSRA = ( ( 1 << ADEN ) | ( 1 << ADATE ) | ( 1 << ADIE ) | ( 1 << ADPS2 ) | ( 1 << ADPS1 ) | ( 
 606               		.loc 3 359 0
 607 019c 8FEA      		ldi r24,lo8(-81)
 608 019e 8093 7A00 		sts 122,r24
 360:main.c        ****   	
 361:main.c        ****   	ADCSRB |= (1<<ADTS2);
 609               		.loc 3 361 0
 610 01a2 EBE7      		ldi r30,lo8(123)
 611 01a4 F0E0      		ldi r31,0
 612 01a6 8081      		ld r24,Z
 613 01a8 8460      		ori r24,lo8(4)
 614 01aa 8083      		st Z,r24
 362:main.c        ****   	
 363:main.c        ****   	// Disable digital input buffers to save power.
 364:main.c        ****   	DIDR0 = ( ( 1 << ADC0D ) | ( 1 << ADC1D ) | ( 1 << ADC2D ) | ( 1 << ADC3D ) );
 615               		.loc 3 364 0
 616 01ac 8FE0      		ldi r24,lo8(15)
 617 01ae 8093 7E00 		sts 126,r24
 618 01b2 0895      		ret
 619               		.cfi_endproc
 620               	.LFE17:
 622               	.global	boostConverterInit
 624               	boostConverterInit:
 625               	.LFB18:
 365:main.c        **** 
 366:main.c        ****     //~~~~~~~~~~~~~~~~~~******************** ADC Configuration ********************~~~~~~~~~~~~~~~~
 367:main.c        **** }
 368:main.c        **** 
 369:main.c        **** 
 370:main.c        **** 
 371:main.c        **** 
 372:main.c        **** void boostConverterInit( void )
 373:main.c        **** {
 626               		.loc 3 373 0
 627               		.cfi_startproc
 628               	/* prologue: function */
 629               	/* frame size = 0 */
 630               	/* stack size = 0 */
 631               	.L__stack_usage = 0
 374:main.c        **** 	//~~~~~~~~~~~~~~~~~~************** Boost Converter Configuration **************~~~~~~~~~~~~~~~~~~~
 375:main.c        **** 
 376:main.c        **** 	// PWM Frequency: 64 kHz
 377:main.c        **** 	
 378:main.c        **** 	// Timer/Counter0: channel: A, clear on compare match ( non-inverting ), Fast PWM, TOP = 0xFF
 379:main.c        **** 	TCCR0A |= ((1<<COM0A1) | (1<<WGM01) | (1<<WGM00));
 632               		.loc 3 379 0
 633 01b4 84B5      		in r24,0x24
 634 01b6 8368      		ori r24,lo8(-125)
 635 01b8 84BD      		out 0x24,r24
 380:main.c        **** 	TCCR0B |= ( 1 << CS00 );	// internal clock as source, no prescale, start the timer
 636               		.loc 3 380 0
 637 01ba 85B5      		in r24,0x25
 638 01bc 8160      		ori r24,lo8(1)
 639 01be 85BD      		out 0x25,r24
 640 01c0 0895      		ret
 641               		.cfi_endproc
 642               	.LFE18:
 644               	.global	__vector_21
 646               	__vector_21:
 647               	.LFB19:
 381:main.c        **** 
 382:main.c        ****     //~~~~~~~~~~~~~~~~~~************** Boost Converter Configuration **************~~~~~~~~~~~~~~~~
 383:main.c        **** }
 384:main.c        **** 
 385:main.c        **** 
 386:main.c        **** 
 387:main.c        **** 
 388:main.c        **** 
 389:main.c        **** //~~~~~~~~~~~~~~~~~~~~~~******************** Functions ********************~~~~~~~~~~~~~~~~~~~~~~~~
 390:main.c        **** 
 391:main.c        **** // ADC interrupt service routine.
 392:main.c        **** // This is called at the completion of each ADC read cycle.
 393:main.c        **** // At the end of the ISR, the next conversion is started and we exit.
 394:main.c        **** // When that conversion is complete, this function is called again.
 395:main.c        **** ISR(ADC_vect) 
 396:main.c        **** {
 648               		.loc 3 396 0
 649               		.cfi_startproc
 650 01c2 1F92      		push r1
 651               	.LCFI11:
 652               		.cfi_def_cfa_offset 3
 653               		.cfi_offset 1, -2
 654 01c4 0F92      		push r0
 655               	.LCFI12:
 656               		.cfi_def_cfa_offset 4
 657               		.cfi_offset 0, -3
 658 01c6 0FB6      		in r0,__SREG__
 659 01c8 0F92      		push r0
 660 01ca 1124      		clr __zero_reg__
 661 01cc 8F93      		push r24
 662               	.LCFI13:
 663               		.cfi_def_cfa_offset 5
 664               		.cfi_offset 24, -4
 665 01ce 9F93      		push r25
 666               	.LCFI14:
 667               		.cfi_def_cfa_offset 6
 668               		.cfi_offset 25, -5
 669 01d0 EF93      		push r30
 670               	.LCFI15:
 671               		.cfi_def_cfa_offset 7
 672               		.cfi_offset 30, -6
 673 01d2 FF93      		push r31
 674               	.LCFI16:
 675               		.cfi_def_cfa_offset 8
 676               		.cfi_offset 31, -7
 677               	/* prologue: Signal */
 678               	/* frame size = 0 */
 679               	/* stack size = 7 */
 680               	.L__stack_usage = 7
 397:main.c        **** static unsigned char input_index=0;
 398:main.c        **** 
 399:main.c        **** // Read the AD conversion result
 400:main.c        ****    adc_raw[input_index]=ADCH;
 681               		.loc 3 400 0
 682 01d4 8091 0000 		lds r24,input_index.2181
 683 01d8 E82F      		mov r30,r24
 684 01da F0E0      		ldi r31,0
 685 01dc 9091 7900 		lds r25,121
 686 01e0 E050      		subi r30,lo8(-(adc_raw))
 687 01e2 F040      		sbci r31,hi8(-(adc_raw))
 688 01e4 9083      		st Z,r25
 401:main.c        ****    
 402:main.c        **** // Select next ADC input
 403:main.c        ****    if (++input_index >= ADC_CHANNELS)
 689               		.loc 3 403 0
 690 01e6 8F5F      		subi r24,lo8(-(1))
 691 01e8 8430      		cpi r24,lo8(4)
 692 01ea 00F4      		brsh .L26
 693 01ec 8093 0000 		sts input_index.2181,r24
 694 01f0 00C0      		rjmp .L27
 695               	.L26:
 404:main.c        ****       {
 405:main.c        ****       input_index=0;
 696               		.loc 3 405 0
 697 01f2 1092 0000 		sts input_index.2181,__zero_reg__
 698               	.L27:
 406:main.c        ****       }
 407:main.c        **** 
 408:main.c        ****    ADMUX=(FIRST_ADC_INPUT | ADC_VREF_TYPE | ( 1 << ADLAR ) ) + input_index; //and left adjust
 699               		.loc 3 408 0
 700 01f6 8091 0000 		lds r24,input_index.2181
 701 01fa 805A      		subi r24,lo8(-(96))
 702 01fc 8093 7C00 		sts 124,r24
 409:main.c        **** 
 410:main.c        **** // Start the AD conversion
 411:main.c        ****    ADCSRA |= (1<<ADSC);
 703               		.loc 3 411 0
 704 0200 8091 7A00 		lds r24,122
 705 0204 8064      		ori r24,lo8(64)
 706 0206 8093 7A00 		sts 122,r24
 707               	/* epilogue start */
 412:main.c        **** 
 413:main.c        **** } 
 708               		.loc 3 413 0
 709 020a FF91      		pop r31
 710 020c EF91      		pop r30
 711 020e 9F91      		pop r25
 712 0210 8F91      		pop r24
 713 0212 0F90      		pop r0
 714 0214 0FBE      		out __SREG__,r0
 715 0216 0F90      		pop r0
 716 0218 1F90      		pop r1
 717 021a 1895      		reti
 718               		.cfi_endproc
 719               	.LFE19:
 721               	.global	__vector_3
 723               	__vector_3:
 724               	.LFB20:
 414:main.c        **** 
 415:main.c        **** 
 416:main.c        **** 
 417:main.c        **** // External interrupt connected to the AC optocoupler.
 418:main.c        **** // Interrupt triggers on rising and falling edges, so double your AC_HERTZ.
 419:main.c        **** // This function will only be called so long as there is an AC input waveform.
 420:main.c        **** // For that reason, we do not need to code for when we lose AC power.  We just have
 421:main.c        **** // to say, if this function is called and we want to use the AC frequency as a timebase
 422:main.c        **** // then increment our seconds.  In ISR( TIMER1_COMPA_vect ) we have to have a bit more logic.
 423:main.c        **** ISR (PCINT0_vect)
 424:main.c        **** {
 725               		.loc 3 424 0
 726               		.cfi_startproc
 727 021c 1F92      		push r1
 728               	.LCFI17:
 729               		.cfi_def_cfa_offset 3
 730               		.cfi_offset 1, -2
 731 021e 0F92      		push r0
 732               	.LCFI18:
 733               		.cfi_def_cfa_offset 4
 734               		.cfi_offset 0, -3
 735 0220 0FB6      		in r0,__SREG__
 736 0222 0F92      		push r0
 737 0224 1124      		clr __zero_reg__
 738 0226 8F93      		push r24
 739               	.LCFI19:
 740               		.cfi_def_cfa_offset 5
 741               		.cfi_offset 24, -4
 742 0228 9F93      		push r25
 743               	.LCFI20:
 744               		.cfi_def_cfa_offset 6
 745               		.cfi_offset 25, -5
 746               	/* prologue: Signal */
 747               	/* frame size = 0 */
 748               	/* stack size = 5 */
 749               	.L__stack_usage = 5
 425:main.c        **** 	static uint8_t timebaseCounter = 0;		// For timekeeping
 426:main.c        **** 	
 427:main.c        **** 	timebaseCounter++;	// Counting AC cycles.
 750               		.loc 3 427 0
 751 022a 8091 0000 		lds r24,timebaseCounter.2187
 752 022e 8F5F      		subi r24,lo8(-(1))
 753 0230 8093 0000 		sts timebaseCounter.2187,r24
 428:main.c        **** 	
 429:main.c        **** 	if( acclock == 1 ){
 754               		.loc 3 429 0
 755 0234 9091 0000 		lds r25,acclock
 756 0238 9130      		cpi r25,lo8(1)
 757 023a 01F4      		brne .L29
 430:main.c        **** 	
 431:main.c        **** 		if( timebaseCounter > ( AC_HERTZ * 2 ) - 1 ){
 758               		.loc 3 431 0
 759 023c 8837      		cpi r24,lo8(120)
 760 023e 00F0      		brlo .L29
 432:main.c        **** 		
 433:main.c        **** 			seconds++;	// Increment the main seconds counter.
 761               		.loc 3 433 0
 762 0240 8091 0000 		lds r24,seconds
 763 0244 8F5F      		subi r24,lo8(-(1))
 764 0246 8093 0000 		sts seconds,r24
 434:main.c        **** 			
 435:main.c        **** 			timebaseCounter = 0;
 765               		.loc 3 435 0
 766 024a 1092 0000 		sts timebaseCounter.2187,__zero_reg__
 767               	.L29:
 436:main.c        **** 		}
 437:main.c        **** 		
 438:main.c        **** 	}
 439:main.c        **** 	
 440:main.c        **** 	acZeroCrossCounter++;	// For measuring the AC frequency - not used for timekeeping
 768               		.loc 3 440 0
 769 024e 8091 0000 		lds r24,acZeroCrossCounter
 770 0252 9091 0000 		lds r25,acZeroCrossCounter+1
 771 0256 0196      		adiw r24,1
 772 0258 9093 0000 		sts acZeroCrossCounter+1,r25
 773 025c 8093 0000 		sts acZeroCrossCounter,r24
 774               	/* epilogue start */
 441:main.c        **** 	
 442:main.c        **** }
 775               		.loc 3 442 0
 776 0260 9F91      		pop r25
 777 0262 8F91      		pop r24
 778 0264 0F90      		pop r0
 779 0266 0FBE      		out __SREG__,r0
 780 0268 0F90      		pop r0
 781 026a 1F90      		pop r1
 782 026c 1895      		reti
 783               		.cfi_endproc
 784               	.LFE20:
 786               	.global	toggle_led
 788               	toggle_led:
 789               	.LFB21:
 443:main.c        **** 
 444:main.c        **** 
 445:main.c        **** 
 446:main.c        **** 
 447:main.c        **** 
 448:main.c        **** void toggle_led()
 449:main.c        **** {
 790               		.loc 3 449 0
 791               		.cfi_startproc
 792               	/* prologue: function */
 793               	/* frame size = 0 */
 794               	/* stack size = 0 */
 795               	.L__stack_usage = 0
 450:main.c        ****     PORTD ^= ( 1 << LED );
 796               		.loc 3 450 0
 797 026e 8BB1      		in r24,0xb
 798 0270 8058      		subi r24,lo8(-(-128))
 799 0272 8BB9      		out 0xb,r24
 800 0274 0895      		ret
 801               		.cfi_endproc
 802               	.LFE21:
 804               	.global	blip_led
 806               	blip_led:
 807               	.LFB22:
 451:main.c        **** }
 452:main.c        **** 
 453:main.c        **** 
 454:main.c        **** 
 455:main.c        **** 
 456:main.c        **** 
 457:main.c        **** void blip_led()
 458:main.c        **** {
 808               		.loc 3 458 0
 809               		.cfi_startproc
 810               	/* prologue: function */
 811               	/* frame size = 0 */
 812               	/* stack size = 0 */
 813               	.L__stack_usage = 0
 459:main.c        ****     PORTD |= ( 1 << LED );	// on
 814               		.loc 3 459 0
 815 0276 5F9A      		sbi 0xb,7
 816               	.LVL56:
 817               	.LBB215:
 818               	.LBB216:
 819               	.LBB217:
 820               	.LBB218:
 821               		.loc 2 105 0
 822 0278 80E0      		ldi r24,0
 823 027a 90E3      		ldi r25,lo8(48)
 824               	/* #APP */
 825               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 826 027c 0197      		1: sbiw r24,1
 827 027e 01F4      		brne 1b
 828               	 ;  0 "" 2
 829               	.LVL57:
 830               	/* #NOAPP */
 831               	.LBE218:
 832               	.LBE217:
 833               	.LBE216:
 834               	.LBE215:
 460:main.c        ****     _delay_ms(3);
 461:main.c        ****     PORTD &= ~( 1 << LED );	// off
 835               		.loc 3 461 0
 836 0280 5F98      		cbi 0xb,7
 837 0282 0895      		ret
 838               		.cfi_endproc
 839               	.LFE22:
 841               	.global	is_switch_pressed
 843               	is_switch_pressed:
 844               	.LFB23:
 462:main.c        **** }
 463:main.c        **** 
 464:main.c        **** 
 465:main.c        **** 
 466:main.c        **** 
 467:main.c        **** 
 468:main.c        **** int is_switch_pressed( char port, char pin, int ms_debounce, int ms_block )
 469:main.c        **** {
 845               		.loc 3 469 0
 846               		.cfi_startproc
 847               	.LVL58:
 848               	/* prologue: function */
 849               	/* frame size = 0 */
 850               	/* stack size = 0 */
 851               	.L__stack_usage = 0
 470:main.c        ****     
 471:main.c        ****     if ( !( port & ( 1 << pin ) ) )
 852               		.loc 3 471 0
 853 0284 282F      		mov r18,r24
 854               	.LVL59:
 855 0286 30E0      		ldi r19,0
 856 0288 00C0      		rjmp 2f
 857               		1:
 858 028a 3595      		asr r19
 859 028c 2795      		ror r18
 860               		2:
 861 028e 6A95      		dec r22
 862 0290 02F4      		brpl 1b
 863 0292 2170      		andi r18,1
 864 0294 3327      		clr r19
 472:main.c        ****     {
 473:main.c        ****         //_delay_ms( ms_debounce );
 474:main.c        ****         if ( !( port & ( 1 << pin ) ) ) return 1;
 865               		.loc 3 474 0
 866 0296 81E0      		ldi r24,1
 867 0298 2827      		eor r18,r24
 868               	.LVL60:
 475:main.c        ****     }
 476:main.c        ****     
 477:main.c        ****     return 0;
 478:main.c        **** }
 869               		.loc 3 478 0
 870 029a C901      		movw r24,r18
 871 029c 0895      		ret
 872               		.cfi_endproc
 873               	.LFE23:
 875               	.global	splitString
 877               	splitString:
 878               	.LFB24:
 479:main.c        **** 
 480:main.c        **** 
 481:main.c        **** 
 482:main.c        **** 
 483:main.c        **** uint32_t splitString(char aString[100])
 484:main.c        **** {
 879               		.loc 3 484 0
 880               		.cfi_startproc
 881               	.LVL61:
 882 029e CF93      		push r28
 883               	.LCFI21:
 884               		.cfi_def_cfa_offset 3
 885               		.cfi_offset 28, -2
 886 02a0 DF93      		push r29
 887               	.LCFI22:
 888               		.cfi_def_cfa_offset 4
 889               		.cfi_offset 29, -3
 890 02a2 CDB7      		in r28,__SP_L__
 891 02a4 DEB7      		in r29,__SP_H__
 892               	.LCFI23:
 893               		.cfi_def_cfa_register 28
 894 02a6 C456      		subi r28,100
 895 02a8 D109      		sbc r29,__zero_reg__
 896               	.LCFI24:
 897               		.cfi_def_cfa_offset 104
 898 02aa 0FB6      		in __tmp_reg__,__SREG__
 899 02ac F894      		cli
 900 02ae DEBF      		out __SP_H__,r29
 901 02b0 0FBE      		out __SREG__,__tmp_reg__
 902 02b2 CDBF      		out __SP_L__,r28
 903               	/* prologue: function */
 904               	/* frame size = 100 */
 905               	/* stack size = 102 */
 906               	.L__stack_usage = 102
 485:main.c        ****     
 486:main.c        ****     char *splitChar;
 487:main.c        ****     char subString[100];
 488:main.c        ****     
 489:main.c        ****     // find the equal symbol.  Var to the left, value to the right
 490:main.c        ****     splitChar = strchr( aString, '=');
 907               		.loc 3 490 0
 908 02b4 6DE3      		ldi r22,lo8(61)
 909 02b6 70E0      		ldi r23,0
 910 02b8 0E94 0000 		call strchr
 911               	.LVL62:
 491:main.c        ****     
 492:main.c        ****     strcpy(subString, splitChar + 1);
 912               		.loc 3 492 0
 913 02bc BC01      		movw r22,r24
 914 02be 6F5F      		subi r22,-1
 915 02c0 7F4F      		sbci r23,-1
 916 02c2 CE01      		movw r24,r28
 917               	.LVL63:
 918 02c4 0196      		adiw r24,1
 919 02c6 0E94 0000 		call strcpy
 920               	.LVL64:
 493:main.c        ****     
 494:main.c        ****     return atol( subString );
 921               		.loc 3 494 0
 922 02ca CE01      		movw r24,r28
 923 02cc 0196      		adiw r24,1
 924 02ce 0E94 0000 		call atol
 925               	.LVL65:
 926               	/* epilogue start */
 495:main.c        **** }
 927               		.loc 3 495 0
 928 02d2 CC59      		subi r28,-100
 929 02d4 DF4F      		sbci r29,-1
 930 02d6 0FB6      		in __tmp_reg__,__SREG__
 931 02d8 F894      		cli
 932 02da DEBF      		out __SP_H__,r29
 933 02dc 0FBE      		out __SREG__,__tmp_reg__
 934 02de CDBF      		out __SP_L__,r28
 935 02e0 DF91      		pop r29
 936 02e2 CF91      		pop r28
 937 02e4 0895      		ret
 938               		.cfi_endproc
 939               	.LFE24:
 941               	.global	copy_command
 943               	copy_command:
 944               	.LFB25:
 496:main.c        **** 
 497:main.c        **** 
 498:main.c        **** 
 499:main.c        **** 
 500:main.c        **** void copy_command ()
 501:main.c        **** {
 945               		.loc 3 501 0
 946               		.cfi_startproc
 947               	/* prologue: function */
 948               	/* frame size = 0 */
 949               	/* stack size = 0 */
 950               	.L__stack_usage = 0
 502:main.c        ****     // Move a copy of uartString to myuartString
 503:main.c        ****     memmove(myUartString, uartString, sizeof( myUartString ) );
 951               		.loc 3 503 0
 952 02e6 84E6      		ldi r24,lo8(100)
 953 02e8 E0E0      		ldi r30,lo8(uartString)
 954 02ea F0E0      		ldi r31,hi8(uartString)
 955 02ec A0E0      		ldi r26,lo8(myUartString)
 956 02ee B0E0      		ldi r27,hi8(myUartString)
 957               		0:
 958 02f0 0190      		ld r0,Z+
 959 02f2 0D92      		st X+,r0
 960 02f4 8A95      		dec r24
 961 02f6 01F4      		brne 0b
 504:main.c        ****     // Empty the uartString.
 505:main.c        ****     memset(uartString, 0, sizeof( myUartString ) );
 962               		.loc 3 505 0
 963 02f8 84E6      		ldi r24,lo8(100)
 964 02fa E0E0      		ldi r30,lo8(uartString)
 965 02fc F0E0      		ldi r31,hi8(uartString)
 966 02fe DF01      		movw r26,r30
 967               		0:
 968 0300 1D92      		st X+,__zero_reg__
 969 0302 8A95      		dec r24
 970 0304 01F4      		brne 0b
 971 0306 0895      		ret
 972               		.cfi_endproc
 973               	.LFE25:
 975               	.global	inRange
 977               	inRange:
 978               	.LFB26:
 506:main.c        **** }
 507:main.c        **** 
 508:main.c        **** 
 509:main.c        **** 
 510:main.c        **** 
 511:main.c        **** uint8_t inRange( uint32_t inputValue, uint32_t upperBound, uint32_t lowerBound )
 512:main.c        **** {
 979               		.loc 3 512 0
 980               		.cfi_startproc
 981               	.LVL66:
 982 0308 EF92      		push r14
 983               	.LCFI25:
 984               		.cfi_def_cfa_offset 3
 985               		.cfi_offset 14, -2
 986 030a FF92      		push r15
 987               	.LCFI26:
 988               		.cfi_def_cfa_offset 4
 989               		.cfi_offset 15, -3
 990 030c 0F93      		push r16
 991               	.LCFI27:
 992               		.cfi_def_cfa_offset 5
 993               		.cfi_offset 16, -4
 994 030e 1F93      		push r17
 995               	.LCFI28:
 996               		.cfi_def_cfa_offset 6
 997               		.cfi_offset 17, -5
 998               	/* prologue: function */
 999               	/* frame size = 0 */
 1000               	/* stack size = 4 */
 1001               	.L__stack_usage = 4
 513:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 1002               		.loc 3 513 0
 1003 0310 6E15      		cp r22,r14
 1004 0312 7F05      		cpc r23,r15
 1005 0314 8007      		cpc r24,r16
 1006 0316 9107      		cpc r25,r17
 1007 0318 00F0      		brlo .L38
 1008               		.loc 3 513 0 is_stmt 0 discriminator 1
 1009 031a E1E0      		ldi r30,lo8(1)
 1010 031c 2617      		cp r18,r22
 1011 031e 3707      		cpc r19,r23
 1012 0320 4807      		cpc r20,r24
 1013 0322 5907      		cpc r21,r25
 1014 0324 00F4      		brsh .L36
 1015               	.L38:
 514:main.c        **** 	{
 515:main.c        **** 		return 1;
 516:main.c        **** 	}
 517:main.c        **** 	
 518:main.c        **** 	return 0;
 1016               		.loc 3 518 0 is_stmt 1
 1017 0326 E0E0      		ldi r30,0
 1018               	.L36:
 519:main.c        **** }
 1019               		.loc 3 519 0
 1020 0328 8E2F      		mov r24,r30
 1021               	/* epilogue start */
 1022 032a 1F91      		pop r17
 1023 032c 0F91      		pop r16
 1024 032e FF90      		pop r15
 1025 0330 EF90      		pop r14
 1026               	.LVL67:
 1027 0332 0895      		ret
 1028               		.cfi_endproc
 1029               	.LFE26:
 1031               		.section	.rodata.str1.1,"aMS",@progbits,1
 1032               	.LC1:
 1033 0000 3A20 00   		.string	": "
 1034               		.text
 1035               	.global	print_value
 1037               	print_value:
 1038               	.LFB28:
 520:main.c        **** 
 521:main.c        **** 
 522:main.c        **** 
 523:main.c        **** 
 524:main.c        **** 
 525:main.c        **** void process_command()
 526:main.c        **** {
 527:main.c        ****     if(strcasestr(myUartString,"hours") != NULL){
 528:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 529:main.c        ****             print_value("Hours", hours);
 530:main.c        ****         }else{
 531:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 532:main.c        ****         		if( inRange( splitString(myUartString), 23, 0 ) )
 533:main.c        ****             		hours = splitString(myUartString);
 534:main.c        ****             }
 535:main.c        ****         }
 536:main.c        ****     }
 537:main.c        ****     
 538:main.c        ****     else if(strcasestr(myUartString,"minutes") != NULL){
 539:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 540:main.c        ****             print_value("Minutes", minutes);
 541:main.c        ****         }else{
 542:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 543:main.c        ****         		if( inRange( splitString(myUartString), 59, 0 ) )
 544:main.c        ****             		minutes = splitString(myUartString);
 545:main.c        ****             }
 546:main.c        ****         }
 547:main.c        ****     }
 548:main.c        ****     
 549:main.c        ****     else if(strcasestr(myUartString,"seconds") != NULL){
 550:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 551:main.c        ****             print_value("Seconds", seconds);
 552:main.c        ****         }else{
 553:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 554:main.c        ****         		if( inRange( splitString(myUartString), 59, 0 ) )
 555:main.c        ****             		seconds = splitString(myUartString);
 556:main.c        ****             }
 557:main.c        ****         }
 558:main.c        ****     }
 559:main.c        ****     
 560:main.c        ****     else if(strcasestr(myUartString,"mscal") != NULL){
 561:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 562:main.c        ****             print_value("mS Calibration", mscal);
 563:main.c        ****         }else{
 564:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 565:main.c        ****         		if( inRange( splitString(myUartString), 4294967295, 0 ) )
 566:main.c        ****             		mscal = splitString(myUartString);
 567:main.c        ****             }
 568:main.c        ****         }
 569:main.c        ****     }
 570:main.c        ****     
 571:main.c        ****     else if(strcasestr(myUartString,"miltime") != NULL){
 572:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 573:main.c        ****             print_value("MIL Time", miltime);
 574:main.c        ****         }else{
 575:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 576:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 577:main.c        ****             		miltime = splitString(myUartString);
 578:main.c        ****             }
 579:main.c        ****         }
 580:main.c        ****     }
 581:main.c        ****     
 582:main.c        ****     else if(strcasestr(myUartString,"year") != NULL){
 583:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 584:main.c        ****             print_value("Year", year);
 585:main.c        ****         }else{
 586:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 587:main.c        ****         		if( inRange( splitString(myUartString), 2525, 0 ) )
 588:main.c        ****             		year = splitString(myUartString);
 589:main.c        ****             }
 590:main.c        ****         }
 591:main.c        ****     }
 592:main.c        ****     
 593:main.c        ****     else if(strcasestr(myUartString,"month") != NULL){
 594:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 595:main.c        ****             print_value("Month", month);
 596:main.c        ****         }else{
 597:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 598:main.c        ****         		if( inRange( splitString(myUartString), 12, 0 ) )
 599:main.c        ****             		month = splitString(myUartString);
 600:main.c        ****             }
 601:main.c        ****         }
 602:main.c        ****     }
 603:main.c        ****     
 604:main.c        ****     else if(strcasestr(myUartString,"day") != NULL){
 605:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 606:main.c        ****             print_value("Day", day);
 607:main.c        ****         }else{
 608:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 609:main.c        ****         		if( inRange( splitString(myUartString), 31, 0 ) )
 610:main.c        ****             		day = splitString(myUartString);
 611:main.c        ****             }
 612:main.c        ****         }
 613:main.c        ****     }
 614:main.c        ****     
 615:main.c        ****     else if(strcasestr(myUartString,"celsius") != NULL){
 616:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 617:main.c        ****             print_value("Celsius", celsius);
 618:main.c        ****         }else{
 619:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 620:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 621:main.c        ****             		celsius = splitString(myUartString);
 622:main.c        ****             }
 623:main.c        ****         }
 624:main.c        ****     }
 625:main.c        ****     
 626:main.c        ****     else if(strcasestr(myUartString,"doecho") != NULL){
 627:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 628:main.c        ****             print_value("Do Echo", doecho);
 629:main.c        ****         }else{
 630:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 631:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 632:main.c        ****             		doecho = splitString(myUartString);
 633:main.c        ****             }
 634:main.c        ****         }
 635:main.c        ****     }
 636:main.c        ****     
 637:main.c        ****     else if(strcasestr(myUartString,"acclock") != NULL){
 638:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 639:main.c        ****             print_value("AC Clock", acclock);
 640:main.c        ****         }else{
 641:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 642:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 643:main.c        ****             		acclock = splitString(myUartString);
 644:main.c        ****             }
 645:main.c        ****         }
 646:main.c        ****     }
 647:main.c        ****     
 648:main.c        ****     else if(strcasestr(myUartString,"xtalisfast") != NULL){
 649:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 650:main.c        ****             print_value("xtalisfast", xtalisfast);
 651:main.c        ****         }else{
 652:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 653:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 654:main.c        ****             		xtalisfast = splitString(myUartString);
 655:main.c        ****             }
 656:main.c        ****         }
 657:main.c        ****     }
 658:main.c        ****     
 659:main.c        **** 	else if(strcasestr(myUartString,"showtherm") != NULL){
 660:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 661:main.c        ****             print_value("Show Therm", showtherm);
 662:main.c        ****         }else{
 663:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 664:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 665:main.c        ****             		showtherm = splitString(myUartString);
 666:main.c        ****             }
 667:main.c        ****         }
 668:main.c        ****     }
 669:main.c        ****     
 670:main.c        ****     else if(strcasestr(myUartString,"showfreq") != NULL){
 671:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 672:main.c        ****             print_value("Show Freq", showfreq);
 673:main.c        ****         }else{
 674:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 675:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 676:main.c        ****             		showfreq = splitString(myUartString);
 677:main.c        ****             }
 678:main.c        ****         }
 679:main.c        ****     }
 680:main.c        **** 	
 681:main.c        **** 	else if(strcasestr(myUartString,"showdate") != NULL){
 682:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 683:main.c        ****             print_value("Show Date", showdate);
 684:main.c        ****         }else{
 685:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 686:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 687:main.c        ****             		showdate = splitString(myUartString);
 688:main.c        ****             }
 689:main.c        ****         }
 690:main.c        ****     }
 691:main.c        ****     
 692:main.c        ****     else if(strcasestr(myUartString,"toggleled")!= NULL){
 693:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 694:main.c        ****             print_value("Toggle LED", toggleled);
 695:main.c        ****         }else{
 696:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 697:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 698:main.c        ****             		toggleled = splitString(myUartString);
 699:main.c        ****             }
 700:main.c        ****         }
 701:main.c        ****     }
 702:main.c        ****     
 703:main.c        ****     else if(strcasestr(myUartString,"nixiesleepstart") != NULL){
 704:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 705:main.c        ****             print_value("Nixie Sleep Start Time", nixiesleepstart);
 706:main.c        ****         }else{
 707:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 708:main.c        ****         		if( inRange( splitString(myUartString), 2358, 0 ) )
 709:main.c        ****             		nixiesleepstart = splitString(myUartString);
 710:main.c        ****             }
 711:main.c        ****         }
 712:main.c        ****     }
 713:main.c        ****     
 714:main.c        ****     else if(strcasestr(myUartString,"nixiesleepend") != NULL){
 715:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 716:main.c        ****             print_value("Nixie Sleep End Time", nixiesleepend);
 717:main.c        ****         }else{
 718:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 719:main.c        ****         		if( inRange( splitString(myUartString), 2359, nixiesleepstart + 1 ) )
 720:main.c        ****             		nixiesleepend = splitString(myUartString);
 721:main.c        ****             }
 722:main.c        ****         }
 723:main.c        ****     }
 724:main.c        ****     
 725:main.c        ****     
 726:main.c        ****     else if(strcasestr(myUartString,"getall") != NULL){
 727:main.c        ****     	
 728:main.c        ****     	print_csv( ",", hours );					
 729:main.c        ****     	print_csv( ",", minutes );					
 730:main.c        ****     	print_csv( ",", seconds );					
 731:main.c        ****     	print_csv( ",", mscal );					
 732:main.c        ****     	print_csv( ",", miltime );					
 733:main.c        ****     	print_csv( ",", year );						
 734:main.c        ****     	print_csv( ",", month );					
 735:main.c        ****     	print_csv( ",", day );						
 736:main.c        ****     	print_csv( ",", celsius );					
 737:main.c        ****     	print_csv( ",", doecho );					
 738:main.c        ****     	print_csv( ",", xtalisfast );				
 739:main.c        ****     	print_csv( ",", showtherm );				
 740:main.c        ****     	print_csv( ",", showdate );					
 741:main.c        ****     	print_csv( ",", toggleled );				
 742:main.c        ****     	print_csv( ",", nixiesleepstart );			
 743:main.c        ****     	print_csv( ",", nixiesleepend );				
 744:main.c        ****     	print_csv( ",", SERIAL_NUMBER );			
 745:main.c        ****     	
 746:main.c        ****     	// PWR_OK
 747:main.c        ****     	double Volts = adc_raw[0] * 0.019375;
 748:main.c        ****         dtostrf(Volts , 10, 2, printBuffer);
 749:main.c        ****         uart_puts(printBuffer);
 750:main.c        ****         uart_puts(",");
 751:main.c        ****         
 752:main.c        ****         // HV_Feedback
 753:main.c        ****         Volts = adc_raw[1] * 1.9375;
 754:main.c        ****         dtostrf(Volts , 10, 2, printBuffer);
 755:main.c        ****         uart_puts(printBuffer);
 756:main.c        ****         uart_puts(",");
 757:main.c        ****         
 758:main.c        ****         // Battery Voltage
 759:main.c        ****         Volts = adc_raw[2] * 0.019375;
 760:main.c        ****         dtostrf(Volts , 10, 2, printBuffer);
 761:main.c        ****         uart_puts(printBuffer);
 762:main.c        ****         uart_puts(",");
 763:main.c        ****         
 764:main.c        ****         // Rectified AC voltage
 765:main.c        ****         Volts = adc_raw[3] * 0.11;
 766:main.c        ****         dtostrf(Volts , 10, 2, printBuffer);
 767:main.c        ****         uart_puts(printBuffer);
 768:main.c        ****     	
 769:main.c        ****     }
 770:main.c        ****     
 771:main.c        ****     else if( strcasestr( myUartString, "help" ) != NULL ){
 772:main.c        ****     	// print instructions
 773:main.c        ****     	uart_puts("Command");			uart_puts("\t\t");	uart_puts("Set/Read");	uart_puts("\t");	uart_puts("
 774:main.c        ****     	uart_puts("hours");				uart_puts("\t\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0")
 775:main.c        ****     	uart_puts("minutes");			uart_puts("\t\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0"
 776:main.c        ****     	uart_puts("seconds");			uart_puts("\t\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0"
 777:main.c        ****     	uart_puts("mscal");				uart_puts("\t\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0")
 778:main.c        ****     	uart_puts("miltime");			uart_puts("\t\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0"
 779:main.c        ****     	uart_puts("year");				uart_puts("\t\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0");
 780:main.c        ****     	uart_puts("month");				uart_puts("\t\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0")
 781:main.c        ****     	uart_puts("day");				uart_puts("\t\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0");	
 782:main.c        ****     	uart_puts("celsius");			uart_puts("\t\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0"
 783:main.c        ****     	uart_puts("doecho");			uart_puts("\t\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0")
 784:main.c        ****     	uart_puts("accclock");			uart_puts("\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0")
 785:main.c        ****     	uart_puts("xtalisfast");		uart_puts("\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0"
 786:main.c        ****     	uart_puts("showtherm");			uart_puts("\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0"
 787:main.c        ****     	uart_puts("showfreq");			uart_puts("\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0")
 788:main.c        ****     	uart_puts("showdate");			uart_puts("\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0")
 789:main.c        ****     	uart_puts("toggleled");			uart_puts("\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0"
 790:main.c        ****     	uart_puts("nixiesleepstart");	uart_puts("\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts
 791:main.c        ****     	uart_puts("nixiesleepend");		uart_puts("\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts(
 792:main.c        ****     	uart_puts("getall");			uart_puts("\t\t");	uart_puts("[ENTER]");	uart_puts( RETURN_NEWLINE );
 793:main.c        ****     	uart_puts("ramtoeeprom");		uart_puts("\t");	uart_puts("[ENTER]");	uart_puts( RETURN_NEWLINE );
 794:main.c        ****     	uart_puts("poke");				uart_puts("\t\t");	uart_puts("[ENTER]");	uart_puts( RETURN_NEWLINE );
 795:main.c        ****     	uart_puts("pwrok");				uart_puts("\t\t");	uart_puts("[ENTER]");	uart_puts( RETURN_NEWLINE );
 796:main.c        ****     	uart_puts("hvfeedback");		uart_puts("\t");	uart_puts("[ENTER]");	uart_puts( RETURN_NEWLINE );
 797:main.c        ****     	uart_puts("battvoltage");		uart_puts("\t");	uart_puts("[ENTER]");	uart_puts( RETURN_NEWLINE );
 798:main.c        ****     	uart_puts("rectifiedac");		uart_puts("\t");	uart_puts("[ENTER]");	uart_puts( RETURN_NEWLINE );
 799:main.c        ****     }
 800:main.c        ****     
 801:main.c        ****     else if(strcasestr(myUartString,"ramtoeeprom") != NULL){
 802:main.c        ****     	updateVarsToEeprom();   
 803:main.c        **** 		uart_puts( "EEPROM Storage Complete");
 804:main.c        ****     }
 805:main.c        ****     
 806:main.c        ****     else if(strstr(myUartString,"poke") != NULL){
 807:main.c        ****         
 808:main.c        ****         uart_puts( "Hello!");
 809:main.c        ****         uart_puts( RETURN_NEWLINE );
 810:main.c        ****         uart_puts( "I'm Serial Number: ");
 811:main.c        ****         uart_puts( itoa( SERIAL_NUMBER, printBuffer, 10 ) );
 812:main.c        ****         
 813:main.c        ****     }
 814:main.c        ****     
 815:main.c        ****     else if(strstr(myUartString,"pwrok") != NULL){
 816:main.c        ****         // ~0.019375 V/count
 817:main.c        ****         double pwrokVolts = adc_raw[0] * 0.019375;
 818:main.c        ****         dtostrf(pwrokVolts , 10, 2, printBuffer);
 819:main.c        ****         uart_puts(printBuffer);
 820:main.c        ****     }
 821:main.c        ****     
 822:main.c        ****     else if(strstr(myUartString,"hvfeedback") != NULL){
 823:main.c        ****         // ~1.9375 V/count
 824:main.c        ****         double hvVolts = adc_raw[1] * 1.9375;
 825:main.c        ****         dtostrf(hvVolts , 10, 2, printBuffer);
 826:main.c        ****         uart_puts(printBuffer);
 827:main.c        ****     }
 828:main.c        ****     
 829:main.c        ****     else if(strstr(myUartString,"battvoltage") != NULL){
 830:main.c        ****         // ~0.019375 V/count
 831:main.c        ****         double battVolts = adc_raw[2] * 0.019375;
 832:main.c        ****         dtostrf(battVolts , 10, 2, printBuffer);
 833:main.c        ****         uart_puts(printBuffer);
 834:main.c        ****     }
 835:main.c        ****     
 836:main.c        ****     else if(strstr(myUartString,"rectifiedac") != NULL){
 837:main.c        ****     	// 1K / 1K + 4K7 = 1K / 5K7 = ~0.175438 
 838:main.c        ****     	// 0.175 ^-1 = 5.7 
 839:main.c        ****         // ~0.11 V/count
 840:main.c        ****         double rectVolts = adc_raw[3] * 0.11;
 841:main.c        ****         dtostrf(rectVolts , 10, 2, printBuffer);
 842:main.c        ****         uart_puts(printBuffer);
 843:main.c        ****     }
 844:main.c        ****     uart_puts( RETURN_NEWLINE );
 845:main.c        **** }
 846:main.c        **** 
 847:main.c        **** 
 848:main.c        **** 
 849:main.c        **** 
 850:main.c        **** 
 851:main.c        **** void print_value (char *id, uint32_t value)
 852:main.c        **** {
 1039               		.loc 3 852 0
 1040               		.cfi_startproc
 1041               	.LVL68:
 1042 0334 CF93      		push r28
 1043               	.LCFI29:
 1044               		.cfi_def_cfa_offset 3
 1045               		.cfi_offset 28, -2
 1046 0336 DF93      		push r29
 1047               	.LCFI30:
 1048               		.cfi_def_cfa_offset 4
 1049               		.cfi_offset 29, -3
 1050               	/* prologue: function */
 1051               	/* frame size = 0 */
 1052               	/* stack size = 2 */
 1053               	.L__stack_usage = 2
 1054 0338 EC01      		movw r28,r24
 1055 033a CB01      		movw r24,r22
 1056 033c BA01      		movw r22,r20
 853:main.c        ****     ultoa(value, printBuffer, 10);
 1057               		.loc 3 853 0
 1058 033e 2AE0      		ldi r18,lo8(10)
 1059 0340 30E0      		ldi r19,0
 1060 0342 40E0      		ldi r20,lo8(printBuffer)
 1061 0344 50E0      		ldi r21,hi8(printBuffer)
 1062               	.LVL69:
 1063 0346 0E94 0000 		call ultoa
 1064               	.LVL70:
 854:main.c        ****     uart_puts(id);
 1065               		.loc 3 854 0
 1066 034a CE01      		movw r24,r28
 1067 034c 0E94 0000 		call uart_puts
 1068               	.LVL71:
 855:main.c        ****     uart_puts(": ");
 1069               		.loc 3 855 0
 1070 0350 80E0      		ldi r24,lo8(.LC1)
 1071 0352 90E0      		ldi r25,hi8(.LC1)
 1072 0354 0E94 0000 		call uart_puts
 1073               	.LVL72:
 856:main.c        ****     uart_puts(printBuffer);
 1074               		.loc 3 856 0
 1075 0358 80E0      		ldi r24,lo8(printBuffer)
 1076 035a 90E0      		ldi r25,hi8(printBuffer)
 1077               	/* epilogue start */
 857:main.c        ****     //uart_puts(RETURN_NEWLINE);
 858:main.c        **** }
 1078               		.loc 3 858 0
 1079 035c DF91      		pop r29
 1080 035e CF91      		pop r28
 1081               	.LVL73:
 856:main.c        ****     uart_puts(printBuffer);
 1082               		.loc 3 856 0
 1083 0360 0C94 0000 		jmp uart_puts
 1084               	.LVL74:
 1085               		.cfi_endproc
 1086               	.LFE28:
 1088               	.global	print_csv
 1090               	print_csv:
 1091               	.LFB29:
 859:main.c        **** 
 860:main.c        **** 
 861:main.c        **** 
 862:main.c        **** void print_csv( char *id, uint32_t value )
 863:main.c        **** {
 1092               		.loc 3 863 0
 1093               		.cfi_startproc
 1094               	.LVL75:
 1095 0364 CF93      		push r28
 1096               	.LCFI31:
 1097               		.cfi_def_cfa_offset 3
 1098               		.cfi_offset 28, -2
 1099 0366 DF93      		push r29
 1100               	.LCFI32:
 1101               		.cfi_def_cfa_offset 4
 1102               		.cfi_offset 29, -3
 1103               	/* prologue: function */
 1104               	/* frame size = 0 */
 1105               	/* stack size = 2 */
 1106               	.L__stack_usage = 2
 1107 0368 EC01      		movw r28,r24
 1108 036a CB01      		movw r24,r22
 1109 036c BA01      		movw r22,r20
 864:main.c        ****     ultoa(value, printBuffer, 10);
 1110               		.loc 3 864 0
 1111 036e 2AE0      		ldi r18,lo8(10)
 1112 0370 30E0      		ldi r19,0
 1113 0372 40E0      		ldi r20,lo8(printBuffer)
 1114 0374 50E0      		ldi r21,hi8(printBuffer)
 1115               	.LVL76:
 1116 0376 0E94 0000 		call ultoa
 1117               	.LVL77:
 865:main.c        **** 
 866:main.c        ****     //uart_puts(": ");
 867:main.c        ****     uart_puts(printBuffer);
 1118               		.loc 3 867 0
 1119 037a 80E0      		ldi r24,lo8(printBuffer)
 1120 037c 90E0      		ldi r25,hi8(printBuffer)
 1121 037e 0E94 0000 		call uart_puts
 1122               	.LVL78:
 868:main.c        ****         uart_puts(id);
 1123               		.loc 3 868 0
 1124 0382 CE01      		movw r24,r28
 1125               	/* epilogue start */
 869:main.c        ****     //uart_puts(RETURN_NEWLINE);
 870:main.c        **** }
 1126               		.loc 3 870 0
 1127 0384 DF91      		pop r29
 1128 0386 CF91      		pop r28
 1129               	.LVL79:
 868:main.c        ****         uart_puts(id);
 1130               		.loc 3 868 0
 1131 0388 0C94 0000 		jmp uart_puts
 1132               	.LVL80:
 1133               		.cfi_endproc
 1134               	.LFE29:
 1136               		.section	.rodata.str1.1
 1137               	.LC2:
 1138 0003 4F4B 00   		.string	"OK"
 1139               	.LC3:
 1140 0006 0D0A 00   		.string	"\r\n"
 1141               		.text
 1142               	.global	uart_ok
 1144               	uart_ok:
 1145               	.LFB30:
 871:main.c        **** 
 872:main.c        **** 
 873:main.c        **** 
 874:main.c        **** 
 875:main.c        **** void uart_ok()
 876:main.c        **** {
 1146               		.loc 3 876 0
 1147               		.cfi_startproc
 1148               	/* prologue: function */
 1149               	/* frame size = 0 */
 1150               	/* stack size = 0 */
 1151               	.L__stack_usage = 0
 877:main.c        ****     uart_puts("OK");
 1152               		.loc 3 877 0
 1153 038c 80E0      		ldi r24,lo8(.LC2)
 1154 038e 90E0      		ldi r25,hi8(.LC2)
 1155 0390 0E94 0000 		call uart_puts
 1156               	.LVL81:
 878:main.c        ****     uart_puts(RETURN_NEWLINE);
 1157               		.loc 3 878 0
 1158 0394 80E0      		ldi r24,lo8(.LC3)
 1159 0396 90E0      		ldi r25,hi8(.LC3)
 1160 0398 0C94 0000 		jmp uart_puts
 1161               	.LVL82:
 1162               		.cfi_endproc
 1163               	.LFE30:
 1165               		.section	.rodata.str1.1
 1166               	.LC4:
 1167 0009 2F2F 7E7E 		.string	"//~~~~~~~~~~~~************ Nixie Clock Instructions ************~~~~~~~~~~~~~~"
 1167      7E7E 7E7E 
 1167      7E7E 7E7E 
 1167      7E7E 2A2A 
 1167      2A2A 2A2A 
 1168               	.LC5:
 1169 0058 4154 4D65 		.string	"ATMega328 Nixie Clock v1.0"
 1169      6761 3332 
 1169      3820 4E69 
 1169      7869 6520 
 1169      436C 6F63 
 1170               	.LC6:
 1171 0073 4368 6563 		.string	"Check petemills.blogspot.com for more info"
 1171      6B20 7065 
 1171      7465 6D69 
 1171      6C6C 732E 
 1171      626C 6F67 
 1172               	.LC7:
 1173 009e 5573 6167 		.string	"Usage Example:"
 1173      6520 4578 
 1173      616D 706C 
 1173      653A 00
 1174               	.LC8:
 1175 00ad 5479 7065 		.string	"Type 'HOURS=10' to set the hours to '10'."
 1175      2027 484F 
 1175      5552 533D 
 1175      3130 2720 
 1175      746F 2073 
 1176               	.LC9:
 1177 00d7 5479 7065 		.string	"Type 'MINUTES=26' to set the minutes to '26'."
 1177      2027 4D49 
 1177      4E55 5445 
 1177      533D 3236 
 1177      2720 746F 
 1178               	.LC10:
 1179 0105 4675 7274 		.string	"Further parameter names can be found in the user manual."
 1179      6865 7220 
 1179      7061 7261 
 1179      6D65 7465 
 1179      7220 6E61 
 1180               	.LC11:
 1181 013e 5669 7369 		.string	"Visit the URL above to download a clock calibration app and user manual."
 1181      7420 7468 
 1181      6520 5552 
 1181      4C20 6162 
 1181      6F76 6520 
 1182               		.text
 1183               	.global	uartWelcome
 1185               	uartWelcome:
 1186               	.LFB32:
 879:main.c        **** }
 880:main.c        **** 
 881:main.c        **** 
 882:main.c        **** 
 883:main.c        **** 
 884:main.c        **** void checkSerialIn()
 885:main.c        **** {
 886:main.c        ****     
 887:main.c        ****     unsigned int aChar = uart_getc();
 888:main.c        ****     
 889:main.c        ****     if ( aChar & UART_NO_DATA )
 890:main.c        ****     {
 891:main.c        ****         
 892:main.c        ****          // No data available from UART
 893:main.c        **** 
 894:main.c        ****     }
 895:main.c        ****     else
 896:main.c        ****     {
 897:main.c        **** 
 898:main.c        ****         /*
 899:main.c        ****          * new data available from UART
 900:main.c        ****          * check for Frame or Overrun error
 901:main.c        ****          */
 902:main.c        ****         if ( aChar & UART_FRAME_ERROR )
 903:main.c        ****         {
 904:main.c        ****             /* Framing Error detected, i.e no stop bit detected */
 905:main.c        ****             uart_puts_P("UART Frame Error: ");
 906:main.c        ****         }
 907:main.c        ****         if ( aChar & UART_OVERRUN_ERROR )
 908:main.c        ****         {
 909:main.c        ****             /*
 910:main.c        ****              * Overrun, a character already present in the UART UDR register was
 911:main.c        ****              * not read by the interrupt handler before the next character arrived,
 912:main.c        ****              * one or more received characters have been dropped
 913:main.c        ****              */
 914:main.c        ****             uart_puts_P("UART Overrun Error: ");
 915:main.c        ****         }
 916:main.c        ****         if ( aChar & UART_BUFFER_OVERFLOW )
 917:main.c        ****         {
 918:main.c        ****             /*
 919:main.c        ****              * We are not reading the receive buffer fast enough,
 920:main.c        ****              * one or more received character have been dropped
 921:main.c        ****              */
 922:main.c        ****             uart_puts_P("Buffer overflow error: ");
 923:main.c        ****         }
 924:main.c        ****         /*
 925:main.c        ****          * send received character back
 926:main.c        ****          */
 927:main.c        ****         
 928:main.c        ****     // Add aChar to the growing string.
 929:main.c        ****     uartString[uartStringIndex] = aChar;
 930:main.c        ****     
 931:main.c        ****     // Keep going until we see a CHAR_RETURN.
 932:main.c        ****     if (uartString[uartStringIndex] == CHAR_RETURN) {
 933:main.c        ****         // Reset to 0, ready to go again
 934:main.c        ****         uartStringIndex = 0;
 935:main.c        ****         uart_puts(RETURN_NEWLINE);
 936:main.c        ****         
 937:main.c        ****         copy_command();
 938:main.c        ****         process_command();
 939:main.c        ****         }
 940:main.c        ****     else {
 941:main.c        ****         uartStringIndex++;
 942:main.c        ****     }
 943:main.c        ****     
 944:main.c        ****     if( doecho ){
 945:main.c        ****     	uart_putc( (unsigned char)aChar ); //echo
 946:main.c        ****     }
 947:main.c        ****         
 948:main.c        ****     }
 949:main.c        **** }
 950:main.c        **** 
 951:main.c        **** 
 952:main.c        **** 
 953:main.c        **** 
 954:main.c        **** void uartWelcome( void )
 955:main.c        **** {
 1187               		.loc 3 955 0
 1188               		.cfi_startproc
 1189               	/* prologue: function */
 1190               	/* frame size = 0 */
 1191               	/* stack size = 0 */
 1192               	.L__stack_usage = 0
 956:main.c        **** 
 957:main.c        ****     uart_puts("//~~~~~~~~~~~~************ Nixie Clock Instructions ************~~~~~~~~~~~~~~");
 1193               		.loc 3 957 0
 1194 039c 80E0      		ldi r24,lo8(.LC4)
 1195 039e 90E0      		ldi r25,hi8(.LC4)
 1196 03a0 0E94 0000 		call uart_puts
 1197               	.LVL83:
 958:main.c        ****     uart_puts(RETURN_NEWLINE);
 1198               		.loc 3 958 0
 1199 03a4 80E0      		ldi r24,lo8(.LC3)
 1200 03a6 90E0      		ldi r25,hi8(.LC3)
 1201 03a8 0E94 0000 		call uart_puts
 1202               	.LVL84:
 959:main.c        ****     uart_puts("ATMega328 Nixie Clock v1.0");
 1203               		.loc 3 959 0
 1204 03ac 80E0      		ldi r24,lo8(.LC5)
 1205 03ae 90E0      		ldi r25,hi8(.LC5)
 1206 03b0 0E94 0000 		call uart_puts
 1207               	.LVL85:
 960:main.c        ****     uart_puts(RETURN_NEWLINE);
 1208               		.loc 3 960 0
 1209 03b4 80E0      		ldi r24,lo8(.LC3)
 1210 03b6 90E0      		ldi r25,hi8(.LC3)
 1211 03b8 0E94 0000 		call uart_puts
 1212               	.LVL86:
 961:main.c        ****     uart_puts("Check petemills.blogspot.com for more info");
 1213               		.loc 3 961 0
 1214 03bc 80E0      		ldi r24,lo8(.LC6)
 1215 03be 90E0      		ldi r25,hi8(.LC6)
 1216 03c0 0E94 0000 		call uart_puts
 1217               	.LVL87:
 962:main.c        ****     uart_puts(RETURN_NEWLINE);
 1218               		.loc 3 962 0
 1219 03c4 80E0      		ldi r24,lo8(.LC3)
 1220 03c6 90E0      		ldi r25,hi8(.LC3)
 1221 03c8 0E94 0000 		call uart_puts
 1222               	.LVL88:
 963:main.c        ****     uart_puts(RETURN_NEWLINE);
 1223               		.loc 3 963 0
 1224 03cc 80E0      		ldi r24,lo8(.LC3)
 1225 03ce 90E0      		ldi r25,hi8(.LC3)
 1226 03d0 0E94 0000 		call uart_puts
 1227               	.LVL89:
 964:main.c        ****     uart_puts("Usage Example:");
 1228               		.loc 3 964 0
 1229 03d4 80E0      		ldi r24,lo8(.LC7)
 1230 03d6 90E0      		ldi r25,hi8(.LC7)
 1231 03d8 0E94 0000 		call uart_puts
 1232               	.LVL90:
 965:main.c        ****     uart_puts(RETURN_NEWLINE);
 1233               		.loc 3 965 0
 1234 03dc 80E0      		ldi r24,lo8(.LC3)
 1235 03de 90E0      		ldi r25,hi8(.LC3)
 1236 03e0 0E94 0000 		call uart_puts
 1237               	.LVL91:
 966:main.c        ****     uart_puts("Type 'HOURS=10' to set the hours to '10'.");
 1238               		.loc 3 966 0
 1239 03e4 80E0      		ldi r24,lo8(.LC8)
 1240 03e6 90E0      		ldi r25,hi8(.LC8)
 1241 03e8 0E94 0000 		call uart_puts
 1242               	.LVL92:
 967:main.c        ****     uart_puts(RETURN_NEWLINE);
 1243               		.loc 3 967 0
 1244 03ec 80E0      		ldi r24,lo8(.LC3)
 1245 03ee 90E0      		ldi r25,hi8(.LC3)
 1246 03f0 0E94 0000 		call uart_puts
 1247               	.LVL93:
 968:main.c        ****     uart_puts("Type 'MINUTES=26' to set the minutes to '26'.");
 1248               		.loc 3 968 0
 1249 03f4 80E0      		ldi r24,lo8(.LC9)
 1250 03f6 90E0      		ldi r25,hi8(.LC9)
 1251 03f8 0E94 0000 		call uart_puts
 1252               	.LVL94:
 969:main.c        ****     uart_puts(RETURN_NEWLINE);
 1253               		.loc 3 969 0
 1254 03fc 80E0      		ldi r24,lo8(.LC3)
 1255 03fe 90E0      		ldi r25,hi8(.LC3)
 1256 0400 0E94 0000 		call uart_puts
 1257               	.LVL95:
 970:main.c        ****     uart_puts("Further parameter names can be found in the user manual.");
 1258               		.loc 3 970 0
 1259 0404 80E0      		ldi r24,lo8(.LC10)
 1260 0406 90E0      		ldi r25,hi8(.LC10)
 1261 0408 0E94 0000 		call uart_puts
 1262               	.LVL96:
 971:main.c        ****     uart_puts(RETURN_NEWLINE);
 1263               		.loc 3 971 0
 1264 040c 80E0      		ldi r24,lo8(.LC3)
 1265 040e 90E0      		ldi r25,hi8(.LC3)
 1266 0410 0E94 0000 		call uart_puts
 1267               	.LVL97:
 972:main.c        ****     uart_puts("Visit the URL above to download a clock calibration app and user manual.");
 1268               		.loc 3 972 0
 1269 0414 80E0      		ldi r24,lo8(.LC11)
 1270 0416 90E0      		ldi r25,hi8(.LC11)
 1271 0418 0E94 0000 		call uart_puts
 1272               	.LVL98:
 973:main.c        ****     uart_puts(RETURN_NEWLINE);
 1273               		.loc 3 973 0
 1274 041c 80E0      		ldi r24,lo8(.LC3)
 1275 041e 90E0      		ldi r25,hi8(.LC3)
 1276 0420 0E94 0000 		call uart_puts
 1277               	.LVL99:
 974:main.c        ****     uart_puts("//~~~~~~~~~~~~************ Nixie Clock Instructions ************~~~~~~~~~~~~~~");
 1278               		.loc 3 974 0
 1279 0424 80E0      		ldi r24,lo8(.LC4)
 1280 0426 90E0      		ldi r25,hi8(.LC4)
 1281 0428 0C94 0000 		jmp uart_puts
 1282               	.LVL100:
 1283               		.cfi_endproc
 1284               	.LFE32:
 1286               	.global	uartInit
 1288               	uartInit:
 1289               	.LFB33:
 975:main.c        **** }
 976:main.c        **** 
 977:main.c        **** 
 978:main.c        **** 
 979:main.c        **** 
 980:main.c        **** void uartInit( void )
 981:main.c        **** {
 1290               		.loc 3 981 0
 1291               		.cfi_startproc
 1292               	/* prologue: function */
 1293               	/* frame size = 0 */
 1294               	/* stack size = 0 */
 1295               	.L__stack_usage = 0
 982:main.c        ****         uart_init( UART_BAUD_SELECT(UART_BAUD_RATE,F_CPU) );
 1296               		.loc 3 982 0
 1297 042c 80E1      		ldi r24,lo8(16)
 1298 042e 90E0      		ldi r25,0
 1299 0430 0C94 0000 		jmp uart_init
 1300               	.LVL101:
 1301               		.cfi_endproc
 1302               	.LFE33:
 1304               		.section	.rodata.str1.1
 1305               	.LC12:
 1306 0187 2C20 00   		.string	", "
 1307               		.text
 1308               	.global	serialPrintDateTime
 1310               	serialPrintDateTime:
 1311               	.LFB36:
 983:main.c        **** }
 984:main.c        **** 
 985:main.c        **** 
 986:main.c        **** 
 987:main.c        **** 
 988:main.c        **** 
 989:main.c        **** // This interrupt is called at 1kHz
 990:main.c        **** // Here we are keeping track of milliseconds and adjusting them slightly to get 1 clock second
 991:main.c        **** // to equal 1 real world second very closely.
 992:main.c        **** // Set via serial comms,  mscal = F_CPU / (F_CPU * PPM_ERROR), then set fast or slow.
 993:main.c        **** ISR( TIMER1_COMPA_vect )
 994:main.c        **** {
 995:main.c        ****     static uint16_t milliSeconds = 0;		// mS value for timekeeping 1000mS/1S
 996:main.c        ****     static uint32_t clockCalCounter = 0;	// counting up the milliseconds to mscal
 997:main.c        ****     const uint16_t MS_IN_SEC = 1000;		// 1000mS/1S
 998:main.c        ****     static uint16_t acFreqFiltCtr = 0;		// this is incremented until it == AC_FRQ_FILT_SEC
 999:main.c        ****     milliSeconds++;
1000:main.c        ****     clockCalCounter++;
1001:main.c        ****     
1002:main.c        ****     
1003:main.c        ****     if( milliSeconds >= MS_IN_SEC )
1004:main.c        ****     {
1005:main.c        ****     	if( acclock == 0 || acPowerOk() == 0 ){	// If we are meant to use the internal xtal, not power
1006:main.c        ****     											// Or, if we loose AC power, and we are in AC clock mode we should step in and keep 
1007:main.c        ****         	seconds++;          // increment seconds
1008:main.c        ****         }
1009:main.c        ****         
1010:main.c        ****         	milliSeconds = 0;   // reset milliseconds
1011:main.c        ****         
1012:main.c        ****         	if( toggleled )		// Clearly toggling the LED is only available when using the internal xta
1013:main.c        ****         		toggle_led();	// Toggle the LED if allowed.
1014:main.c        ****         	acFreqFiltCtr++;	// Increment the frequency filter counter.	
1015:main.c        ****     }
1016:main.c        ****     
1017:main.c        ****     // For measuring the power line frequency.
1018:main.c        **** 	if( acFreqFiltCtr >= AC_FRQ_FILT_SEC )
1019:main.c        **** 	{
1020:main.c        **** 		acZeroCrossSnapshot = acZeroCrossCounter;	// Grab the current number of zero crossings since the 
1021:main.c        **** 		acZeroCrossCounter = 0;				// Reset the number of zero crossings.
1022:main.c        **** 		acFreqFlag = 1;						// Signal that a computation is ready to be made.
1023:main.c        **** 		acFreqFiltCtr = 0;					// Reset the measurement interval counter.
1024:main.c        **** 	}
1025:main.c        **** 
1026:main.c        ****     
1027:main.c        **** 
1028:main.c        ****     // Only adjust the time if mscal is not 0, this way we can disable the
1029:main.c        ****     // adjustment during the calibration procedure.
1030:main.c        ****     if( mscal != 0 )
1031:main.c        ****     {
1032:main.c        ****         if( xtalisfast == 1 )
1033:main.c        ****         {
1034:main.c        ****             if( ( clockCalCounter >= mscal ) && ( milliSeconds > 1 ))
1035:main.c        ****             {
1036:main.c        ****                 milliSeconds--;
1037:main.c        ****                 clockCalCounter = clockCalCounter - mscal;
1038:main.c        ****             }
1039:main.c        ****         }
1040:main.c        ****         else
1041:main.c        ****         {
1042:main.c        ****             // milliseconds must be less than 999 to avoid missing an adjustment.
1043:main.c        ****             // eg if milliseconds were to be 999 and we increment it here to 1000
1044:main.c        ****             // the next ISR call will make it 1001 and reset to zero just as if it
1045:main.c        ****             // would for 1000 and the adjustment would be effectively canceled out.
1046:main.c        ****             if( ( clockCalCounter >= mscal ) && ( milliSeconds < MS_IN_SEC - 1 ) )
1047:main.c        ****             {
1048:main.c        ****                 milliSeconds++;
1049:main.c        ****          
1050:main.c        ****                 // it may be that clock_cal_counter > than mscal in which case
1051:main.c        ****                 // I want to count the tick towards the next adjustment
1052:main.c        ****                 // should always be 1 or 0
1053:main.c        ****                 clockCalCounter = clockCalCounter - mscal;
1054:main.c        ****             }
1055:main.c        ****         }
1056:main.c        ****     }
1057:main.c        ****     
1058:main.c        ****     updateBoostConverter();	// Updated here for determinism.
1059:main.c        **** }
1060:main.c        **** 
1061:main.c        **** 
1062:main.c        **** 
1063:main.c        **** 
1064:main.c        **** void updateDateTime( void )
1065:main.c        **** {
1066:main.c        ****     uint8_t numDaysInMonth[] = {0,31,28,31,30,31,30,31,31,30,31,30,31};
1067:main.c        ****     
1068:main.c        ****     if( numDaysInMonth[2] == 28 && isLeapYear() )
1069:main.c        ****     {
1070:main.c        ****         numDaysInMonth[2] = 29;
1071:main.c        ****     }
1072:main.c        ****     else if( numDaysInMonth[2] == 29 )
1073:main.c        ****     {
1074:main.c        ****         numDaysInMonth[2] = 28;
1075:main.c        ****     }
1076:main.c        ****     
1077:main.c        ****     
1078:main.c        ****     if( seconds > 59 )
1079:main.c        ****     {
1080:main.c        ****         minutes++;		// increment minutes
1081:main.c        ****         seconds = 0;	// reset seconds
1082:main.c        ****     }
1083:main.c        ****     
1084:main.c        ****     if( minutes > 59 )
1085:main.c        ****     {
1086:main.c        ****         hours++;		// increment hours
1087:main.c        ****         minutes = 0; 	// reset minutes
1088:main.c        ****     }
1089:main.c        ****     
1090:main.c        ****     if( hours > 23 )
1091:main.c        ****     {
1092:main.c        ****         day++;          // increment day
1093:main.c        ****         hours = 0;		// reset hours
1094:main.c        ****     }
1095:main.c        ****     
1096:main.c        ****     if( day > numDaysInMonth[ month ] )
1097:main.c        ****     {
1098:main.c        ****         month++;        // increment the month
1099:main.c        ****         day = 1;        // reset the day counter to the first
1100:main.c        ****     }
1101:main.c        ****     
1102:main.c        ****     if( month > 12 )
1103:main.c        ****     {
1104:main.c        ****         year++;         // increment the year
1105:main.c        ****         month = 1;      // reset the month to january
1106:main.c        ****     }
1107:main.c        ****     
1108:main.c        ****     
1109:main.c        **** }
1110:main.c        **** 
1111:main.c        **** 
1112:main.c        **** 
1113:main.c        **** 
1114:main.c        **** void serialPrintDateTime( void )
1115:main.c        **** {
 1312               		.loc 3 1115 0
 1313               		.cfi_startproc
 1314               	/* prologue: function */
 1315               	/* frame size = 0 */
 1316               	/* stack size = 0 */
 1317               	.L__stack_usage = 0
1116:main.c        ****     //if( isLeapYear() )
1117:main.c        ****     //    uart_puts("L ");
1118:main.c        ****     // Print the date in YYYY.MM.DD format
1119:main.c        ****     uart_puts( itoa( year, printBuffer, 10 ) );
 1318               		.loc 3 1119 0
 1319 0434 4AE0      		ldi r20,lo8(10)
 1320 0436 50E0      		ldi r21,0
 1321 0438 60E0      		ldi r22,lo8(printBuffer)
 1322 043a 70E0      		ldi r23,hi8(printBuffer)
 1323 043c 8091 0000 		lds r24,year
 1324 0440 9091 0000 		lds r25,year+1
 1325 0444 0E94 0000 		call itoa
 1326               	.LVL102:
 1327 0448 0E94 0000 		call uart_puts
 1328               	.LVL103:
1120:main.c        ****     uart_putc('-');
 1329               		.loc 3 1120 0
 1330 044c 8DE2      		ldi r24,lo8(45)
 1331 044e 0E94 0000 		call uart_putc
 1332               	.LVL104:
1121:main.c        ****     
1122:main.c        ****     uart_puts( itoa( month, printBuffer, 10 ) );
 1333               		.loc 3 1122 0
 1334 0452 4AE0      		ldi r20,lo8(10)
 1335 0454 50E0      		ldi r21,0
 1336 0456 60E0      		ldi r22,lo8(printBuffer)
 1337 0458 70E0      		ldi r23,hi8(printBuffer)
 1338 045a 8091 0000 		lds r24,month
 1339 045e 90E0      		ldi r25,0
 1340 0460 0E94 0000 		call itoa
 1341               	.LVL105:
 1342 0464 0E94 0000 		call uart_puts
 1343               	.LVL106:
1123:main.c        ****     uart_putc('-');
 1344               		.loc 3 1123 0
 1345 0468 8DE2      		ldi r24,lo8(45)
 1346 046a 0E94 0000 		call uart_putc
 1347               	.LVL107:
1124:main.c        ****     
1125:main.c        ****     uart_puts( itoa( day, printBuffer, 10 ) );
 1348               		.loc 3 1125 0
 1349 046e 4AE0      		ldi r20,lo8(10)
 1350 0470 50E0      		ldi r21,0
 1351 0472 60E0      		ldi r22,lo8(printBuffer)
 1352 0474 70E0      		ldi r23,hi8(printBuffer)
 1353 0476 8091 0000 		lds r24,day
 1354 047a 90E0      		ldi r25,0
 1355 047c 0E94 0000 		call itoa
 1356               	.LVL108:
 1357 0480 0E94 0000 		call uart_puts
 1358               	.LVL109:
1126:main.c        ****     
1127:main.c        ****     uart_puts(", ");
 1359               		.loc 3 1127 0
 1360 0484 80E0      		ldi r24,lo8(.LC12)
 1361 0486 90E0      		ldi r25,hi8(.LC12)
 1362 0488 0E94 0000 		call uart_puts
 1363               	.LVL110:
1128:main.c        ****     
1129:main.c        ****     
1130:main.c        ****     if( miltime == 0  && hours > 12 )
 1364               		.loc 3 1130 0
 1365 048c 8091 0000 		lds r24,miltime
 1366 0490 8111      		cpse r24,__zero_reg__
 1367 0492 00C0      		rjmp .L45
 1368               		.loc 3 1130 0 is_stmt 0 discriminator 1
 1369 0494 8091 0000 		lds r24,hours
 1370 0498 8D30      		cpi r24,lo8(13)
 1371 049a 00F0      		brlo .L46
1131:main.c        ****     {
1132:main.c        ****         // Display the hours in 12 hour format.
1133:main.c        ****         uart_puts( itoa( hours - 12, printBuffer, 10 ) );
 1372               		.loc 3 1133 0 is_stmt 1
 1373 049c 90E0      		ldi r25,0
 1374 049e 4AE0      		ldi r20,lo8(10)
 1375 04a0 50E0      		ldi r21,0
 1376 04a2 60E0      		ldi r22,lo8(printBuffer)
 1377 04a4 70E0      		ldi r23,hi8(printBuffer)
 1378 04a6 0C97      		sbiw r24,12
 1379 04a8 00C0      		rjmp .L48
 1380               	.L46:
1134:main.c        ****     }
1135:main.c        ****     else if( miltime == 0 && hours == 0 )
 1381               		.loc 3 1135 0 discriminator 1
 1382 04aa 8111      		cpse r24,__zero_reg__
 1383 04ac 00C0      		rjmp .L45
1136:main.c        ****     {
1137:main.c        ****         // Don't display '0' hours in 12-hour format, display "12" instead.
1138:main.c        ****         uart_puts( itoa( 12, printBuffer, 10 ) );
 1384               		.loc 3 1138 0
 1385 04ae 4AE0      		ldi r20,lo8(10)
 1386 04b0 50E0      		ldi r21,0
 1387 04b2 60E0      		ldi r22,lo8(printBuffer)
 1388 04b4 70E0      		ldi r23,hi8(printBuffer)
 1389 04b6 8CE0      		ldi r24,lo8(12)
 1390 04b8 90E0      		ldi r25,0
 1391 04ba 00C0      		rjmp .L48
 1392               	.L45:
1139:main.c        ****     }
1140:main.c        ****     else
1141:main.c        ****     {
1142:main.c        ****         // Otherwise, everything is cool, just print the hours.
1143:main.c        ****         uart_puts( itoa( hours, printBuffer, 10 ) );
 1393               		.loc 3 1143 0
 1394 04bc 4AE0      		ldi r20,lo8(10)
 1395 04be 50E0      		ldi r21,0
 1396 04c0 60E0      		ldi r22,lo8(printBuffer)
 1397 04c2 70E0      		ldi r23,hi8(printBuffer)
 1398 04c4 8091 0000 		lds r24,hours
 1399 04c8 90E0      		ldi r25,0
 1400               	.L48:
 1401 04ca 0E94 0000 		call itoa
 1402               	.LVL111:
 1403 04ce 0E94 0000 		call uart_puts
 1404               	.LVL112:
1144:main.c        ****     }
1145:main.c        ****     uart_putc(':');
 1405               		.loc 3 1145 0
 1406 04d2 8AE3      		ldi r24,lo8(58)
 1407 04d4 0E94 0000 		call uart_putc
 1408               	.LVL113:
1146:main.c        ****         
1147:main.c        ****     uart_puts( itoa( minutes, printBuffer, 10 ) );
 1409               		.loc 3 1147 0
 1410 04d8 4AE0      		ldi r20,lo8(10)
 1411 04da 50E0      		ldi r21,0
 1412 04dc 60E0      		ldi r22,lo8(printBuffer)
 1413 04de 70E0      		ldi r23,hi8(printBuffer)
 1414 04e0 8091 0000 		lds r24,minutes
 1415 04e4 90E0      		ldi r25,0
 1416 04e6 0E94 0000 		call itoa
 1417               	.LVL114:
 1418 04ea 0E94 0000 		call uart_puts
 1419               	.LVL115:
1148:main.c        ****     uart_putc(':');
 1420               		.loc 3 1148 0
 1421 04ee 8AE3      		ldi r24,lo8(58)
 1422 04f0 0E94 0000 		call uart_putc
 1423               	.LVL116:
1149:main.c        ****         
1150:main.c        ****     uart_puts( itoa( seconds, printBuffer, 10 ) );
 1424               		.loc 3 1150 0
 1425 04f4 8091 0000 		lds r24,seconds
 1426 04f8 4AE0      		ldi r20,lo8(10)
 1427 04fa 50E0      		ldi r21,0
 1428 04fc 60E0      		ldi r22,lo8(printBuffer)
 1429 04fe 70E0      		ldi r23,hi8(printBuffer)
 1430 0500 90E0      		ldi r25,0
 1431 0502 0E94 0000 		call itoa
 1432               	.LVL117:
 1433 0506 0E94 0000 		call uart_puts
 1434               	.LVL118:
1151:main.c        ****         
1152:main.c        ****     //uart_puts(RETURN_NEWLINE);
1153:main.c        ****     uart_putc( ',');
 1435               		.loc 3 1153 0
 1436 050a 8CE2      		ldi r24,lo8(44)
 1437 050c 0C94 0000 		jmp uart_putc
 1438               	.LVL119:
 1439               		.cfi_endproc
 1440               	.LFE36:
 1442               	.global	isLeapYear
 1444               	isLeapYear:
 1445               	.LFB37:
1154:main.c        **** 
1155:main.c        **** }
1156:main.c        **** 
1157:main.c        **** 
1158:main.c        **** 
1159:main.c        **** 
1160:main.c        **** uint8_t isLeapYear( void )
1161:main.c        **** {
 1446               		.loc 3 1161 0
 1447               		.cfi_startproc
 1448               	/* prologue: function */
 1449               	/* frame size = 0 */
 1450               	/* stack size = 0 */
 1451               	.L__stack_usage = 0
1162:main.c        ****     if( year % 4 != 0 )
 1452               		.loc 3 1162 0
 1453 0510 2091 0000 		lds r18,year
 1454 0514 3091 0000 		lds r19,year+1
 1455 0518 C901      		movw r24,r18
 1456 051a 8370      		andi r24,3
 1457 051c 9927      		clr r25
 1458 051e 892B      		or r24,r25
 1459 0520 01F4      		brne .L52
1163:main.c        ****     {
1164:main.c        ****         return 0;   // not a leap year
1165:main.c        ****     }
1166:main.c        ****     else if( year % 100 != 0 )
 1460               		.loc 3 1166 0
 1461 0522 C901      		movw r24,r18
 1462 0524 64E6      		ldi r22,lo8(100)
 1463 0526 70E0      		ldi r23,0
 1464 0528 0E94 0000 		call __udivmodhi4
 1465 052c 892B      		or r24,r25
 1466 052e 01F4      		brne .L53
1167:main.c        ****     {
1168:main.c        ****         return 1;   // it is a leap year
1169:main.c        ****     }
1170:main.c        ****     else if( year % 400 )
 1467               		.loc 3 1170 0
 1468 0530 C901      		movw r24,r18
 1469 0532 60E9      		ldi r22,lo8(-112)
 1470 0534 71E0      		ldi r23,lo8(1)
 1471 0536 0E94 0000 		call __udivmodhi4
 1472 053a 21E0      		ldi r18,lo8(1)
 1473 053c 892B      		or r24,r25
 1474 053e 01F0      		breq .L50
 1475               	.L52:
1164:main.c        ****         return 0;   // not a leap year
 1476               		.loc 3 1164 0
 1477 0540 20E0      		ldi r18,0
 1478 0542 00C0      		rjmp .L50
 1479               	.L53:
1168:main.c        ****         return 1;   // it is a leap year
 1480               		.loc 3 1168 0
 1481 0544 21E0      		ldi r18,lo8(1)
 1482               	.L50:
1171:main.c        ****     {
1172:main.c        ****         return 0;   // it is not a leap year
1173:main.c        ****     }
1174:main.c        ****     else
1175:main.c        ****     {
1176:main.c        ****         return 1;   // it is a leap year
1177:main.c        ****     }
1178:main.c        **** }
 1483               		.loc 3 1178 0
 1484 0546 822F      		mov r24,r18
 1485 0548 0895      		ret
 1486               		.cfi_endproc
 1487               	.LFE37:
 1489               		.section	.rodata
 1490               	.LC0:
 1491 0000 00        		.byte	0
 1492 0001 1F        		.byte	31
 1493 0002 1C        		.byte	28
 1494 0003 1F        		.byte	31
 1495 0004 1E        		.byte	30
 1496 0005 1F        		.byte	31
 1497 0006 1E        		.byte	30
 1498 0007 1F        		.byte	31
 1499 0008 1F        		.byte	31
 1500 0009 1E        		.byte	30
 1501 000a 1F        		.byte	31
 1502 000b 1E        		.byte	30
 1503 000c 1F        		.byte	31
 1504               		.text
 1505               	.global	updateDateTime
 1507               	updateDateTime:
 1508               	.LFB35:
1065:main.c        **** {
 1509               		.loc 3 1065 0
 1510               		.cfi_startproc
 1511 054a CF93      		push r28
 1512               	.LCFI33:
 1513               		.cfi_def_cfa_offset 3
 1514               		.cfi_offset 28, -2
 1515 054c DF93      		push r29
 1516               	.LCFI34:
 1517               		.cfi_def_cfa_offset 4
 1518               		.cfi_offset 29, -3
 1519 054e CDB7      		in r28,__SP_L__
 1520 0550 DEB7      		in r29,__SP_H__
 1521               	.LCFI35:
 1522               		.cfi_def_cfa_register 28
 1523 0552 2D97      		sbiw r28,13
 1524               	.LCFI36:
 1525               		.cfi_def_cfa_offset 17
 1526 0554 0FB6      		in __tmp_reg__,__SREG__
 1527 0556 F894      		cli
 1528 0558 DEBF      		out __SP_H__,r29
 1529 055a 0FBE      		out __SREG__,__tmp_reg__
 1530 055c CDBF      		out __SP_L__,r28
 1531               	/* prologue: function */
 1532               	/* frame size = 13 */
 1533               	/* stack size = 15 */
 1534               	.L__stack_usage = 15
1066:main.c        ****     uint8_t numDaysInMonth[] = {0,31,28,31,30,31,30,31,31,30,31,30,31};
 1535               		.loc 3 1066 0
 1536 055e 8DE0      		ldi r24,lo8(13)
 1537 0560 E0E0      		ldi r30,lo8(.LC0)
 1538 0562 F0E0      		ldi r31,hi8(.LC0)
 1539 0564 DE01      		movw r26,r28
 1540 0566 1196      		adiw r26,1
 1541               		0:
 1542 0568 0190      		ld r0,Z+
 1543 056a 0D92      		st X+,r0
 1544 056c 8A95      		dec r24
 1545 056e 01F4      		brne 0b
1068:main.c        ****     if( numDaysInMonth[2] == 28 && isLeapYear() )
 1546               		.loc 3 1068 0
 1547 0570 8B81      		ldd r24,Y+3
 1548 0572 8C31      		cpi r24,lo8(28)
 1549 0574 01F4      		brne .L58
1068:main.c        ****     if( numDaysInMonth[2] == 28 && isLeapYear() )
 1550               		.loc 3 1068 0 is_stmt 0 discriminator 1
 1551 0576 0E94 0000 		call isLeapYear
 1552               	.LVL120:
 1553 057a 8823      		tst r24
 1554 057c 01F0      		breq .L59
1070:main.c        ****         numDaysInMonth[2] = 29;
 1555               		.loc 3 1070 0 is_stmt 1
 1556 057e 8DE1      		ldi r24,lo8(29)
 1557 0580 00C0      		rjmp .L68
 1558               	.L58:
1072:main.c        ****     else if( numDaysInMonth[2] == 29 )
 1559               		.loc 3 1072 0
 1560 0582 8D31      		cpi r24,lo8(29)
 1561 0584 01F4      		brne .L59
1074:main.c        ****         numDaysInMonth[2] = 28;
 1562               		.loc 3 1074 0
 1563 0586 8CE1      		ldi r24,lo8(28)
 1564               	.L68:
 1565 0588 8B83      		std Y+3,r24
 1566               	.L59:
1078:main.c        ****     if( seconds > 59 )
 1567               		.loc 3 1078 0
 1568 058a 8091 0000 		lds r24,seconds
 1569 058e 8C33      		cpi r24,lo8(60)
 1570 0590 00F0      		brlo .L60
1080:main.c        ****         minutes++;		// increment minutes
 1571               		.loc 3 1080 0
 1572 0592 8091 0000 		lds r24,minutes
 1573 0596 8F5F      		subi r24,lo8(-(1))
 1574 0598 8093 0000 		sts minutes,r24
1081:main.c        ****         seconds = 0;	// reset seconds
 1575               		.loc 3 1081 0
 1576 059c 1092 0000 		sts seconds,__zero_reg__
 1577               	.L60:
1084:main.c        ****     if( minutes > 59 )
 1578               		.loc 3 1084 0
 1579 05a0 8091 0000 		lds r24,minutes
 1580 05a4 8C33      		cpi r24,lo8(60)
 1581 05a6 00F0      		brlo .L61
1086:main.c        ****         hours++;		// increment hours
 1582               		.loc 3 1086 0
 1583 05a8 8091 0000 		lds r24,hours
 1584 05ac 8F5F      		subi r24,lo8(-(1))
 1585 05ae 8093 0000 		sts hours,r24
1087:main.c        ****         minutes = 0; 	// reset minutes
 1586               		.loc 3 1087 0
 1587 05b2 1092 0000 		sts minutes,__zero_reg__
 1588               	.L61:
1090:main.c        ****     if( hours > 23 )
 1589               		.loc 3 1090 0
 1590 05b6 8091 0000 		lds r24,hours
 1591 05ba 8831      		cpi r24,lo8(24)
 1592 05bc 00F0      		brlo .L62
1092:main.c        ****         day++;          // increment day
 1593               		.loc 3 1092 0
 1594 05be 8091 0000 		lds r24,day
 1595 05c2 8F5F      		subi r24,lo8(-(1))
 1596 05c4 8093 0000 		sts day,r24
1093:main.c        ****         hours = 0;		// reset hours
 1597               		.loc 3 1093 0
 1598 05c8 1092 0000 		sts hours,__zero_reg__
 1599               	.L62:
1096:main.c        ****     if( day > numDaysInMonth[ month ] )
 1600               		.loc 3 1096 0
 1601 05cc 8091 0000 		lds r24,month
 1602 05d0 FE01      		movw r30,r28
 1603 05d2 E80F      		add r30,r24
 1604 05d4 F11D      		adc r31,__zero_reg__
 1605 05d6 2091 0000 		lds r18,day
 1606 05da 9181      		ldd r25,Z+1
 1607 05dc 9217      		cp r25,r18
 1608 05de 00F4      		brsh .L63
1098:main.c        ****         month++;        // increment the month
 1609               		.loc 3 1098 0
 1610 05e0 8F5F      		subi r24,lo8(-(1))
 1611 05e2 8093 0000 		sts month,r24
1099:main.c        ****         day = 1;        // reset the day counter to the first
 1612               		.loc 3 1099 0
 1613 05e6 81E0      		ldi r24,lo8(1)
 1614 05e8 8093 0000 		sts day,r24
 1615               	.L63:
1102:main.c        ****     if( month > 12 )
 1616               		.loc 3 1102 0
 1617 05ec 8091 0000 		lds r24,month
 1618 05f0 8D30      		cpi r24,lo8(13)
 1619 05f2 00F0      		brlo .L57
1104:main.c        ****         year++;         // increment the year
 1620               		.loc 3 1104 0
 1621 05f4 8091 0000 		lds r24,year
 1622 05f8 9091 0000 		lds r25,year+1
 1623 05fc 0196      		adiw r24,1
 1624 05fe 9093 0000 		sts year+1,r25
 1625 0602 8093 0000 		sts year,r24
1105:main.c        ****         month = 1;      // reset the month to january
 1626               		.loc 3 1105 0
 1627 0606 81E0      		ldi r24,lo8(1)
 1628 0608 8093 0000 		sts month,r24
 1629               	.L57:
 1630               	/* epilogue start */
1109:main.c        **** }
 1631               		.loc 3 1109 0
 1632 060c 2D96      		adiw r28,13
 1633 060e 0FB6      		in __tmp_reg__,__SREG__
 1634 0610 F894      		cli
 1635 0612 DEBF      		out __SP_H__,r29
 1636 0614 0FBE      		out __SREG__,__tmp_reg__
 1637 0616 CDBF      		out __SP_L__,r28
 1638 0618 DF91      		pop r29
 1639 061a CF91      		pop r28
 1640 061c 0895      		ret
 1641               		.cfi_endproc
 1642               	.LFE35:
 1644               	.global	dayOfWeek
 1646               	dayOfWeek:
 1647               	.LFB38:
1179:main.c        **** 
1180:main.c        **** 
1181:main.c        **** 
1182:main.c        **** 
1183:main.c        **** uint8_t dayOfWeek(uint8_t day, uint8_t month, uint16_t year)
1184:main.c        **** {
 1648               		.loc 3 1184 0
 1649               		.cfi_startproc
 1650               	.LVL121:
 1651 061e CF93      		push r28
 1652               	.LCFI37:
 1653               		.cfi_def_cfa_offset 3
 1654               		.cfi_offset 28, -2
 1655 0620 DF93      		push r29
 1656               	.LCFI38:
 1657               		.cfi_def_cfa_offset 4
 1658               		.cfi_offset 29, -3
 1659               	/* prologue: function */
 1660               	/* frame size = 0 */
 1661               	/* stack size = 2 */
 1662               	.L__stack_usage = 2
 1663 0622 D82F      		mov r29,r24
 1664 0624 C62F      		mov r28,r22
 1665 0626 FA01      		movw r30,r20
1185:main.c        ****    // http://en.wikipedia.org/wiki/Zeller%27s_congruence
1186:main.c        ****    // returns 0 for monday thru 6 for sunday.
1187:main.c        ****    
1188:main.c        **** 	if( month < 3 ){
 1666               		.loc 3 1188 0
 1667 0628 6330      		cpi r22,lo8(3)
 1668 062a 00F4      		brsh .L70
1189:main.c        **** 		month += 12;
 1669               		.loc 3 1189 0
 1670 062c C45F      		subi r28,lo8(-(12))
 1671               	.LVL122:
1190:main.c        **** 		year--;
 1672               		.loc 3 1190 0
 1673 062e 3197      		sbiw r30,1
 1674               	.LVL123:
 1675               	.L70:
1191:main.c        ****    }
1192:main.c        ****    return ( ( 13 * month + 3 ) / 5 + day + year + ( year / 4 ) - ( year / 100 ) + ( year / 400 ) ) 
 1676               		.loc 3 1192 0
 1677 0630 9F01      		movw r18,r30
 1678 0632 3695      		lsr r19
 1679 0634 2795      		ror r18
 1680 0636 3695      		lsr r19
 1681 0638 2795      		ror r18
 1682               	.LVL124:
 1683 063a CF01      		movw r24,r30
 1684 063c 60E9      		ldi r22,lo8(-112)
 1685 063e 71E0      		ldi r23,lo8(1)
 1686 0640 0E94 0000 		call __udivmodhi4
 1687 0644 260F      		add r18,r22
 1688 0646 371F      		adc r19,r23
 1689 0648 2E0F      		add r18,r30
 1690 064a 3F1F      		adc r19,r31
 1691 064c CF01      		movw r24,r30
 1692 064e 64E6      		ldi r22,lo8(100)
 1693 0650 70E0      		ldi r23,0
 1694 0652 0E94 0000 		call __udivmodhi4
 1695 0656 261B      		sub r18,r22
 1696 0658 370B      		sbc r19,r23
 1697 065a 4DE0      		ldi r20,lo8(13)
 1698 065c C49F      		mul r28,r20
 1699 065e C001      		movw r24,r0
 1700 0660 1124      		clr __zero_reg__
 1701 0662 0396      		adiw r24,3
 1702 0664 65E0      		ldi r22,lo8(5)
 1703 0666 70E0      		ldi r23,0
 1704 0668 0E94 0000 		call __divmodhi4
 1705 066c 6D0F      		add r22,r29
 1706 066e 711D      		adc r23,__zero_reg__
 1707 0670 260F      		add r18,r22
 1708 0672 371F      		adc r19,r23
 1709 0674 C901      		movw r24,r18
 1710 0676 67E0      		ldi r22,lo8(7)
 1711 0678 70E0      		ldi r23,0
 1712 067a 0E94 0000 		call __udivmodhi4
 1713               	/* epilogue start */
1193:main.c        **** }
 1714               		.loc 3 1193 0
 1715 067e DF91      		pop r29
 1716               	.LVL125:
 1717 0680 CF91      		pop r28
 1718               	.LVL126:
 1719 0682 0895      		ret
 1720               		.cfi_endproc
 1721               	.LFE38:
 1723               	.global	readTemperature
 1725               	readTemperature:
 1726               	.LFB39:
1194:main.c        **** 
1195:main.c        **** 
1196:main.c        **** 
1197:main.c        **** 
1198:main.c        **** double readTemperature( void )
1199:main.c        **** {
 1727               		.loc 3 1199 0
 1728               		.cfi_startproc
 1729               	/* prologue: function */
 1730               	/* frame size = 0 */
 1731               	/* stack size = 0 */
 1732               	.L__stack_usage = 0
1200:main.c        ****     celsiusTemperature = ds18b20_gettemp();
 1733               		.loc 3 1200 0
 1734 0684 0E94 0000 		call ds18b20_gettemp
 1735               	.LVL127:
 1736 0688 9B01      		movw r18,r22
 1737 068a 462F      		mov r20,r22
 1738 068c 532F      		mov r21,r19
 1739 068e 682F      		mov r22,r24
 1740 0690 792F      		mov r23,r25
 1741 0692 4093 0000 		sts celsiusTemperature,r20
 1742 0696 5093 0000 		sts celsiusTemperature+1,r21
 1743 069a 6093 0000 		sts celsiusTemperature+2,r22
 1744 069e 7093 0000 		sts celsiusTemperature+3,r23
1201:main.c        ****     
1202:main.c        ****     return celsiusTemperature;
1203:main.c        **** }
 1745               		.loc 3 1203 0
 1746 06a2 622F      		mov r22,r18
 1747 06a4 732F      		mov r23,r19
 1748 06a6 0895      		ret
 1749               		.cfi_endproc
 1750               	.LFE39:
 1752               	.global	updateBoostConverter
 1754               	updateBoostConverter:
 1755               	.LFB40:
1204:main.c        **** 
1205:main.c        **** 
1206:main.c        **** 
1207:main.c        **** 
1208:main.c        **** void updateBoostConverter( void )
1209:main.c        **** {
 1756               		.loc 3 1209 0
 1757               		.cfi_startproc
 1758               	/* prologue: function */
 1759               	/* frame size = 0 */
 1760               	/* stack size = 0 */
 1761               	.L__stack_usage = 0
1210:main.c        **** 
1211:main.c        ****     // The input to HV_FEEDBACK is a voltage divider with 470k0 and 4k7 resistors.
1212:main.c        ****     // Therefore the voltage present will be about 10% of the boost converter output.
1213:main.c        ****     // 175 V DC on the boost converter will be about 1.75 V DC input to the ADC
1214:main.c        ****     
1215:main.c        ****     // The ADC results are continuously stored as 8-bit results in array location adc_raw[1]
1216:main.c        ****     // 5 v / 8 bits = ~0.019685 V/count, or 50.8 counts/V
1217:main.c        ****     
1218:main.c        ****     // ex. 50 V on the boost converter is 0.5 V to the ADC.  0.5 V in counts is 25.4
1219:main.c        ****     //    175 V on the boost converter is 1.75V to the ADC.  1.75V in counts is 88.9
1220:main.c        ****     
1221:main.c        ****     uint16_t myVoltage = adc_raw[1];	// HV_FEEDBACK
 1762               		.loc 3 1221 0
 1763 06a8 8091 0000 		lds r24,adc_raw+1
 1764               	.LVL128:
1222:main.c        ****     
1223:main.c        **** 	if( myVoltage > 89 )
 1765               		.loc 3 1223 0
 1766 06ac 8A35      		cpi r24,lo8(90)
 1767 06ae 00F0      		brlo .L73
1224:main.c        **** 	{
1225:main.c        **** 		boostConverterPwm = boostLowPwm;
 1768               		.loc 3 1225 0
 1769 06b0 8091 0000 		lds r24,boostLowPwm
 1770               	.LVL129:
 1771 06b4 00C0      		rjmp .L75
 1772               	.LVL130:
 1773               	.L73:
1226:main.c        **** 		//boostConverterPwm--;
1227:main.c        **** 	}
1228:main.c        **** 	else 
1229:main.c        **** 	{
1230:main.c        **** 		boostConverterPwm = boostHighPwm;
 1774               		.loc 3 1230 0
 1775 06b6 8091 0000 		lds r24,boostHighPwm
 1776               	.LVL131:
 1777               	.L75:
 1778 06ba 8093 0000 		sts boostConverterPwm,r24
1231:main.c        **** 		//boostConverterPwm++;
1232:main.c        **** 	}
1233:main.c        **** 	
1234:main.c        **** 	OCR0A = boostConverterPwm;        
 1779               		.loc 3 1234 0
 1780 06be 8091 0000 		lds r24,boostConverterPwm
 1781 06c2 87BD      		out 0x27,r24
 1782 06c4 0895      		ret
 1783               		.cfi_endproc
 1784               	.LFE40:
 1786               	.global	__divsf3
 1787               	.global	updateTemperatureFilter
 1789               	updateTemperatureFilter:
 1790               	.LFB41:
1235:main.c        **** 
1236:main.c        **** }
1237:main.c        **** 
1238:main.c        **** 
1239:main.c        **** 
1240:main.c        **** 
1241:main.c        **** 
1242:main.c        **** 
1243:main.c        **** void updateTemperatureFilter( uint8_t moduloSeconds )
1244:main.c        **** {
 1791               		.loc 3 1244 0
 1792               		.cfi_startproc
 1793               	.LVL132:
 1794 06c6 0F93      		push r16
 1795               	.LCFI39:
 1796               		.cfi_def_cfa_offset 3
 1797               		.cfi_offset 16, -2
 1798 06c8 1F93      		push r17
 1799               	.LCFI40:
 1800               		.cfi_def_cfa_offset 4
 1801               		.cfi_offset 17, -3
 1802 06ca CF93      		push r28
 1803               	.LCFI41:
 1804               		.cfi_def_cfa_offset 5
 1805               		.cfi_offset 28, -4
 1806 06cc DF93      		push r29
 1807               	.LCFI42:
 1808               		.cfi_def_cfa_offset 6
 1809               		.cfi_offset 29, -5
 1810               	/* prologue: function */
 1811               	/* frame size = 0 */
 1812               	/* stack size = 4 */
 1813               	.L__stack_usage = 4
 1814 06ce 682F      		mov r22,r24
1245:main.c        **** 	if( seconds % moduloSeconds == 0 )
 1815               		.loc 3 1245 0
 1816 06d0 8091 0000 		lds r24,seconds
 1817               	.LVL133:
 1818 06d4 0E94 0000 		call __udivmodqi4
 1819 06d8 9111      		cpse r25,__zero_reg__
 1820 06da 00C0      		rjmp .L76
 1821 06dc 00E0      		ldi r16,lo8(movingAverageArray)
 1822 06de 10E0      		ldi r17,hi8(movingAverageArray)
 1823 06e0 C0E0      		ldi r28,0
 1824 06e2 D0E0      		ldi r29,0
 1825               	.LVL134:
 1826               	.L80:
 1827               	.LBB219:
1246:main.c        ****     {
1247:main.c        ****             
1248:main.c        ****         // FIR
1249:main.c        ****             
1250:main.c        ****         for( int i = 0; i < TEMPERATURE_ARRAY_SIZE; i++ )
1251:main.c        ****         {
1252:main.c        ****             if( i < TEMPERATURE_ARRAY_SIZE - 1 )
 1828               		.loc 3 1252 0
 1829 06e4 C530      		cpi r28,5
 1830 06e6 D105      		cpc r29,__zero_reg__
 1831 06e8 01F0      		breq .L78
1253:main.c        ****             {
1254:main.c        ****                 movingAverageArray[ i ] = movingAverageArray[ i + 1 ];
 1832               		.loc 3 1254 0
 1833 06ea F801      		movw r30,r16
 1834 06ec 8481      		ldd r24,Z+4
 1835 06ee 9581      		ldd r25,Z+5
 1836 06f0 A681      		ldd r26,Z+6
 1837 06f2 B781      		ldd r27,Z+7
 1838 06f4 8083      		st Z,r24
 1839 06f6 9183      		std Z+1,r25
 1840 06f8 A283      		std Z+2,r26
 1841 06fa B383      		std Z+3,r27
 1842 06fc 00C0      		rjmp .L79
 1843               	.L78:
1255:main.c        ****             }
1256:main.c        ****             else
1257:main.c        ****             {
1258:main.c        ****                 movingAverageArray[ i ] = readTemperature();
 1844               		.loc 3 1258 0
 1845 06fe 0E94 0000 		call readTemperature
 1846               	.LVL135:
 1847 0702 6093 0000 		sts movingAverageArray+20,r22
 1848 0706 7093 0000 		sts movingAverageArray+20+1,r23
 1849 070a 8093 0000 		sts movingAverageArray+20+2,r24
 1850 070e 9093 0000 		sts movingAverageArray+20+3,r25
 1851               	.L79:
1250:main.c        ****         for( int i = 0; i < TEMPERATURE_ARRAY_SIZE; i++ )
 1852               		.loc 3 1250 0
 1853 0712 2196      		adiw r28,1
 1854               	.LVL136:
 1855 0714 0C5F      		subi r16,-4
 1856 0716 1F4F      		sbci r17,-1
 1857 0718 C630      		cpi r28,6
 1858 071a D105      		cpc r29,__zero_reg__
 1859 071c 01F4      		brne .L80
 1860               	.LVL137:
 1861 071e C0E0      		ldi r28,lo8(movingAverageArray)
 1862 0720 D0E0      		ldi r29,hi8(movingAverageArray)
 1863               	.LVL138:
 1864               	.LBE219:
1243:main.c        **** void updateTemperatureFilter( uint8_t moduloSeconds )
 1865               		.loc 3 1243 0
 1866 0722 F0E0      		ldi r31,0
 1867 0724 E0E0      		ldi r30,0
 1868 0726 80E0      		ldi r24,0
 1869 0728 90E0      		ldi r25,0
 1870               	.LVL139:
 1871               	.L81:
 1872               	.LBB220:
1259:main.c        ****             }
1260:main.c        ****                 
1261:main.c        ****         }
1262:main.c        ****             
1263:main.c        ****         arraySum = 0;
1264:main.c        ****             
1265:main.c        ****         for( int i = 0; i < TEMPERATURE_ARRAY_SIZE; i++ )
1266:main.c        ****         {
1267:main.c        ****             arraySum += movingAverageArray[ i ];
 1873               		.loc 3 1267 0 discriminator 2
 1874 072a 2991      		ld r18,Y+
 1875 072c 3991      		ld r19,Y+
 1876 072e 4991      		ld r20,Y+
 1877 0730 5991      		ld r21,Y+
 1878 0732 0F2F      		mov r16,r31
 1879 0734 1E2F      		mov r17,r30
 1880 0736 B801      		movw r22,r16
 1881 0738 0E94 0000 		call __addsf3
 1882               	.LVL140:
 1883 073c F62F      		mov r31,r22
 1884 073e E72F      		mov r30,r23
1265:main.c        ****         for( int i = 0; i < TEMPERATURE_ARRAY_SIZE; i++ )
 1885               		.loc 3 1265 0 discriminator 2
 1886 0740 20E0      		ldi r18,hi8(movingAverageArray+24)
 1887 0742 C030      		cpi r28,lo8(movingAverageArray+24)
 1888 0744 D207      		cpc r29,r18
 1889 0746 01F4      		brne .L81
 1890 0748 DF01      		movw r26,r30
 1891 074a 4B2F      		mov r20,r27
 1892 074c 5A2F      		mov r21,r26
 1893 074e 682F      		mov r22,r24
 1894 0750 792F      		mov r23,r25
 1895 0752 4093 0000 		sts arraySum,r20
 1896 0756 5093 0000 		sts arraySum+1,r21
 1897 075a 6093 0000 		sts arraySum+2,r22
 1898 075e 7093 0000 		sts arraySum+3,r23
 1899               	.LBE220:
1268:main.c        ****         }
1269:main.c        ****             
1270:main.c        **** 		averageCelsiusTemperature = arraySum / TEMPERATURE_ARRAY_SIZE;       
 1900               		.loc 3 1270 0
 1901 0762 20E0      		ldi r18,0
 1902 0764 30E0      		ldi r19,0
 1903 0766 40EC      		ldi r20,lo8(-64)
 1904 0768 50E4      		ldi r21,lo8(64)
 1905 076a EF01      		movw r28,r30
 1906 076c 6D2F      		mov r22,r29
 1907 076e 7C2F      		mov r23,r28
 1908 0770 0E94 0000 		call __divsf3
 1909               	.LVL141:
 1910 0774 6093 0000 		sts averageCelsiusTemperature,r22
 1911 0778 7093 0000 		sts averageCelsiusTemperature+1,r23
 1912 077c 8093 0000 		sts averageCelsiusTemperature+2,r24
 1913 0780 9093 0000 		sts averageCelsiusTemperature+3,r25
 1914               	.L76:
 1915               	/* epilogue start */
1271:main.c        ****     }
1272:main.c        **** }
 1916               		.loc 3 1272 0
 1917 0784 DF91      		pop r29
 1918 0786 CF91      		pop r28
 1919 0788 1F91      		pop r17
 1920 078a 0F91      		pop r16
 1921 078c 0895      		ret
 1922               		.cfi_endproc
 1923               	.LFE41:
 1925               	.global	serialPrintTemperature
 1927               	serialPrintTemperature:
 1928               	.LFB42:
1273:main.c        **** 
1274:main.c        **** 
1275:main.c        **** 
1276:main.c        **** 
1277:main.c        **** void serialPrintTemperature( void )
1278:main.c        **** {
 1929               		.loc 3 1278 0
 1930               		.cfi_startproc
 1931 078e 0F93      		push r16
 1932               	.LCFI43:
 1933               		.cfi_def_cfa_offset 3
 1934               		.cfi_offset 16, -2
 1935 0790 1F93      		push r17
 1936               	.LCFI44:
 1937               		.cfi_def_cfa_offset 4
 1938               		.cfi_offset 17, -3
 1939               	/* prologue: function */
 1940               	/* frame size = 0 */
 1941               	/* stack size = 2 */
 1942               	.L__stack_usage = 2
1279:main.c        **** 	if( celsius == 1 )
 1943               		.loc 3 1279 0
 1944 0792 8091 0000 		lds r24,celsius
 1945 0796 8130      		cpi r24,lo8(1)
 1946 0798 01F4      		brne .L85
1280:main.c        ****         {
1281:main.c        ****             //dtostrf(readTemperature(), 10, 3, printBuffer);
1282:main.c        ****             dtostrf(averageCelsiusTemperature, 10, 3, printBuffer);
 1947               		.loc 3 1282 0
 1948 079a 6091 0000 		lds r22,averageCelsiusTemperature
 1949 079e 7091 0000 		lds r23,averageCelsiusTemperature+1
 1950 07a2 8091 0000 		lds r24,averageCelsiusTemperature+2
 1951 07a6 9091 0000 		lds r25,averageCelsiusTemperature+3
 1952 07aa 00C0      		rjmp .L87
 1953               	.L85:
 1954               	.LVL142:
 1955               	.LBB221:
1283:main.c        **** 
1284:main.c        ****             //uart_puts(", Temperature: ");
1285:main.c        ****             //uart_putc( ',');
1286:main.c        ****             uart_puts(printBuffer); //uart_puts( RETURN_NEWLINE );
1287:main.c        ****         }
1288:main.c        ****         else
1289:main.c        ****         {
1290:main.c        ****             //double tempF = ( readTemperature() * 1.8 ) + 32;
1291:main.c        ****             double tempF = ( averageCelsiusTemperature * 1.8 ) + 32;
 1956               		.loc 3 1291 0
 1957 07ac 26E6      		ldi r18,lo8(102)
 1958 07ae 36E6      		ldi r19,lo8(102)
 1959 07b0 46EE      		ldi r20,lo8(-26)
 1960 07b2 5FE3      		ldi r21,lo8(63)
 1961 07b4 6091 0000 		lds r22,averageCelsiusTemperature
 1962 07b8 7091 0000 		lds r23,averageCelsiusTemperature+1
 1963 07bc 8091 0000 		lds r24,averageCelsiusTemperature+2
 1964 07c0 9091 0000 		lds r25,averageCelsiusTemperature+3
 1965 07c4 0E94 0000 		call __mulsf3
 1966               	.LVL143:
 1967 07c8 20E0      		ldi r18,0
 1968 07ca 30E0      		ldi r19,0
 1969 07cc 40E0      		ldi r20,0
 1970 07ce 52E4      		ldi r21,lo8(66)
 1971 07d0 0E94 0000 		call __addsf3
 1972               	.LVL144:
 1973               	.L87:
1292:main.c        ****             dtostrf(tempF , 10, 3, printBuffer);
 1974               		.loc 3 1292 0
 1975 07d4 00E0      		ldi r16,lo8(printBuffer)
 1976 07d6 10E0      		ldi r17,hi8(printBuffer)
 1977 07d8 23E0      		ldi r18,lo8(3)
 1978 07da 4AE0      		ldi r20,lo8(10)
 1979 07dc 0E94 0000 		call dtostrf
 1980               	.LVL145:
1293:main.c        ****             //uart_puts(", Temperature: ");
1294:main.c        ****             //uart_putc(',');
1295:main.c        ****             uart_puts(printBuffer); //uart_puts( RETURN_NEWLINE );
 1981               		.loc 3 1295 0
 1982 07e0 C801      		movw r24,r16
 1983 07e2 0E94 0000 		call uart_puts
 1984               	.LVL146:
 1985               	.LBE221:
1296:main.c        ****     }
1297:main.c        ****     
1298:main.c        ****     uart_putc( ',');
 1986               		.loc 3 1298 0
 1987 07e6 8CE2      		ldi r24,lo8(44)
 1988               	/* epilogue start */
1299:main.c        **** }
 1989               		.loc 3 1299 0
 1990 07e8 1F91      		pop r17
 1991 07ea 0F91      		pop r16
1298:main.c        ****     uart_putc( ',');
 1992               		.loc 3 1298 0
 1993 07ec 0C94 0000 		jmp uart_putc
 1994               	.LVL147:
 1995               		.cfi_endproc
 1996               	.LFE42:
 1998               	.global	serialPrintAcFrequency
 2000               	serialPrintAcFrequency:
 2001               	.LFB43:
1300:main.c        **** 
1301:main.c        **** 
1302:main.c        **** 
1303:main.c        **** 
1304:main.c        **** 
1305:main.c        **** void serialPrintAcFrequency( void )
1306:main.c        **** {
 2002               		.loc 3 1306 0
 2003               		.cfi_startproc
 2004 07f0 0F93      		push r16
 2005               	.LCFI45:
 2006               		.cfi_def_cfa_offset 3
 2007               		.cfi_offset 16, -2
 2008 07f2 1F93      		push r17
 2009               	.LCFI46:
 2010               		.cfi_def_cfa_offset 4
 2011               		.cfi_offset 17, -3
 2012               	/* prologue: function */
 2013               	/* frame size = 0 */
 2014               	/* stack size = 2 */
 2015               	.L__stack_usage = 2
1307:main.c        **** 	dtostrf(acFrequency, 10, 3, printBuffer);
 2016               		.loc 3 1307 0
 2017 07f4 6091 0000 		lds r22,acFrequency
 2018 07f8 7091 0000 		lds r23,acFrequency+1
 2019 07fc 8091 0000 		lds r24,acFrequency+2
 2020 0800 9091 0000 		lds r25,acFrequency+3
 2021 0804 00E0      		ldi r16,lo8(printBuffer)
 2022 0806 10E0      		ldi r17,hi8(printBuffer)
 2023 0808 23E0      		ldi r18,lo8(3)
 2024 080a 4AE0      		ldi r20,lo8(10)
 2025 080c 0E94 0000 		call dtostrf
 2026               	.LVL148:
1308:main.c        **** 	uart_puts(printBuffer); //uart_puts( RETURN_NEWLINE );
 2027               		.loc 3 1308 0
 2028 0810 C801      		movw r24,r16
 2029 0812 0E94 0000 		call uart_puts
 2030               	.LVL149:
1309:main.c        **** 	uart_putc( ',');	
 2031               		.loc 3 1309 0
 2032 0816 8CE2      		ldi r24,lo8(44)
 2033               	/* epilogue start */
1310:main.c        **** }
 2034               		.loc 3 1310 0
 2035 0818 1F91      		pop r17
 2036 081a 0F91      		pop r16
1309:main.c        **** 	uart_putc( ',');	
 2037               		.loc 3 1309 0
 2038 081c 0C94 0000 		jmp uart_putc
 2039               	.LVL150:
 2040               		.cfi_endproc
 2041               	.LFE43:
 2043               	.global	readEepromToVars
 2045               	readEepromToVars:
 2046               	.LFB44:
1311:main.c        **** 
1312:main.c        **** 
1313:main.c        **** 
1314:main.c        **** 
1315:main.c        **** 
1316:main.c        **** 
1317:main.c        **** 
1318:main.c        **** void readEepromToVars( void )
1319:main.c        **** {
 2047               		.loc 3 1319 0
 2048               		.cfi_startproc
 2049               	/* prologue: function */
 2050               	/* frame size = 0 */
 2051               	/* stack size = 0 */
 2052               	.L__stack_usage = 0
1320:main.c        **** 	
1321:main.c        **** 	mscal = eeprom_read_dword( &ee_mscal );	
 2053               		.loc 3 1321 0
 2054 0820 80E0      		ldi r24,lo8(ee_mscal)
 2055 0822 90E0      		ldi r25,hi8(ee_mscal)
 2056 0824 0E94 0000 		call __eerd_dword_m328p
 2057               	.LVL151:
 2058 0828 6093 0000 		sts mscal,r22
 2059 082c 7093 0000 		sts mscal+1,r23
 2060 0830 8093 0000 		sts mscal+2,r24
 2061 0834 9093 0000 		sts mscal+3,r25
1322:main.c        **** 	nixiesleepstart = eeprom_read_dword( &ee_nixiesleepstart );
 2062               		.loc 3 1322 0
 2063 0838 80E0      		ldi r24,lo8(ee_nixiesleepstart)
 2064 083a 90E0      		ldi r25,hi8(ee_nixiesleepstart)
 2065 083c 0E94 0000 		call __eerd_dword_m328p
 2066               	.LVL152:
 2067 0840 6093 0000 		sts nixiesleepstart,r22
 2068 0844 7093 0000 		sts nixiesleepstart+1,r23
 2069 0848 8093 0000 		sts nixiesleepstart+2,r24
 2070 084c 9093 0000 		sts nixiesleepstart+3,r25
1323:main.c        **** 	nixiesleepend = eeprom_read_dword( &ee_nixiesleepend );
 2071               		.loc 3 1323 0
 2072 0850 80E0      		ldi r24,lo8(ee_nixiesleepend)
 2073 0852 90E0      		ldi r25,hi8(ee_nixiesleepend)
 2074 0854 0E94 0000 		call __eerd_dword_m328p
 2075               	.LVL153:
 2076 0858 6093 0000 		sts nixiesleepend,r22
 2077 085c 7093 0000 		sts nixiesleepend+1,r23
 2078 0860 8093 0000 		sts nixiesleepend+2,r24
 2079 0864 9093 0000 		sts nixiesleepend+3,r25
1324:main.c        **** 	
1325:main.c        **** 	miltime = eeprom_read_byte( &ee_miltime );
 2080               		.loc 3 1325 0
 2081 0868 80E0      		ldi r24,lo8(ee_miltime)
 2082 086a 90E0      		ldi r25,hi8(ee_miltime)
 2083 086c 0E94 0000 		call __eerd_byte_m328p
 2084               	.LVL154:
 2085 0870 8093 0000 		sts miltime,r24
1326:main.c        **** 	showtherm = eeprom_read_byte( &ee_showtherm );
 2086               		.loc 3 1326 0
 2087 0874 80E0      		ldi r24,lo8(ee_showtherm)
 2088 0876 90E0      		ldi r25,hi8(ee_showtherm)
 2089 0878 0E94 0000 		call __eerd_byte_m328p
 2090               	.LVL155:
 2091 087c 8093 0000 		sts showtherm,r24
1327:main.c        **** 	showfreq = eeprom_read_byte( &ee_showfreq );
 2092               		.loc 3 1327 0
 2093 0880 80E0      		ldi r24,lo8(ee_showfreq)
 2094 0882 90E0      		ldi r25,hi8(ee_showfreq)
 2095 0884 0E94 0000 		call __eerd_byte_m328p
 2096               	.LVL156:
 2097 0888 8093 0000 		sts showfreq,r24
1328:main.c        **** 	showdate = eeprom_read_byte( &ee_showdate );
 2098               		.loc 3 1328 0
 2099 088c 80E0      		ldi r24,lo8(ee_showdate)
 2100 088e 90E0      		ldi r25,hi8(ee_showdate)
 2101 0890 0E94 0000 		call __eerd_byte_m328p
 2102               	.LVL157:
 2103 0894 8093 0000 		sts showdate,r24
1329:main.c        **** 	celsius = eeprom_read_byte( &ee_celsius );
 2104               		.loc 3 1329 0
 2105 0898 80E0      		ldi r24,lo8(ee_celsius)
 2106 089a 90E0      		ldi r25,hi8(ee_celsius)
 2107 089c 0E94 0000 		call __eerd_byte_m328p
 2108               	.LVL158:
 2109 08a0 8093 0000 		sts celsius,r24
1330:main.c        **** 	doecho = eeprom_read_byte( &ee_doecho );
 2110               		.loc 3 1330 0
 2111 08a4 80E0      		ldi r24,lo8(ee_doecho)
 2112 08a6 90E0      		ldi r25,hi8(ee_doecho)
 2113 08a8 0E94 0000 		call __eerd_byte_m328p
 2114               	.LVL159:
 2115 08ac 8093 0000 		sts doecho,r24
1331:main.c        **** 	acclock = eeprom_read_byte( &ee_acclock );
 2116               		.loc 3 1331 0
 2117 08b0 80E0      		ldi r24,lo8(ee_acclock)
 2118 08b2 90E0      		ldi r25,hi8(ee_acclock)
 2119 08b4 0E94 0000 		call __eerd_byte_m328p
 2120               	.LVL160:
 2121 08b8 8093 0000 		sts acclock,r24
1332:main.c        **** 	xtalisfast = eeprom_read_byte( &ee_xtalisfast );
 2122               		.loc 3 1332 0
 2123 08bc 80E0      		ldi r24,lo8(ee_xtalisfast)
 2124 08be 90E0      		ldi r25,hi8(ee_xtalisfast)
 2125 08c0 0E94 0000 		call __eerd_byte_m328p
 2126               	.LVL161:
 2127 08c4 8093 0000 		sts xtalisfast,r24
1333:main.c        **** 	toggleled = eeprom_read_byte( &ee_toggleled );
 2128               		.loc 3 1333 0
 2129 08c8 80E0      		ldi r24,lo8(ee_toggleled)
 2130 08ca 90E0      		ldi r25,hi8(ee_toggleled)
 2131 08cc 0E94 0000 		call __eerd_byte_m328p
 2132               	.LVL162:
 2133 08d0 8093 0000 		sts toggleled,r24
 2134 08d4 0895      		ret
 2135               		.cfi_endproc
 2136               	.LFE44:
 2138               	.global	updateVarsToEeprom
 2140               	updateVarsToEeprom:
 2141               	.LFB45:
1334:main.c        **** 
1335:main.c        **** }
1336:main.c        **** 
1337:main.c        **** 
1338:main.c        **** 
1339:main.c        **** 
1340:main.c        **** 
1341:main.c        **** // Update will only write data to eeprom if the new value is different from the stored value.
1342:main.c        **** void updateVarsToEeprom( void )
1343:main.c        **** {
 2142               		.loc 3 1343 0
 2143               		.cfi_startproc
 2144               	/* prologue: function */
 2145               	/* frame size = 0 */
 2146               	/* stack size = 0 */
 2147               	.L__stack_usage = 0
1344:main.c        **** 
1345:main.c        **** 	eeprom_update_dword( &ee_mscal, mscal );
 2148               		.loc 3 1345 0
 2149 08d6 4091 0000 		lds r20,mscal
 2150 08da 5091 0000 		lds r21,mscal+1
 2151 08de 6091 0000 		lds r22,mscal+2
 2152 08e2 7091 0000 		lds r23,mscal+3
 2153 08e6 80E0      		ldi r24,lo8(ee_mscal)
 2154 08e8 90E0      		ldi r25,hi8(ee_mscal)
 2155 08ea 0E94 0000 		call __eeupd_dword_m328p
 2156               	.LVL163:
1346:main.c        **** 	eeprom_update_dword( &ee_nixiesleepstart, nixiesleepstart );
 2157               		.loc 3 1346 0
 2158 08ee 4091 0000 		lds r20,nixiesleepstart
 2159 08f2 5091 0000 		lds r21,nixiesleepstart+1
 2160 08f6 6091 0000 		lds r22,nixiesleepstart+2
 2161 08fa 7091 0000 		lds r23,nixiesleepstart+3
 2162 08fe 80E0      		ldi r24,lo8(ee_nixiesleepstart)
 2163 0900 90E0      		ldi r25,hi8(ee_nixiesleepstart)
 2164 0902 0E94 0000 		call __eeupd_dword_m328p
 2165               	.LVL164:
1347:main.c        **** 	eeprom_update_dword( &ee_nixiesleepend, nixiesleepend );
 2166               		.loc 3 1347 0
 2167 0906 4091 0000 		lds r20,nixiesleepend
 2168 090a 5091 0000 		lds r21,nixiesleepend+1
 2169 090e 6091 0000 		lds r22,nixiesleepend+2
 2170 0912 7091 0000 		lds r23,nixiesleepend+3
 2171 0916 80E0      		ldi r24,lo8(ee_nixiesleepend)
 2172 0918 90E0      		ldi r25,hi8(ee_nixiesleepend)
 2173 091a 0E94 0000 		call __eeupd_dword_m328p
 2174               	.LVL165:
1348:main.c        **** 	
1349:main.c        **** 	eeprom_update_byte( &ee_miltime, miltime );
 2175               		.loc 3 1349 0
 2176 091e 6091 0000 		lds r22,miltime
 2177 0922 80E0      		ldi r24,lo8(ee_miltime)
 2178 0924 90E0      		ldi r25,hi8(ee_miltime)
 2179 0926 0E94 0000 		call __eeupd_byte_m328p
 2180               	.LVL166:
1350:main.c        **** 	eeprom_update_byte( &ee_showtherm, showtherm );
 2181               		.loc 3 1350 0
 2182 092a 6091 0000 		lds r22,showtherm
 2183 092e 80E0      		ldi r24,lo8(ee_showtherm)
 2184 0930 90E0      		ldi r25,hi8(ee_showtherm)
 2185 0932 0E94 0000 		call __eeupd_byte_m328p
 2186               	.LVL167:
1351:main.c        **** 	eeprom_update_byte( &ee_showfreq, showfreq );
 2187               		.loc 3 1351 0
 2188 0936 6091 0000 		lds r22,showfreq
 2189 093a 80E0      		ldi r24,lo8(ee_showfreq)
 2190 093c 90E0      		ldi r25,hi8(ee_showfreq)
 2191 093e 0E94 0000 		call __eeupd_byte_m328p
 2192               	.LVL168:
1352:main.c        **** 	eeprom_update_byte( &ee_showdate, showdate );
 2193               		.loc 3 1352 0
 2194 0942 6091 0000 		lds r22,showdate
 2195 0946 80E0      		ldi r24,lo8(ee_showdate)
 2196 0948 90E0      		ldi r25,hi8(ee_showdate)
 2197 094a 0E94 0000 		call __eeupd_byte_m328p
 2198               	.LVL169:
1353:main.c        **** 	eeprom_update_byte( &ee_celsius, celsius );
 2199               		.loc 3 1353 0
 2200 094e 6091 0000 		lds r22,celsius
 2201 0952 80E0      		ldi r24,lo8(ee_celsius)
 2202 0954 90E0      		ldi r25,hi8(ee_celsius)
 2203 0956 0E94 0000 		call __eeupd_byte_m328p
 2204               	.LVL170:
1354:main.c        **** 	eeprom_update_byte( &ee_doecho, doecho );
 2205               		.loc 3 1354 0
 2206 095a 6091 0000 		lds r22,doecho
 2207 095e 80E0      		ldi r24,lo8(ee_doecho)
 2208 0960 90E0      		ldi r25,hi8(ee_doecho)
 2209 0962 0E94 0000 		call __eeupd_byte_m328p
 2210               	.LVL171:
1355:main.c        **** 	eeprom_update_byte( &ee_acclock, acclock );
 2211               		.loc 3 1355 0
 2212 0966 6091 0000 		lds r22,acclock
 2213 096a 80E0      		ldi r24,lo8(ee_acclock)
 2214 096c 90E0      		ldi r25,hi8(ee_acclock)
 2215 096e 0E94 0000 		call __eeupd_byte_m328p
 2216               	.LVL172:
1356:main.c        **** 	eeprom_update_byte( &ee_xtalisfast, xtalisfast );
 2217               		.loc 3 1356 0
 2218 0972 6091 0000 		lds r22,xtalisfast
 2219 0976 80E0      		ldi r24,lo8(ee_xtalisfast)
 2220 0978 90E0      		ldi r25,hi8(ee_xtalisfast)
 2221 097a 0E94 0000 		call __eeupd_byte_m328p
 2222               	.LVL173:
1357:main.c        **** 	eeprom_update_byte( &ee_toggleled, toggleled );
 2223               		.loc 3 1357 0
 2224 097e 6091 0000 		lds r22,toggleled
 2225 0982 80E0      		ldi r24,lo8(ee_toggleled)
 2226 0984 90E0      		ldi r25,hi8(ee_toggleled)
 2227 0986 0C94 0000 		jmp __eeupd_byte_m328p
 2228               	.LVL174:
 2229               		.cfi_endproc
 2230               	.LFE45:
 2232               		.section	.rodata.str1.1
 2233               	.LC13:
 2234 018a 686F 7572 		.string	"hours"
 2234      7300 
 2235               	.LC14:
 2236 0190 3F00      		.string	"?"
 2237               	.LC15:
 2238 0192 486F 7572 		.string	"Hours"
 2238      7300 
 2239               	.LC16:
 2240 0198 3D00      		.string	"="
 2241               	.LC17:
 2242 019a 6D69 6E75 		.string	"minutes"
 2242      7465 7300 
 2243               	.LC18:
 2244 01a2 4D69 6E75 		.string	"Minutes"
 2244      7465 7300 
 2245               	.LC19:
 2246 01aa 7365 636F 		.string	"seconds"
 2246      6E64 7300 
 2247               	.LC20:
 2248 01b2 5365 636F 		.string	"Seconds"
 2248      6E64 7300 
 2249               	.LC21:
 2250 01ba 6D73 6361 		.string	"mscal"
 2250      6C00 
 2251               	.LC22:
 2252 01c0 6D53 2043 		.string	"mS Calibration"
 2252      616C 6962 
 2252      7261 7469 
 2252      6F6E 00
 2253               	.LC23:
 2254 01cf 6D69 6C74 		.string	"miltime"
 2254      696D 6500 
 2255               	.LC24:
 2256 01d7 4D49 4C20 		.string	"MIL Time"
 2256      5469 6D65 
 2256      00
 2257               	.LC25:
 2258 01e0 7965 6172 		.string	"year"
 2258      00
 2259               	.LC26:
 2260 01e5 5965 6172 		.string	"Year"
 2260      00
 2261               	.LC27:
 2262 01ea 6D6F 6E74 		.string	"month"
 2262      6800 
 2263               	.LC28:
 2264 01f0 4D6F 6E74 		.string	"Month"
 2264      6800 
 2265               	.LC29:
 2266 01f6 6461 7900 		.string	"day"
 2267               	.LC30:
 2268 01fa 4461 7900 		.string	"Day"
 2269               	.LC31:
 2270 01fe 6365 6C73 		.string	"celsius"
 2270      6975 7300 
 2271               	.LC32:
 2272 0206 4365 6C73 		.string	"Celsius"
 2272      6975 7300 
 2273               	.LC33:
 2274 020e 646F 6563 		.string	"doecho"
 2274      686F 00
 2275               	.LC34:
 2276 0215 446F 2045 		.string	"Do Echo"
 2276      6368 6F00 
 2277               	.LC35:
 2278 021d 6163 636C 		.string	"acclock"
 2278      6F63 6B00 
 2279               	.LC36:
 2280 0225 4143 2043 		.string	"AC Clock"
 2280      6C6F 636B 
 2280      00
 2281               	.LC37:
 2282 022e 7874 616C 		.string	"xtalisfast"
 2282      6973 6661 
 2282      7374 00
 2283               	.LC38:
 2284 0239 7368 6F77 		.string	"showtherm"
 2284      7468 6572 
 2284      6D00 
 2285               	.LC39:
 2286 0243 5368 6F77 		.string	"Show Therm"
 2286      2054 6865 
 2286      726D 00
 2287               	.LC40:
 2288 024e 7368 6F77 		.string	"showfreq"
 2288      6672 6571 
 2288      00
 2289               	.LC41:
 2290 0257 5368 6F77 		.string	"Show Freq"
 2290      2046 7265 
 2290      7100 
 2291               	.LC42:
 2292 0261 7368 6F77 		.string	"showdate"
 2292      6461 7465 
 2292      00
 2293               	.LC43:
 2294 026a 5368 6F77 		.string	"Show Date"
 2294      2044 6174 
 2294      6500 
 2295               	.LC44:
 2296 0274 746F 6767 		.string	"toggleled"
 2296      6C65 6C65 
 2296      6400 
 2297               	.LC45:
 2298 027e 546F 6767 		.string	"Toggle LED"
 2298      6C65 204C 
 2298      4544 00
 2299               	.LC46:
 2300 0289 6E69 7869 		.string	"nixiesleepstart"
 2300      6573 6C65 
 2300      6570 7374 
 2300      6172 7400 
 2301               	.LC47:
 2302 0299 4E69 7869 		.string	"Nixie Sleep Start Time"
 2302      6520 536C 
 2302      6565 7020 
 2302      5374 6172 
 2302      7420 5469 
 2303               	.LC48:
 2304 02b0 6E69 7869 		.string	"nixiesleepend"
 2304      6573 6C65 
 2304      6570 656E 
 2304      6400 
 2305               	.LC49:
 2306 02be 4E69 7869 		.string	"Nixie Sleep End Time"
 2306      6520 536C 
 2306      6565 7020 
 2306      456E 6420 
 2306      5469 6D65 
 2307               	.LC50:
 2308 02d3 6765 7461 		.string	"getall"
 2308      6C6C 00
 2309               	.LC51:
 2310 02da 2C00      		.string	","
 2311               	.LC52:
 2312 02dc 6865 6C70 		.string	"help"
 2312      00
 2313               	.LC53:
 2314 02e1 436F 6D6D 		.string	"Command"
 2314      616E 6400 
 2315               	.LC54:
 2316 02e9 0909 00   		.string	"\t\t"
 2317               	.LC55:
 2318 02ec 5365 742F 		.string	"Set/Read"
 2318      5265 6164 
 2318      00
 2319               	.LC56:
 2320 02f5 0900      		.string	"\t"
 2321               	.LC57:
 2322 02f7 4C6F 7720 		.string	"Low Lim"
 2322      4C69 6D00 
 2323               	.LC58:
 2324 02ff 0909 0900 		.string	"\t\t\t"
 2325               	.LC59:
 2326 0303 4869 6768 		.string	"High Lim"
 2326      204C 696D 
 2326      00
 2327               	.LC60:
 2328 030c 3D2F 3F00 		.string	"=/?"
 2329               	.LC61:
 2330 0310 3000      		.string	"0"
 2331               	.LC62:
 2332 0312 3233 00   		.string	"23"
 2333               	.LC63:
 2334 0315 3539 00   		.string	"59"
 2335               	.LC64:
 2336 0318 3432 3934 		.string	"4294967295"
 2336      3936 3732 
 2336      3935 00
 2337               	.LC65:
 2338 0323 3100      		.string	"1"
 2339               	.LC66:
 2340 0325 3235 3235 		.string	"2525"
 2340      00
 2341               	.LC67:
 2342 032a 3132 00   		.string	"12"
 2343               	.LC68:
 2344 032d 3331 00   		.string	"31"
 2345               	.LC69:
 2346 0330 6163 6363 		.string	"accclock"
 2346      6C6F 636B 
 2346      00
 2347               	.LC70:
 2348 0339 3233 3538 		.string	"2358"
 2348      00
 2349               	.LC71:
 2350 033e 6E69 7869 		.string	"nixiesleepstart + 1"
 2350      6573 6C65 
 2350      6570 7374 
 2350      6172 7420 
 2350      2B20 3100 
 2351               	.LC72:
 2352 0352 3233 3539 		.string	"2359"
 2352      00
 2353               	.LC73:
 2354 0357 5B45 4E54 		.string	"[ENTER]"
 2354      4552 5D00 
 2355               	.LC74:
 2356 035f 7261 6D74 		.string	"ramtoeeprom"
 2356      6F65 6570 
 2356      726F 6D00 
 2357               	.LC75:
 2358 036b 706F 6B65 		.string	"poke"
 2358      00
 2359               	.LC76:
 2360 0370 7077 726F 		.string	"pwrok"
 2360      6B00 
 2361               	.LC77:
 2362 0376 6876 6665 		.string	"hvfeedback"
 2362      6564 6261 
 2362      636B 00
 2363               	.LC78:
 2364 0381 6261 7474 		.string	"battvoltage"
 2364      766F 6C74 
 2364      6167 6500 
 2365               	.LC79:
 2366 038d 7265 6374 		.string	"rectifiedac"
 2366      6966 6965 
 2366      6461 6300 
 2367               	.LC80:
 2368 0399 4545 5052 		.string	"EEPROM Storage Complete"
 2368      4F4D 2053 
 2368      746F 7261 
 2368      6765 2043 
 2368      6F6D 706C 
 2369               	.LC81:
 2370 03b1 4865 6C6C 		.string	"Hello!"
 2370      6F21 00
 2371               	.LC82:
 2372 03b8 4927 6D20 		.string	"I'm Serial Number: "
 2372      5365 7269 
 2372      616C 204E 
 2372      756D 6265 
 2372      723A 2000 
 2373               		.text
 2374               	.global	process_command
 2376               	process_command:
 2377               	.LFB27:
 526:main.c        **** {
 2378               		.loc 3 526 0
 2379               		.cfi_startproc
 2380 098a CF92      		push r12
 2381               	.LCFI47:
 2382               		.cfi_def_cfa_offset 3
 2383               		.cfi_offset 12, -2
 2384 098c DF92      		push r13
 2385               	.LCFI48:
 2386               		.cfi_def_cfa_offset 4
 2387               		.cfi_offset 13, -3
 2388 098e EF92      		push r14
 2389               	.LCFI49:
 2390               		.cfi_def_cfa_offset 5
 2391               		.cfi_offset 14, -4
 2392 0990 FF92      		push r15
 2393               	.LCFI50:
 2394               		.cfi_def_cfa_offset 6
 2395               		.cfi_offset 15, -5
 2396 0992 0F93      		push r16
 2397               	.LCFI51:
 2398               		.cfi_def_cfa_offset 7
 2399               		.cfi_offset 16, -6
 2400 0994 1F93      		push r17
 2401               	.LCFI52:
 2402               		.cfi_def_cfa_offset 8
 2403               		.cfi_offset 17, -7
 2404               	/* prologue: function */
 2405               	/* frame size = 0 */
 2406               	/* stack size = 6 */
 2407               	.L__stack_usage = 6
 527:main.c        ****     if(strcasestr(myUartString,"hours") != NULL){
 2408               		.loc 3 527 0
 2409 0996 60E0      		ldi r22,lo8(.LC13)
 2410 0998 70E0      		ldi r23,hi8(.LC13)
 2411 099a 80E0      		ldi r24,lo8(myUartString)
 2412 099c 90E0      		ldi r25,hi8(myUartString)
 2413 099e 0E94 0000 		call strcasestr
 2414               	.LVL175:
 2415 09a2 892B      		or r24,r25
 2416 09a4 01F0      		breq .L92
 528:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2417               		.loc 3 528 0
 2418 09a6 60E0      		ldi r22,lo8(.LC14)
 2419 09a8 70E0      		ldi r23,hi8(.LC14)
 2420 09aa 80E0      		ldi r24,lo8(myUartString)
 2421 09ac 90E0      		ldi r25,hi8(myUartString)
 2422 09ae 0E94 0000 		call strcasestr
 2423               	.LVL176:
 2424 09b2 892B      		or r24,r25
 2425 09b4 01F0      		breq .L93
 529:main.c        ****             print_value("Hours", hours);
 2426               		.loc 3 529 0
 2427 09b6 4091 0000 		lds r20,hours
 2428 09ba 50E0      		ldi r21,0
 2429 09bc 60E0      		ldi r22,0
 2430 09be 70E0      		ldi r23,0
 2431 09c0 80E0      		ldi r24,lo8(.LC15)
 2432 09c2 90E0      		ldi r25,hi8(.LC15)
 2433 09c4 00C0      		rjmp .L210
 2434               	.L93:
 531:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2435               		.loc 3 531 0
 2436 09c6 60E0      		ldi r22,lo8(.LC16)
 2437 09c8 70E0      		ldi r23,hi8(.LC16)
 2438 09ca 80E0      		ldi r24,lo8(myUartString)
 2439 09cc 90E0      		ldi r25,hi8(myUartString)
 2440 09ce 0E94 0000 		call strcasestr
 2441               	.LVL177:
 2442 09d2 892B      		or r24,r25
 2443 09d4 01F4      		brne .+2
 2444 09d6 00C0      		rjmp .L94
 532:main.c        ****         		if( inRange( splitString(myUartString), 23, 0 ) )
 2445               		.loc 3 532 0
 2446 09d8 80E0      		ldi r24,lo8(myUartString)
 2447 09da 90E0      		ldi r25,hi8(myUartString)
 2448 09dc 0E94 0000 		call splitString
 2449               	.LVL178:
 2450               	.LBB222:
 2451               	.LBB223:
 513:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 2452               		.loc 3 513 0
 2453 09e0 6831      		cpi r22,24
 2454 09e2 7105      		cpc r23,__zero_reg__
 2455 09e4 8105      		cpc r24,__zero_reg__
 2456 09e6 9105      		cpc r25,__zero_reg__
 2457 09e8 00F4      		brsh .+2
 2458 09ea 00C0      		rjmp .L96
 2459 09ec 00C0      		rjmp .L94
 2460               	.LVL179:
 2461               	.L92:
 2462               	.LBE223:
 2463               	.LBE222:
 538:main.c        ****     else if(strcasestr(myUartString,"minutes") != NULL){
 2464               		.loc 3 538 0
 2465 09ee 60E0      		ldi r22,lo8(.LC17)
 2466 09f0 70E0      		ldi r23,hi8(.LC17)
 2467 09f2 80E0      		ldi r24,lo8(myUartString)
 2468 09f4 90E0      		ldi r25,hi8(myUartString)
 2469 09f6 0E94 0000 		call strcasestr
 2470               	.LVL180:
 2471 09fa 892B      		or r24,r25
 2472 09fc 01F0      		breq .L98
 539:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2473               		.loc 3 539 0
 2474 09fe 60E0      		ldi r22,lo8(.LC14)
 2475 0a00 70E0      		ldi r23,hi8(.LC14)
 2476 0a02 80E0      		ldi r24,lo8(myUartString)
 2477 0a04 90E0      		ldi r25,hi8(myUartString)
 2478 0a06 0E94 0000 		call strcasestr
 2479               	.LVL181:
 2480 0a0a 892B      		or r24,r25
 2481 0a0c 01F0      		breq .L99
 540:main.c        ****             print_value("Minutes", minutes);
 2482               		.loc 3 540 0
 2483 0a0e 4091 0000 		lds r20,minutes
 2484 0a12 50E0      		ldi r21,0
 2485 0a14 60E0      		ldi r22,0
 2486 0a16 70E0      		ldi r23,0
 2487 0a18 80E0      		ldi r24,lo8(.LC18)
 2488 0a1a 90E0      		ldi r25,hi8(.LC18)
 2489 0a1c 00C0      		rjmp .L210
 2490               	.L99:
 542:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2491               		.loc 3 542 0
 2492 0a1e 60E0      		ldi r22,lo8(.LC16)
 2493 0a20 70E0      		ldi r23,hi8(.LC16)
 2494 0a22 80E0      		ldi r24,lo8(myUartString)
 2495 0a24 90E0      		ldi r25,hi8(myUartString)
 2496 0a26 0E94 0000 		call strcasestr
 2497               	.LVL182:
 2498 0a2a 892B      		or r24,r25
 2499 0a2c 01F4      		brne .+2
 2500 0a2e 00C0      		rjmp .L94
 543:main.c        ****         		if( inRange( splitString(myUartString), 59, 0 ) )
 2501               		.loc 3 543 0
 2502 0a30 80E0      		ldi r24,lo8(myUartString)
 2503 0a32 90E0      		ldi r25,hi8(myUartString)
 2504 0a34 0E94 0000 		call splitString
 2505               	.LVL183:
 2506               	.LBB224:
 2507               	.LBB225:
 513:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 2508               		.loc 3 513 0
 2509 0a38 6C33      		cpi r22,60
 2510 0a3a 7105      		cpc r23,__zero_reg__
 2511 0a3c 8105      		cpc r24,__zero_reg__
 2512 0a3e 9105      		cpc r25,__zero_reg__
 2513 0a40 00F4      		brsh .+2
 2514 0a42 00C0      		rjmp .L100
 2515 0a44 00C0      		rjmp .L94
 2516               	.LVL184:
 2517               	.L98:
 2518               	.LBE225:
 2519               	.LBE224:
 549:main.c        ****     else if(strcasestr(myUartString,"seconds") != NULL){
 2520               		.loc 3 549 0
 2521 0a46 60E0      		ldi r22,lo8(.LC19)
 2522 0a48 70E0      		ldi r23,hi8(.LC19)
 2523 0a4a 80E0      		ldi r24,lo8(myUartString)
 2524 0a4c 90E0      		ldi r25,hi8(myUartString)
 2525 0a4e 0E94 0000 		call strcasestr
 2526               	.LVL185:
 2527 0a52 892B      		or r24,r25
 2528 0a54 01F0      		breq .L101
 550:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2529               		.loc 3 550 0
 2530 0a56 60E0      		ldi r22,lo8(.LC14)
 2531 0a58 70E0      		ldi r23,hi8(.LC14)
 2532 0a5a 80E0      		ldi r24,lo8(myUartString)
 2533 0a5c 90E0      		ldi r25,hi8(myUartString)
 2534 0a5e 0E94 0000 		call strcasestr
 2535               	.LVL186:
 2536 0a62 892B      		or r24,r25
 2537 0a64 01F0      		breq .L102
 551:main.c        ****             print_value("Seconds", seconds);
 2538               		.loc 3 551 0
 2539 0a66 4091 0000 		lds r20,seconds
 2540 0a6a 50E0      		ldi r21,0
 2541 0a6c 60E0      		ldi r22,0
 2542 0a6e 70E0      		ldi r23,0
 2543 0a70 80E0      		ldi r24,lo8(.LC20)
 2544 0a72 90E0      		ldi r25,hi8(.LC20)
 2545 0a74 00C0      		rjmp .L210
 2546               	.L102:
 553:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2547               		.loc 3 553 0
 2548 0a76 60E0      		ldi r22,lo8(.LC16)
 2549 0a78 70E0      		ldi r23,hi8(.LC16)
 2550 0a7a 80E0      		ldi r24,lo8(myUartString)
 2551 0a7c 90E0      		ldi r25,hi8(myUartString)
 2552 0a7e 0E94 0000 		call strcasestr
 2553               	.LVL187:
 2554 0a82 892B      		or r24,r25
 2555 0a84 01F4      		brne .+2
 2556 0a86 00C0      		rjmp .L94
 554:main.c        ****         		if( inRange( splitString(myUartString), 59, 0 ) )
 2557               		.loc 3 554 0
 2558 0a88 80E0      		ldi r24,lo8(myUartString)
 2559 0a8a 90E0      		ldi r25,hi8(myUartString)
 2560 0a8c 0E94 0000 		call splitString
 2561               	.LVL188:
 2562               	.LBB226:
 2563               	.LBB227:
 513:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 2564               		.loc 3 513 0
 2565 0a90 6C33      		cpi r22,60
 2566 0a92 7105      		cpc r23,__zero_reg__
 2567 0a94 8105      		cpc r24,__zero_reg__
 2568 0a96 9105      		cpc r25,__zero_reg__
 2569 0a98 00F4      		brsh .+2
 2570 0a9a 00C0      		rjmp .L103
 2571 0a9c 00C0      		rjmp .L94
 2572               	.LVL189:
 2573               	.L101:
 2574               	.LBE227:
 2575               	.LBE226:
 560:main.c        ****     else if(strcasestr(myUartString,"mscal") != NULL){
 2576               		.loc 3 560 0
 2577 0a9e 60E0      		ldi r22,lo8(.LC21)
 2578 0aa0 70E0      		ldi r23,hi8(.LC21)
 2579 0aa2 80E0      		ldi r24,lo8(myUartString)
 2580 0aa4 90E0      		ldi r25,hi8(myUartString)
 2581 0aa6 0E94 0000 		call strcasestr
 2582               	.LVL190:
 2583 0aaa 892B      		or r24,r25
 2584 0aac 01F0      		breq .L104
 561:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2585               		.loc 3 561 0
 2586 0aae 60E0      		ldi r22,lo8(.LC14)
 2587 0ab0 70E0      		ldi r23,hi8(.LC14)
 2588 0ab2 80E0      		ldi r24,lo8(myUartString)
 2589 0ab4 90E0      		ldi r25,hi8(myUartString)
 2590 0ab6 0E94 0000 		call strcasestr
 2591               	.LVL191:
 2592 0aba 892B      		or r24,r25
 2593 0abc 01F0      		breq .L105
 562:main.c        ****             print_value("mS Calibration", mscal);
 2594               		.loc 3 562 0
 2595 0abe 4091 0000 		lds r20,mscal
 2596 0ac2 5091 0000 		lds r21,mscal+1
 2597 0ac6 6091 0000 		lds r22,mscal+2
 2598 0aca 7091 0000 		lds r23,mscal+3
 2599 0ace 80E0      		ldi r24,lo8(.LC22)
 2600 0ad0 90E0      		ldi r25,hi8(.LC22)
 2601 0ad2 00C0      		rjmp .L210
 2602               	.L105:
 564:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2603               		.loc 3 564 0
 2604 0ad4 60E0      		ldi r22,lo8(.LC16)
 2605 0ad6 70E0      		ldi r23,hi8(.LC16)
 2606 0ad8 80E0      		ldi r24,lo8(myUartString)
 2607 0ada 90E0      		ldi r25,hi8(myUartString)
 2608 0adc 0E94 0000 		call strcasestr
 2609               	.LVL192:
 2610 0ae0 892B      		or r24,r25
 2611 0ae2 01F4      		brne .+2
 2612 0ae4 00C0      		rjmp .L94
 565:main.c        ****         		if( inRange( splitString(myUartString), 4294967295, 0 ) )
 2613               		.loc 3 565 0
 2614 0ae6 80E0      		ldi r24,lo8(myUartString)
 2615 0ae8 90E0      		ldi r25,hi8(myUartString)
 2616 0aea 0E94 0000 		call splitString
 2617               	.LVL193:
 566:main.c        ****             		mscal = splitString(myUartString);
 2618               		.loc 3 566 0
 2619 0aee 80E0      		ldi r24,lo8(myUartString)
 2620 0af0 90E0      		ldi r25,hi8(myUartString)
 2621 0af2 0E94 0000 		call splitString
 2622               	.LVL194:
 2623 0af6 6093 0000 		sts mscal,r22
 2624 0afa 7093 0000 		sts mscal+1,r23
 2625 0afe 8093 0000 		sts mscal+2,r24
 2626 0b02 9093 0000 		sts mscal+3,r25
 2627 0b06 00C0      		rjmp .L94
 2628               	.LVL195:
 2629               	.L104:
 571:main.c        ****     else if(strcasestr(myUartString,"miltime") != NULL){
 2630               		.loc 3 571 0
 2631 0b08 60E0      		ldi r22,lo8(.LC23)
 2632 0b0a 70E0      		ldi r23,hi8(.LC23)
 2633 0b0c 80E0      		ldi r24,lo8(myUartString)
 2634 0b0e 90E0      		ldi r25,hi8(myUartString)
 2635 0b10 0E94 0000 		call strcasestr
 2636               	.LVL196:
 2637 0b14 892B      		or r24,r25
 2638 0b16 01F0      		breq .L106
 572:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2639               		.loc 3 572 0
 2640 0b18 60E0      		ldi r22,lo8(.LC14)
 2641 0b1a 70E0      		ldi r23,hi8(.LC14)
 2642 0b1c 80E0      		ldi r24,lo8(myUartString)
 2643 0b1e 90E0      		ldi r25,hi8(myUartString)
 2644 0b20 0E94 0000 		call strcasestr
 2645               	.LVL197:
 2646 0b24 892B      		or r24,r25
 2647 0b26 01F0      		breq .L107
 573:main.c        ****             print_value("MIL Time", miltime);
 2648               		.loc 3 573 0
 2649 0b28 4091 0000 		lds r20,miltime
 2650 0b2c 50E0      		ldi r21,0
 2651 0b2e 60E0      		ldi r22,0
 2652 0b30 70E0      		ldi r23,0
 2653 0b32 80E0      		ldi r24,lo8(.LC24)
 2654 0b34 90E0      		ldi r25,hi8(.LC24)
 2655 0b36 00C0      		rjmp .L210
 2656               	.L107:
 575:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2657               		.loc 3 575 0
 2658 0b38 60E0      		ldi r22,lo8(.LC16)
 2659 0b3a 70E0      		ldi r23,hi8(.LC16)
 2660 0b3c 80E0      		ldi r24,lo8(myUartString)
 2661 0b3e 90E0      		ldi r25,hi8(myUartString)
 2662 0b40 0E94 0000 		call strcasestr
 2663               	.LVL198:
 2664 0b44 892B      		or r24,r25
 2665 0b46 01F4      		brne .+2
 2666 0b48 00C0      		rjmp .L94
 576:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 2667               		.loc 3 576 0
 2668 0b4a 80E0      		ldi r24,lo8(myUartString)
 2669 0b4c 90E0      		ldi r25,hi8(myUartString)
 2670 0b4e 0E94 0000 		call splitString
 2671               	.LVL199:
 2672               	.LBB228:
 2673               	.LBB229:
 513:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 2674               		.loc 3 513 0
 2675 0b52 6230      		cpi r22,2
 2676 0b54 7105      		cpc r23,__zero_reg__
 2677 0b56 8105      		cpc r24,__zero_reg__
 2678 0b58 9105      		cpc r25,__zero_reg__
 2679 0b5a 00F0      		brlo .+2
 2680 0b5c 00C0      		rjmp .L94
 2681 0b5e 00C0      		rjmp .L108
 2682               	.LVL200:
 2683               	.L106:
 2684               	.LBE229:
 2685               	.LBE228:
 582:main.c        ****     else if(strcasestr(myUartString,"year") != NULL){
 2686               		.loc 3 582 0
 2687 0b60 60E0      		ldi r22,lo8(.LC25)
 2688 0b62 70E0      		ldi r23,hi8(.LC25)
 2689 0b64 80E0      		ldi r24,lo8(myUartString)
 2690 0b66 90E0      		ldi r25,hi8(myUartString)
 2691 0b68 0E94 0000 		call strcasestr
 2692               	.LVL201:
 2693 0b6c 892B      		or r24,r25
 2694 0b6e 01F0      		breq .L109
 583:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2695               		.loc 3 583 0
 2696 0b70 60E0      		ldi r22,lo8(.LC14)
 2697 0b72 70E0      		ldi r23,hi8(.LC14)
 2698 0b74 80E0      		ldi r24,lo8(myUartString)
 2699 0b76 90E0      		ldi r25,hi8(myUartString)
 2700 0b78 0E94 0000 		call strcasestr
 2701               	.LVL202:
 2702 0b7c 892B      		or r24,r25
 2703 0b7e 01F0      		breq .L110
 584:main.c        ****             print_value("Year", year);
 2704               		.loc 3 584 0
 2705 0b80 4091 0000 		lds r20,year
 2706 0b84 5091 0000 		lds r21,year+1
 2707 0b88 60E0      		ldi r22,0
 2708 0b8a 70E0      		ldi r23,0
 2709 0b8c 80E0      		ldi r24,lo8(.LC26)
 2710 0b8e 90E0      		ldi r25,hi8(.LC26)
 2711 0b90 00C0      		rjmp .L210
 2712               	.L110:
 586:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2713               		.loc 3 586 0
 2714 0b92 60E0      		ldi r22,lo8(.LC16)
 2715 0b94 70E0      		ldi r23,hi8(.LC16)
 2716 0b96 80E0      		ldi r24,lo8(myUartString)
 2717 0b98 90E0      		ldi r25,hi8(myUartString)
 2718 0b9a 0E94 0000 		call strcasestr
 2719               	.LVL203:
 2720 0b9e 892B      		or r24,r25
 2721 0ba0 01F4      		brne .+2
 2722 0ba2 00C0      		rjmp .L94
 587:main.c        ****         		if( inRange( splitString(myUartString), 2525, 0 ) )
 2723               		.loc 3 587 0
 2724 0ba4 80E0      		ldi r24,lo8(myUartString)
 2725 0ba6 90E0      		ldi r25,hi8(myUartString)
 2726 0ba8 0E94 0000 		call splitString
 2727               	.LVL204:
 2728               	.LBB230:
 2729               	.LBB231:
 513:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 2730               		.loc 3 513 0
 2731 0bac 6E3D      		cpi r22,-34
 2732 0bae 7940      		sbci r23,9
 2733 0bb0 8105      		cpc r24,__zero_reg__
 2734 0bb2 9105      		cpc r25,__zero_reg__
 2735 0bb4 00F4      		brsh .+2
 2736 0bb6 00C0      		rjmp .L111
 2737 0bb8 00C0      		rjmp .L94
 2738               	.LVL205:
 2739               	.L109:
 2740               	.LBE231:
 2741               	.LBE230:
 593:main.c        ****     else if(strcasestr(myUartString,"month") != NULL){
 2742               		.loc 3 593 0
 2743 0bba 60E0      		ldi r22,lo8(.LC27)
 2744 0bbc 70E0      		ldi r23,hi8(.LC27)
 2745 0bbe 80E0      		ldi r24,lo8(myUartString)
 2746 0bc0 90E0      		ldi r25,hi8(myUartString)
 2747 0bc2 0E94 0000 		call strcasestr
 2748               	.LVL206:
 2749 0bc6 892B      		or r24,r25
 2750 0bc8 01F0      		breq .L112
 594:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2751               		.loc 3 594 0
 2752 0bca 60E0      		ldi r22,lo8(.LC14)
 2753 0bcc 70E0      		ldi r23,hi8(.LC14)
 2754 0bce 80E0      		ldi r24,lo8(myUartString)
 2755 0bd0 90E0      		ldi r25,hi8(myUartString)
 2756 0bd2 0E94 0000 		call strcasestr
 2757               	.LVL207:
 2758 0bd6 892B      		or r24,r25
 2759 0bd8 01F0      		breq .L113
 595:main.c        ****             print_value("Month", month);
 2760               		.loc 3 595 0
 2761 0bda 4091 0000 		lds r20,month
 2762 0bde 50E0      		ldi r21,0
 2763 0be0 60E0      		ldi r22,0
 2764 0be2 70E0      		ldi r23,0
 2765 0be4 80E0      		ldi r24,lo8(.LC28)
 2766 0be6 90E0      		ldi r25,hi8(.LC28)
 2767 0be8 00C0      		rjmp .L210
 2768               	.L113:
 597:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2769               		.loc 3 597 0
 2770 0bea 60E0      		ldi r22,lo8(.LC16)
 2771 0bec 70E0      		ldi r23,hi8(.LC16)
 2772 0bee 80E0      		ldi r24,lo8(myUartString)
 2773 0bf0 90E0      		ldi r25,hi8(myUartString)
 2774 0bf2 0E94 0000 		call strcasestr
 2775               	.LVL208:
 2776 0bf6 892B      		or r24,r25
 2777 0bf8 01F4      		brne .+2
 2778 0bfa 00C0      		rjmp .L94
 598:main.c        ****         		if( inRange( splitString(myUartString), 12, 0 ) )
 2779               		.loc 3 598 0
 2780 0bfc 80E0      		ldi r24,lo8(myUartString)
 2781 0bfe 90E0      		ldi r25,hi8(myUartString)
 2782 0c00 0E94 0000 		call splitString
 2783               	.LVL209:
 2784               	.LBB232:
 2785               	.LBB233:
 513:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 2786               		.loc 3 513 0
 2787 0c04 6D30      		cpi r22,13
 2788 0c06 7105      		cpc r23,__zero_reg__
 2789 0c08 8105      		cpc r24,__zero_reg__
 2790 0c0a 9105      		cpc r25,__zero_reg__
 2791 0c0c 00F4      		brsh .+2
 2792 0c0e 00C0      		rjmp .L114
 2793 0c10 00C0      		rjmp .L94
 2794               	.LVL210:
 2795               	.L112:
 2796               	.LBE233:
 2797               	.LBE232:
 604:main.c        ****     else if(strcasestr(myUartString,"day") != NULL){
 2798               		.loc 3 604 0
 2799 0c12 60E0      		ldi r22,lo8(.LC29)
 2800 0c14 70E0      		ldi r23,hi8(.LC29)
 2801 0c16 80E0      		ldi r24,lo8(myUartString)
 2802 0c18 90E0      		ldi r25,hi8(myUartString)
 2803 0c1a 0E94 0000 		call strcasestr
 2804               	.LVL211:
 2805 0c1e 892B      		or r24,r25
 2806 0c20 01F0      		breq .L115
 605:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2807               		.loc 3 605 0
 2808 0c22 60E0      		ldi r22,lo8(.LC14)
 2809 0c24 70E0      		ldi r23,hi8(.LC14)
 2810 0c26 80E0      		ldi r24,lo8(myUartString)
 2811 0c28 90E0      		ldi r25,hi8(myUartString)
 2812 0c2a 0E94 0000 		call strcasestr
 2813               	.LVL212:
 2814 0c2e 892B      		or r24,r25
 2815 0c30 01F0      		breq .L116
 606:main.c        ****             print_value("Day", day);
 2816               		.loc 3 606 0
 2817 0c32 4091 0000 		lds r20,day
 2818 0c36 50E0      		ldi r21,0
 2819 0c38 60E0      		ldi r22,0
 2820 0c3a 70E0      		ldi r23,0
 2821 0c3c 80E0      		ldi r24,lo8(.LC30)
 2822 0c3e 90E0      		ldi r25,hi8(.LC30)
 2823 0c40 00C0      		rjmp .L210
 2824               	.L116:
 608:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2825               		.loc 3 608 0
 2826 0c42 60E0      		ldi r22,lo8(.LC16)
 2827 0c44 70E0      		ldi r23,hi8(.LC16)
 2828 0c46 80E0      		ldi r24,lo8(myUartString)
 2829 0c48 90E0      		ldi r25,hi8(myUartString)
 2830 0c4a 0E94 0000 		call strcasestr
 2831               	.LVL213:
 2832 0c4e 892B      		or r24,r25
 2833 0c50 01F4      		brne .+2
 2834 0c52 00C0      		rjmp .L94
 609:main.c        ****         		if( inRange( splitString(myUartString), 31, 0 ) )
 2835               		.loc 3 609 0
 2836 0c54 80E0      		ldi r24,lo8(myUartString)
 2837 0c56 90E0      		ldi r25,hi8(myUartString)
 2838 0c58 0E94 0000 		call splitString
 2839               	.LVL214:
 2840               	.LBB234:
 2841               	.LBB235:
 513:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 2842               		.loc 3 513 0
 2843 0c5c 6032      		cpi r22,32
 2844 0c5e 7105      		cpc r23,__zero_reg__
 2845 0c60 8105      		cpc r24,__zero_reg__
 2846 0c62 9105      		cpc r25,__zero_reg__
 2847 0c64 00F4      		brsh .+2
 2848 0c66 00C0      		rjmp .L117
 2849 0c68 00C0      		rjmp .L94
 2850               	.LVL215:
 2851               	.L115:
 2852               	.LBE235:
 2853               	.LBE234:
 615:main.c        ****     else if(strcasestr(myUartString,"celsius") != NULL){
 2854               		.loc 3 615 0
 2855 0c6a 60E0      		ldi r22,lo8(.LC31)
 2856 0c6c 70E0      		ldi r23,hi8(.LC31)
 2857 0c6e 80E0      		ldi r24,lo8(myUartString)
 2858 0c70 90E0      		ldi r25,hi8(myUartString)
 2859 0c72 0E94 0000 		call strcasestr
 2860               	.LVL216:
 2861 0c76 892B      		or r24,r25
 2862 0c78 01F0      		breq .L118
 616:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2863               		.loc 3 616 0
 2864 0c7a 60E0      		ldi r22,lo8(.LC14)
 2865 0c7c 70E0      		ldi r23,hi8(.LC14)
 2866 0c7e 80E0      		ldi r24,lo8(myUartString)
 2867 0c80 90E0      		ldi r25,hi8(myUartString)
 2868 0c82 0E94 0000 		call strcasestr
 2869               	.LVL217:
 2870 0c86 892B      		or r24,r25
 2871 0c88 01F0      		breq .L119
 617:main.c        ****             print_value("Celsius", celsius);
 2872               		.loc 3 617 0
 2873 0c8a 4091 0000 		lds r20,celsius
 2874 0c8e 50E0      		ldi r21,0
 2875 0c90 60E0      		ldi r22,0
 2876 0c92 70E0      		ldi r23,0
 2877 0c94 80E0      		ldi r24,lo8(.LC32)
 2878 0c96 90E0      		ldi r25,hi8(.LC32)
 2879 0c98 00C0      		rjmp .L210
 2880               	.L119:
 619:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2881               		.loc 3 619 0
 2882 0c9a 60E0      		ldi r22,lo8(.LC16)
 2883 0c9c 70E0      		ldi r23,hi8(.LC16)
 2884 0c9e 80E0      		ldi r24,lo8(myUartString)
 2885 0ca0 90E0      		ldi r25,hi8(myUartString)
 2886 0ca2 0E94 0000 		call strcasestr
 2887               	.LVL218:
 2888 0ca6 892B      		or r24,r25
 2889 0ca8 01F4      		brne .+2
 2890 0caa 00C0      		rjmp .L94
 620:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 2891               		.loc 3 620 0
 2892 0cac 80E0      		ldi r24,lo8(myUartString)
 2893 0cae 90E0      		ldi r25,hi8(myUartString)
 2894 0cb0 0E94 0000 		call splitString
 2895               	.LVL219:
 2896               	.LBB236:
 2897               	.LBB237:
 513:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 2898               		.loc 3 513 0
 2899 0cb4 6230      		cpi r22,2
 2900 0cb6 7105      		cpc r23,__zero_reg__
 2901 0cb8 8105      		cpc r24,__zero_reg__
 2902 0cba 9105      		cpc r25,__zero_reg__
 2903 0cbc 00F0      		brlo .+2
 2904 0cbe 00C0      		rjmp .L94
 2905 0cc0 00C0      		rjmp .L120
 2906               	.LVL220:
 2907               	.L118:
 2908               	.LBE237:
 2909               	.LBE236:
 626:main.c        ****     else if(strcasestr(myUartString,"doecho") != NULL){
 2910               		.loc 3 626 0
 2911 0cc2 60E0      		ldi r22,lo8(.LC33)
 2912 0cc4 70E0      		ldi r23,hi8(.LC33)
 2913 0cc6 80E0      		ldi r24,lo8(myUartString)
 2914 0cc8 90E0      		ldi r25,hi8(myUartString)
 2915 0cca 0E94 0000 		call strcasestr
 2916               	.LVL221:
 2917 0cce 892B      		or r24,r25
 2918 0cd0 01F0      		breq .L121
 627:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2919               		.loc 3 627 0
 2920 0cd2 60E0      		ldi r22,lo8(.LC14)
 2921 0cd4 70E0      		ldi r23,hi8(.LC14)
 2922 0cd6 80E0      		ldi r24,lo8(myUartString)
 2923 0cd8 90E0      		ldi r25,hi8(myUartString)
 2924 0cda 0E94 0000 		call strcasestr
 2925               	.LVL222:
 2926 0cde 892B      		or r24,r25
 2927 0ce0 01F0      		breq .L122
 628:main.c        ****             print_value("Do Echo", doecho);
 2928               		.loc 3 628 0
 2929 0ce2 4091 0000 		lds r20,doecho
 2930 0ce6 50E0      		ldi r21,0
 2931 0ce8 60E0      		ldi r22,0
 2932 0cea 70E0      		ldi r23,0
 2933 0cec 80E0      		ldi r24,lo8(.LC34)
 2934 0cee 90E0      		ldi r25,hi8(.LC34)
 2935 0cf0 00C0      		rjmp .L210
 2936               	.L122:
 630:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2937               		.loc 3 630 0
 2938 0cf2 60E0      		ldi r22,lo8(.LC16)
 2939 0cf4 70E0      		ldi r23,hi8(.LC16)
 2940 0cf6 80E0      		ldi r24,lo8(myUartString)
 2941 0cf8 90E0      		ldi r25,hi8(myUartString)
 2942 0cfa 0E94 0000 		call strcasestr
 2943               	.LVL223:
 2944 0cfe 892B      		or r24,r25
 2945 0d00 01F4      		brne .+2
 2946 0d02 00C0      		rjmp .L94
 631:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 2947               		.loc 3 631 0
 2948 0d04 80E0      		ldi r24,lo8(myUartString)
 2949 0d06 90E0      		ldi r25,hi8(myUartString)
 2950 0d08 0E94 0000 		call splitString
 2951               	.LVL224:
 2952               	.LBB238:
 2953               	.LBB239:
 513:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 2954               		.loc 3 513 0
 2955 0d0c 6230      		cpi r22,2
 2956 0d0e 7105      		cpc r23,__zero_reg__
 2957 0d10 8105      		cpc r24,__zero_reg__
 2958 0d12 9105      		cpc r25,__zero_reg__
 2959 0d14 00F0      		brlo .+2
 2960 0d16 00C0      		rjmp .L94
 2961 0d18 00C0      		rjmp .L123
 2962               	.LVL225:
 2963               	.L121:
 2964               	.LBE239:
 2965               	.LBE238:
 637:main.c        ****     else if(strcasestr(myUartString,"acclock") != NULL){
 2966               		.loc 3 637 0
 2967 0d1a 60E0      		ldi r22,lo8(.LC35)
 2968 0d1c 70E0      		ldi r23,hi8(.LC35)
 2969 0d1e 80E0      		ldi r24,lo8(myUartString)
 2970 0d20 90E0      		ldi r25,hi8(myUartString)
 2971 0d22 0E94 0000 		call strcasestr
 2972               	.LVL226:
 2973 0d26 892B      		or r24,r25
 2974 0d28 01F0      		breq .L124
 638:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 2975               		.loc 3 638 0
 2976 0d2a 60E0      		ldi r22,lo8(.LC14)
 2977 0d2c 70E0      		ldi r23,hi8(.LC14)
 2978 0d2e 80E0      		ldi r24,lo8(myUartString)
 2979 0d30 90E0      		ldi r25,hi8(myUartString)
 2980 0d32 0E94 0000 		call strcasestr
 2981               	.LVL227:
 2982 0d36 892B      		or r24,r25
 2983 0d38 01F0      		breq .L125
 639:main.c        ****             print_value("AC Clock", acclock);
 2984               		.loc 3 639 0
 2985 0d3a 4091 0000 		lds r20,acclock
 2986 0d3e 50E0      		ldi r21,0
 2987 0d40 60E0      		ldi r22,0
 2988 0d42 70E0      		ldi r23,0
 2989 0d44 80E0      		ldi r24,lo8(.LC36)
 2990 0d46 90E0      		ldi r25,hi8(.LC36)
 2991 0d48 00C0      		rjmp .L210
 2992               	.L125:
 641:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 2993               		.loc 3 641 0
 2994 0d4a 60E0      		ldi r22,lo8(.LC16)
 2995 0d4c 70E0      		ldi r23,hi8(.LC16)
 2996 0d4e 80E0      		ldi r24,lo8(myUartString)
 2997 0d50 90E0      		ldi r25,hi8(myUartString)
 2998 0d52 0E94 0000 		call strcasestr
 2999               	.LVL228:
 3000 0d56 892B      		or r24,r25
 3001 0d58 01F4      		brne .+2
 3002 0d5a 00C0      		rjmp .L94
 642:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 3003               		.loc 3 642 0
 3004 0d5c 80E0      		ldi r24,lo8(myUartString)
 3005 0d5e 90E0      		ldi r25,hi8(myUartString)
 3006 0d60 0E94 0000 		call splitString
 3007               	.LVL229:
 3008               	.LBB240:
 3009               	.LBB241:
 513:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 3010               		.loc 3 513 0
 3011 0d64 6230      		cpi r22,2
 3012 0d66 7105      		cpc r23,__zero_reg__
 3013 0d68 8105      		cpc r24,__zero_reg__
 3014 0d6a 9105      		cpc r25,__zero_reg__
 3015 0d6c 00F0      		brlo .+2
 3016 0d6e 00C0      		rjmp .L94
 3017 0d70 00C0      		rjmp .L126
 3018               	.LVL230:
 3019               	.L124:
 3020               	.LBE241:
 3021               	.LBE240:
 648:main.c        ****     else if(strcasestr(myUartString,"xtalisfast") != NULL){
 3022               		.loc 3 648 0
 3023 0d72 60E0      		ldi r22,lo8(.LC37)
 3024 0d74 70E0      		ldi r23,hi8(.LC37)
 3025 0d76 80E0      		ldi r24,lo8(myUartString)
 3026 0d78 90E0      		ldi r25,hi8(myUartString)
 3027 0d7a 0E94 0000 		call strcasestr
 3028               	.LVL231:
 3029 0d7e 892B      		or r24,r25
 3030 0d80 01F0      		breq .L127
 649:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 3031               		.loc 3 649 0
 3032 0d82 60E0      		ldi r22,lo8(.LC14)
 3033 0d84 70E0      		ldi r23,hi8(.LC14)
 3034 0d86 80E0      		ldi r24,lo8(myUartString)
 3035 0d88 90E0      		ldi r25,hi8(myUartString)
 3036 0d8a 0E94 0000 		call strcasestr
 3037               	.LVL232:
 3038 0d8e 892B      		or r24,r25
 3039 0d90 01F0      		breq .L128
 650:main.c        ****             print_value("xtalisfast", xtalisfast);
 3040               		.loc 3 650 0
 3041 0d92 4091 0000 		lds r20,xtalisfast
 3042 0d96 50E0      		ldi r21,0
 3043 0d98 60E0      		ldi r22,0
 3044 0d9a 70E0      		ldi r23,0
 3045 0d9c 80E0      		ldi r24,lo8(.LC37)
 3046 0d9e 90E0      		ldi r25,hi8(.LC37)
 3047               	.L210:
 3048 0da0 0E94 0000 		call print_value
 3049               	.LVL233:
 3050 0da4 00C0      		rjmp .L94
 3051               	.L128:
 652:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 3052               		.loc 3 652 0
 3053 0da6 60E0      		ldi r22,lo8(.LC16)
 3054 0da8 70E0      		ldi r23,hi8(.LC16)
 3055 0daa 80E0      		ldi r24,lo8(myUartString)
 3056 0dac 90E0      		ldi r25,hi8(myUartString)
 3057 0dae 0E94 0000 		call strcasestr
 3058               	.LVL234:
 3059 0db2 892B      		or r24,r25
 3060 0db4 01F4      		brne .+2
 3061 0db6 00C0      		rjmp .L94
 653:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 3062               		.loc 3 653 0
 3063 0db8 80E0      		ldi r24,lo8(myUartString)
 3064 0dba 90E0      		ldi r25,hi8(myUartString)
 3065 0dbc 0E94 0000 		call splitString
 3066               	.LVL235:
 3067               	.LBB242:
 3068               	.LBB243:
 513:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 3069               		.loc 3 513 0
 3070 0dc0 6230      		cpi r22,2
 3071 0dc2 7105      		cpc r23,__zero_reg__
 3072 0dc4 8105      		cpc r24,__zero_reg__
 3073 0dc6 9105      		cpc r25,__zero_reg__
 3074 0dc8 00F0      		brlo .+2
 3075 0dca 00C0      		rjmp .L94
 3076 0dcc 00C0      		rjmp .L129
 3077               	.LVL236:
 3078               	.L127:
 3079               	.LBE243:
 3080               	.LBE242:
 659:main.c        **** 	else if(strcasestr(myUartString,"showtherm") != NULL){
 3081               		.loc 3 659 0
 3082 0dce 60E0      		ldi r22,lo8(.LC38)
 3083 0dd0 70E0      		ldi r23,hi8(.LC38)
 3084 0dd2 80E0      		ldi r24,lo8(myUartString)
 3085 0dd4 90E0      		ldi r25,hi8(myUartString)
 3086 0dd6 0E94 0000 		call strcasestr
 3087               	.LVL237:
 3088 0dda 892B      		or r24,r25
 3089 0ddc 01F0      		breq .L130
 660:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 3090               		.loc 3 660 0
 3091 0dde 60E0      		ldi r22,lo8(.LC14)
 3092 0de0 70E0      		ldi r23,hi8(.LC14)
 3093 0de2 80E0      		ldi r24,lo8(myUartString)
 3094 0de4 90E0      		ldi r25,hi8(myUartString)
 3095 0de6 0E94 0000 		call strcasestr
 3096               	.LVL238:
 3097 0dea 892B      		or r24,r25
 3098 0dec 01F0      		breq .L131
 661:main.c        ****             print_value("Show Therm", showtherm);
 3099               		.loc 3 661 0
 3100 0dee 4091 0000 		lds r20,showtherm
 3101 0df2 50E0      		ldi r21,0
 3102 0df4 60E0      		ldi r22,0
 3103 0df6 70E0      		ldi r23,0
 3104 0df8 80E0      		ldi r24,lo8(.LC39)
 3105 0dfa 90E0      		ldi r25,hi8(.LC39)
 3106 0dfc 00C0      		rjmp .L210
 3107               	.L131:
 663:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 3108               		.loc 3 663 0
 3109 0dfe 60E0      		ldi r22,lo8(.LC16)
 3110 0e00 70E0      		ldi r23,hi8(.LC16)
 3111 0e02 80E0      		ldi r24,lo8(myUartString)
 3112 0e04 90E0      		ldi r25,hi8(myUartString)
 3113 0e06 0E94 0000 		call strcasestr
 3114               	.LVL239:
 3115 0e0a 892B      		or r24,r25
 3116 0e0c 01F4      		brne .+2
 3117 0e0e 00C0      		rjmp .L94
 664:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 3118               		.loc 3 664 0
 3119 0e10 80E0      		ldi r24,lo8(myUartString)
 3120 0e12 90E0      		ldi r25,hi8(myUartString)
 3121 0e14 0E94 0000 		call splitString
 3122               	.LVL240:
 3123               	.LBB244:
 3124               	.LBB245:
 513:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 3125               		.loc 3 513 0
 3126 0e18 6230      		cpi r22,2
 3127 0e1a 7105      		cpc r23,__zero_reg__
 3128 0e1c 8105      		cpc r24,__zero_reg__
 3129 0e1e 9105      		cpc r25,__zero_reg__
 3130 0e20 00F0      		brlo .+2
 3131 0e22 00C0      		rjmp .L94
 3132 0e24 00C0      		rjmp .L132
 3133               	.LVL241:
 3134               	.L130:
 3135               	.LBE245:
 3136               	.LBE244:
 670:main.c        ****     else if(strcasestr(myUartString,"showfreq") != NULL){
 3137               		.loc 3 670 0
 3138 0e26 60E0      		ldi r22,lo8(.LC40)
 3139 0e28 70E0      		ldi r23,hi8(.LC40)
 3140 0e2a 80E0      		ldi r24,lo8(myUartString)
 3141 0e2c 90E0      		ldi r25,hi8(myUartString)
 3142 0e2e 0E94 0000 		call strcasestr
 3143               	.LVL242:
 3144 0e32 892B      		or r24,r25
 3145 0e34 01F0      		breq .L133
 671:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 3146               		.loc 3 671 0
 3147 0e36 60E0      		ldi r22,lo8(.LC14)
 3148 0e38 70E0      		ldi r23,hi8(.LC14)
 3149 0e3a 80E0      		ldi r24,lo8(myUartString)
 3150 0e3c 90E0      		ldi r25,hi8(myUartString)
 3151 0e3e 0E94 0000 		call strcasestr
 3152               	.LVL243:
 3153 0e42 892B      		or r24,r25
 3154 0e44 01F0      		breq .L134
 672:main.c        ****             print_value("Show Freq", showfreq);
 3155               		.loc 3 672 0
 3156 0e46 4091 0000 		lds r20,showfreq
 3157 0e4a 50E0      		ldi r21,0
 3158 0e4c 60E0      		ldi r22,0
 3159 0e4e 70E0      		ldi r23,0
 3160 0e50 80E0      		ldi r24,lo8(.LC41)
 3161 0e52 90E0      		ldi r25,hi8(.LC41)
 3162 0e54 00C0      		rjmp .L210
 3163               	.L134:
 674:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 3164               		.loc 3 674 0
 3165 0e56 60E0      		ldi r22,lo8(.LC16)
 3166 0e58 70E0      		ldi r23,hi8(.LC16)
 3167 0e5a 80E0      		ldi r24,lo8(myUartString)
 3168 0e5c 90E0      		ldi r25,hi8(myUartString)
 3169 0e5e 0E94 0000 		call strcasestr
 3170               	.LVL244:
 3171 0e62 892B      		or r24,r25
 3172 0e64 01F4      		brne .+2
 3173 0e66 00C0      		rjmp .L94
 675:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 3174               		.loc 3 675 0
 3175 0e68 80E0      		ldi r24,lo8(myUartString)
 3176 0e6a 90E0      		ldi r25,hi8(myUartString)
 3177 0e6c 0E94 0000 		call splitString
 3178               	.LVL245:
 3179               	.LBB246:
 3180               	.LBB247:
 513:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 3181               		.loc 3 513 0
 3182 0e70 6230      		cpi r22,2
 3183 0e72 7105      		cpc r23,__zero_reg__
 3184 0e74 8105      		cpc r24,__zero_reg__
 3185 0e76 9105      		cpc r25,__zero_reg__
 3186 0e78 00F0      		brlo .+2
 3187 0e7a 00C0      		rjmp .L94
 3188 0e7c 00C0      		rjmp .L135
 3189               	.LVL246:
 3190               	.L133:
 3191               	.LBE247:
 3192               	.LBE246:
 681:main.c        **** 	else if(strcasestr(myUartString,"showdate") != NULL){
 3193               		.loc 3 681 0
 3194 0e7e 60E0      		ldi r22,lo8(.LC42)
 3195 0e80 70E0      		ldi r23,hi8(.LC42)
 3196 0e82 80E0      		ldi r24,lo8(myUartString)
 3197 0e84 90E0      		ldi r25,hi8(myUartString)
 3198 0e86 0E94 0000 		call strcasestr
 3199               	.LVL247:
 3200 0e8a 892B      		or r24,r25
 3201 0e8c 01F0      		breq .L136
 682:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 3202               		.loc 3 682 0
 3203 0e8e 60E0      		ldi r22,lo8(.LC14)
 3204 0e90 70E0      		ldi r23,hi8(.LC14)
 3205 0e92 80E0      		ldi r24,lo8(myUartString)
 3206 0e94 90E0      		ldi r25,hi8(myUartString)
 3207 0e96 0E94 0000 		call strcasestr
 3208               	.LVL248:
 3209 0e9a 892B      		or r24,r25
 3210 0e9c 01F0      		breq .L137
 683:main.c        ****             print_value("Show Date", showdate);
 3211               		.loc 3 683 0
 3212 0e9e 4091 0000 		lds r20,showdate
 3213 0ea2 50E0      		ldi r21,0
 3214 0ea4 60E0      		ldi r22,0
 3215 0ea6 70E0      		ldi r23,0
 3216 0ea8 80E0      		ldi r24,lo8(.LC43)
 3217 0eaa 90E0      		ldi r25,hi8(.LC43)
 3218 0eac 00C0      		rjmp .L210
 3219               	.L137:
 685:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 3220               		.loc 3 685 0
 3221 0eae 60E0      		ldi r22,lo8(.LC16)
 3222 0eb0 70E0      		ldi r23,hi8(.LC16)
 3223 0eb2 80E0      		ldi r24,lo8(myUartString)
 3224 0eb4 90E0      		ldi r25,hi8(myUartString)
 3225 0eb6 0E94 0000 		call strcasestr
 3226               	.LVL249:
 3227 0eba 892B      		or r24,r25
 3228 0ebc 01F4      		brne .+2
 3229 0ebe 00C0      		rjmp .L94
 686:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 3230               		.loc 3 686 0
 3231 0ec0 80E0      		ldi r24,lo8(myUartString)
 3232 0ec2 90E0      		ldi r25,hi8(myUartString)
 3233 0ec4 0E94 0000 		call splitString
 3234               	.LVL250:
 3235               	.LBB248:
 3236               	.LBB249:
 513:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 3237               		.loc 3 513 0
 3238 0ec8 6230      		cpi r22,2
 3239 0eca 7105      		cpc r23,__zero_reg__
 3240 0ecc 8105      		cpc r24,__zero_reg__
 3241 0ece 9105      		cpc r25,__zero_reg__
 3242 0ed0 00F0      		brlo .+2
 3243 0ed2 00C0      		rjmp .L94
 3244 0ed4 00C0      		rjmp .L138
 3245               	.LVL251:
 3246               	.L136:
 3247               	.LBE249:
 3248               	.LBE248:
 692:main.c        ****     else if(strcasestr(myUartString,"toggleled")!= NULL){
 3249               		.loc 3 692 0
 3250 0ed6 60E0      		ldi r22,lo8(.LC44)
 3251 0ed8 70E0      		ldi r23,hi8(.LC44)
 3252 0eda 80E0      		ldi r24,lo8(myUartString)
 3253 0edc 90E0      		ldi r25,hi8(myUartString)
 3254 0ede 0E94 0000 		call strcasestr
 3255               	.LVL252:
 3256 0ee2 892B      		or r24,r25
 3257 0ee4 01F0      		breq .L139
 693:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 3258               		.loc 3 693 0
 3259 0ee6 60E0      		ldi r22,lo8(.LC14)
 3260 0ee8 70E0      		ldi r23,hi8(.LC14)
 3261 0eea 80E0      		ldi r24,lo8(myUartString)
 3262 0eec 90E0      		ldi r25,hi8(myUartString)
 3263 0eee 0E94 0000 		call strcasestr
 3264               	.LVL253:
 3265 0ef2 892B      		or r24,r25
 3266 0ef4 01F0      		breq .L140
 694:main.c        ****             print_value("Toggle LED", toggleled);
 3267               		.loc 3 694 0
 3268 0ef6 4091 0000 		lds r20,toggleled
 3269 0efa 50E0      		ldi r21,0
 3270 0efc 60E0      		ldi r22,0
 3271 0efe 70E0      		ldi r23,0
 3272 0f00 80E0      		ldi r24,lo8(.LC45)
 3273 0f02 90E0      		ldi r25,hi8(.LC45)
 3274 0f04 00C0      		rjmp .L210
 3275               	.L140:
 696:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 3276               		.loc 3 696 0
 3277 0f06 60E0      		ldi r22,lo8(.LC16)
 3278 0f08 70E0      		ldi r23,hi8(.LC16)
 3279 0f0a 80E0      		ldi r24,lo8(myUartString)
 3280 0f0c 90E0      		ldi r25,hi8(myUartString)
 3281 0f0e 0E94 0000 		call strcasestr
 3282               	.LVL254:
 3283 0f12 892B      		or r24,r25
 3284 0f14 01F4      		brne .+2
 3285 0f16 00C0      		rjmp .L94
 697:main.c        ****         		if( inRange( splitString(myUartString), 1, 0 ) )
 3286               		.loc 3 697 0
 3287 0f18 80E0      		ldi r24,lo8(myUartString)
 3288 0f1a 90E0      		ldi r25,hi8(myUartString)
 3289 0f1c 0E94 0000 		call splitString
 3290               	.LVL255:
 3291               	.LBB250:
 3292               	.LBB251:
 513:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 3293               		.loc 3 513 0
 3294 0f20 6230      		cpi r22,2
 3295 0f22 7105      		cpc r23,__zero_reg__
 3296 0f24 8105      		cpc r24,__zero_reg__
 3297 0f26 9105      		cpc r25,__zero_reg__
 3298 0f28 00F0      		brlo .+2
 3299 0f2a 00C0      		rjmp .L94
 3300 0f2c 00C0      		rjmp .L141
 3301               	.LVL256:
 3302               	.L139:
 3303               	.LBE251:
 3304               	.LBE250:
 703:main.c        ****     else if(strcasestr(myUartString,"nixiesleepstart") != NULL){
 3305               		.loc 3 703 0
 3306 0f2e 60E0      		ldi r22,lo8(.LC46)
 3307 0f30 70E0      		ldi r23,hi8(.LC46)
 3308 0f32 80E0      		ldi r24,lo8(myUartString)
 3309 0f34 90E0      		ldi r25,hi8(myUartString)
 3310 0f36 0E94 0000 		call strcasestr
 3311               	.LVL257:
 3312 0f3a 892B      		or r24,r25
 3313 0f3c 01F0      		breq .L142
 704:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 3314               		.loc 3 704 0
 3315 0f3e 60E0      		ldi r22,lo8(.LC14)
 3316 0f40 70E0      		ldi r23,hi8(.LC14)
 3317 0f42 80E0      		ldi r24,lo8(myUartString)
 3318 0f44 90E0      		ldi r25,hi8(myUartString)
 3319 0f46 0E94 0000 		call strcasestr
 3320               	.LVL258:
 3321 0f4a 892B      		or r24,r25
 3322 0f4c 01F0      		breq .L143
 705:main.c        ****             print_value("Nixie Sleep Start Time", nixiesleepstart);
 3323               		.loc 3 705 0
 3324 0f4e 4091 0000 		lds r20,nixiesleepstart
 3325 0f52 5091 0000 		lds r21,nixiesleepstart+1
 3326 0f56 6091 0000 		lds r22,nixiesleepstart+2
 3327 0f5a 7091 0000 		lds r23,nixiesleepstart+3
 3328 0f5e 80E0      		ldi r24,lo8(.LC47)
 3329 0f60 90E0      		ldi r25,hi8(.LC47)
 3330 0f62 00C0      		rjmp .L210
 3331               	.L143:
 707:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 3332               		.loc 3 707 0
 3333 0f64 60E0      		ldi r22,lo8(.LC16)
 3334 0f66 70E0      		ldi r23,hi8(.LC16)
 3335 0f68 80E0      		ldi r24,lo8(myUartString)
 3336 0f6a 90E0      		ldi r25,hi8(myUartString)
 3337 0f6c 0E94 0000 		call strcasestr
 3338               	.LVL259:
 3339 0f70 892B      		or r24,r25
 3340 0f72 01F4      		brne .+2
 3341 0f74 00C0      		rjmp .L94
 708:main.c        ****         		if( inRange( splitString(myUartString), 2358, 0 ) )
 3342               		.loc 3 708 0
 3343 0f76 80E0      		ldi r24,lo8(myUartString)
 3344 0f78 90E0      		ldi r25,hi8(myUartString)
 3345 0f7a 0E94 0000 		call splitString
 3346               	.LVL260:
 3347               	.LBB252:
 3348               	.LBB253:
 513:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 3349               		.loc 3 513 0
 3350 0f7e 6733      		cpi r22,55
 3351 0f80 7940      		sbci r23,9
 3352 0f82 8105      		cpc r24,__zero_reg__
 3353 0f84 9105      		cpc r25,__zero_reg__
 3354 0f86 00F4      		brsh .+2
 3355 0f88 00C0      		rjmp .L144
 3356 0f8a 00C0      		rjmp .L94
 3357               	.LVL261:
 3358               	.L142:
 3359               	.LBE253:
 3360               	.LBE252:
 714:main.c        ****     else if(strcasestr(myUartString,"nixiesleepend") != NULL){
 3361               		.loc 3 714 0
 3362 0f8c 60E0      		ldi r22,lo8(.LC48)
 3363 0f8e 70E0      		ldi r23,hi8(.LC48)
 3364 0f90 80E0      		ldi r24,lo8(myUartString)
 3365 0f92 90E0      		ldi r25,hi8(myUartString)
 3366 0f94 0E94 0000 		call strcasestr
 3367               	.LVL262:
 3368 0f98 892B      		or r24,r25
 3369 0f9a 01F0      		breq .L145
 715:main.c        ****         if(strcasestr(myUartString,"?") != NULL){
 3370               		.loc 3 715 0
 3371 0f9c 60E0      		ldi r22,lo8(.LC14)
 3372 0f9e 70E0      		ldi r23,hi8(.LC14)
 3373 0fa0 80E0      		ldi r24,lo8(myUartString)
 3374 0fa2 90E0      		ldi r25,hi8(myUartString)
 3375 0fa4 0E94 0000 		call strcasestr
 3376               	.LVL263:
 3377 0fa8 892B      		or r24,r25
 3378 0faa 01F0      		breq .L146
 716:main.c        ****             print_value("Nixie Sleep End Time", nixiesleepend);
 3379               		.loc 3 716 0
 3380 0fac 4091 0000 		lds r20,nixiesleepend
 3381 0fb0 5091 0000 		lds r21,nixiesleepend+1
 3382 0fb4 6091 0000 		lds r22,nixiesleepend+2
 3383 0fb8 7091 0000 		lds r23,nixiesleepend+3
 3384 0fbc 80E0      		ldi r24,lo8(.LC49)
 3385 0fbe 90E0      		ldi r25,hi8(.LC49)
 3386 0fc0 00C0      		rjmp .L210
 3387               	.L146:
 718:main.c        ****         	if(strcasestr(myUartString,"=") != NULL){
 3388               		.loc 3 718 0
 3389 0fc2 60E0      		ldi r22,lo8(.LC16)
 3390 0fc4 70E0      		ldi r23,hi8(.LC16)
 3391 0fc6 80E0      		ldi r24,lo8(myUartString)
 3392 0fc8 90E0      		ldi r25,hi8(myUartString)
 3393 0fca 0E94 0000 		call strcasestr
 3394               	.LVL264:
 3395 0fce 892B      		or r24,r25
 3396 0fd0 01F4      		brne .+2
 3397 0fd2 00C0      		rjmp .L94
 719:main.c        ****         		if( inRange( splitString(myUartString), 2359, nixiesleepstart + 1 ) )
 3398               		.loc 3 719 0
 3399 0fd4 C090 0000 		lds r12,nixiesleepstart
 3400 0fd8 D090 0000 		lds r13,nixiesleepstart+1
 3401 0fdc E090 0000 		lds r14,nixiesleepstart+2
 3402 0fe0 F090 0000 		lds r15,nixiesleepstart+3
 3403 0fe4 8FEF      		ldi r24,-1
 3404 0fe6 C81A      		sub r12,r24
 3405 0fe8 D80A      		sbc r13,r24
 3406 0fea E80A      		sbc r14,r24
 3407 0fec F80A      		sbc r15,r24
 3408 0fee 80E0      		ldi r24,lo8(myUartString)
 3409 0ff0 90E0      		ldi r25,hi8(myUartString)
 3410 0ff2 0E94 0000 		call splitString
 3411               	.LVL265:
 3412               	.LBB254:
 3413               	.LBB255:
 513:main.c        **** 	if( inputValue >= lowerBound && inputValue <= upperBound )
 3414               		.loc 3 513 0
 3415 0ff6 6C15      		cp r22,r12
 3416 0ff8 7D05      		cpc r23,r13
 3417 0ffa 8E05      		cpc r24,r14
 3418 0ffc 9F05      		cpc r25,r15
 3419 0ffe 00F4      		brsh .+2
 3420 1000 00C0      		rjmp .L94
 3421 1002 6833      		cpi r22,56
 3422 1004 7940      		sbci r23,9
 3423 1006 8105      		cpc r24,__zero_reg__
 3424 1008 9105      		cpc r25,__zero_reg__
 3425 100a 00F4      		brsh .+2
 3426 100c 00C0      		rjmp .L147
 3427 100e 00C0      		rjmp .L94
 3428               	.LVL266:
 3429               	.L145:
 3430               	.LBE255:
 3431               	.LBE254:
 726:main.c        ****     else if(strcasestr(myUartString,"getall") != NULL){
 3432               		.loc 3 726 0
 3433 1010 60E0      		ldi r22,lo8(.LC50)
 3434 1012 70E0      		ldi r23,hi8(.LC50)
 3435 1014 80E0      		ldi r24,lo8(myUartString)
 3436 1016 90E0      		ldi r25,hi8(myUartString)
 3437 1018 0E94 0000 		call strcasestr
 3438               	.LVL267:
 3439 101c 892B      		or r24,r25
 3440 101e 01F4      		brne .+2
 3441 1020 00C0      		rjmp .L148
 3442               	.LBB256:
 728:main.c        ****     	print_csv( ",", hours );					
 3443               		.loc 3 728 0
 3444 1022 4091 0000 		lds r20,hours
 3445 1026 50E0      		ldi r21,0
 3446 1028 60E0      		ldi r22,0
 3447 102a 70E0      		ldi r23,0
 3448 102c 80E0      		ldi r24,lo8(.LC51)
 3449 102e 90E0      		ldi r25,hi8(.LC51)
 3450 1030 0E94 0000 		call print_csv
 3451               	.LVL268:
 729:main.c        ****     	print_csv( ",", minutes );					
 3452               		.loc 3 729 0
 3453 1034 4091 0000 		lds r20,minutes
 3454 1038 50E0      		ldi r21,0
 3455 103a 60E0      		ldi r22,0
 3456 103c 70E0      		ldi r23,0
 3457 103e 80E0      		ldi r24,lo8(.LC51)
 3458 1040 90E0      		ldi r25,hi8(.LC51)
 3459 1042 0E94 0000 		call print_csv
 3460               	.LVL269:
 730:main.c        ****     	print_csv( ",", seconds );					
 3461               		.loc 3 730 0
 3462 1046 4091 0000 		lds r20,seconds
 3463 104a 50E0      		ldi r21,0
 3464 104c 60E0      		ldi r22,0
 3465 104e 70E0      		ldi r23,0
 3466 1050 80E0      		ldi r24,lo8(.LC51)
 3467 1052 90E0      		ldi r25,hi8(.LC51)
 3468 1054 0E94 0000 		call print_csv
 3469               	.LVL270:
 731:main.c        ****     	print_csv( ",", mscal );					
 3470               		.loc 3 731 0
 3471 1058 4091 0000 		lds r20,mscal
 3472 105c 5091 0000 		lds r21,mscal+1
 3473 1060 6091 0000 		lds r22,mscal+2
 3474 1064 7091 0000 		lds r23,mscal+3
 3475 1068 80E0      		ldi r24,lo8(.LC51)
 3476 106a 90E0      		ldi r25,hi8(.LC51)
 3477 106c 0E94 0000 		call print_csv
 3478               	.LVL271:
 732:main.c        ****     	print_csv( ",", miltime );					
 3479               		.loc 3 732 0
 3480 1070 4091 0000 		lds r20,miltime
 3481 1074 50E0      		ldi r21,0
 3482 1076 60E0      		ldi r22,0
 3483 1078 70E0      		ldi r23,0
 3484 107a 80E0      		ldi r24,lo8(.LC51)
 3485 107c 90E0      		ldi r25,hi8(.LC51)
 3486 107e 0E94 0000 		call print_csv
 3487               	.LVL272:
 733:main.c        ****     	print_csv( ",", year );						
 3488               		.loc 3 733 0
 3489 1082 4091 0000 		lds r20,year
 3490 1086 5091 0000 		lds r21,year+1
 3491 108a 60E0      		ldi r22,0
 3492 108c 70E0      		ldi r23,0
 3493 108e 80E0      		ldi r24,lo8(.LC51)
 3494 1090 90E0      		ldi r25,hi8(.LC51)
 3495 1092 0E94 0000 		call print_csv
 3496               	.LVL273:
 734:main.c        ****     	print_csv( ",", month );					
 3497               		.loc 3 734 0
 3498 1096 4091 0000 		lds r20,month
 3499 109a 50E0      		ldi r21,0
 3500 109c 60E0      		ldi r22,0
 3501 109e 70E0      		ldi r23,0
 3502 10a0 80E0      		ldi r24,lo8(.LC51)
 3503 10a2 90E0      		ldi r25,hi8(.LC51)
 3504 10a4 0E94 0000 		call print_csv
 3505               	.LVL274:
 735:main.c        ****     	print_csv( ",", day );						
 3506               		.loc 3 735 0
 3507 10a8 4091 0000 		lds r20,day
 3508 10ac 50E0      		ldi r21,0
 3509 10ae 60E0      		ldi r22,0
 3510 10b0 70E0      		ldi r23,0
 3511 10b2 80E0      		ldi r24,lo8(.LC51)
 3512 10b4 90E0      		ldi r25,hi8(.LC51)
 3513 10b6 0E94 0000 		call print_csv
 3514               	.LVL275:
 736:main.c        ****     	print_csv( ",", celsius );					
 3515               		.loc 3 736 0
 3516 10ba 4091 0000 		lds r20,celsius
 3517 10be 50E0      		ldi r21,0
 3518 10c0 60E0      		ldi r22,0
 3519 10c2 70E0      		ldi r23,0
 3520 10c4 80E0      		ldi r24,lo8(.LC51)
 3521 10c6 90E0      		ldi r25,hi8(.LC51)
 3522 10c8 0E94 0000 		call print_csv
 3523               	.LVL276:
 737:main.c        ****     	print_csv( ",", doecho );					
 3524               		.loc 3 737 0
 3525 10cc 4091 0000 		lds r20,doecho
 3526 10d0 50E0      		ldi r21,0
 3527 10d2 60E0      		ldi r22,0
 3528 10d4 70E0      		ldi r23,0
 3529 10d6 80E0      		ldi r24,lo8(.LC51)
 3530 10d8 90E0      		ldi r25,hi8(.LC51)
 3531 10da 0E94 0000 		call print_csv
 3532               	.LVL277:
 738:main.c        ****     	print_csv( ",", xtalisfast );				
 3533               		.loc 3 738 0
 3534 10de 4091 0000 		lds r20,xtalisfast
 3535 10e2 50E0      		ldi r21,0
 3536 10e4 60E0      		ldi r22,0
 3537 10e6 70E0      		ldi r23,0
 3538 10e8 80E0      		ldi r24,lo8(.LC51)
 3539 10ea 90E0      		ldi r25,hi8(.LC51)
 3540 10ec 0E94 0000 		call print_csv
 3541               	.LVL278:
 739:main.c        ****     	print_csv( ",", showtherm );				
 3542               		.loc 3 739 0
 3543 10f0 4091 0000 		lds r20,showtherm
 3544 10f4 50E0      		ldi r21,0
 3545 10f6 60E0      		ldi r22,0
 3546 10f8 70E0      		ldi r23,0
 3547 10fa 80E0      		ldi r24,lo8(.LC51)
 3548 10fc 90E0      		ldi r25,hi8(.LC51)
 3549 10fe 0E94 0000 		call print_csv
 3550               	.LVL279:
 740:main.c        ****     	print_csv( ",", showdate );					
 3551               		.loc 3 740 0
 3552 1102 4091 0000 		lds r20,showdate
 3553 1106 50E0      		ldi r21,0
 3554 1108 60E0      		ldi r22,0
 3555 110a 70E0      		ldi r23,0
 3556 110c 80E0      		ldi r24,lo8(.LC51)
 3557 110e 90E0      		ldi r25,hi8(.LC51)
 3558 1110 0E94 0000 		call print_csv
 3559               	.LVL280:
 741:main.c        ****     	print_csv( ",", toggleled );				
 3560               		.loc 3 741 0
 3561 1114 4091 0000 		lds r20,toggleled
 3562 1118 50E0      		ldi r21,0
 3563 111a 60E0      		ldi r22,0
 3564 111c 70E0      		ldi r23,0
 3565 111e 80E0      		ldi r24,lo8(.LC51)
 3566 1120 90E0      		ldi r25,hi8(.LC51)
 3567 1122 0E94 0000 		call print_csv
 3568               	.LVL281:
 742:main.c        ****     	print_csv( ",", nixiesleepstart );			
 3569               		.loc 3 742 0
 3570 1126 4091 0000 		lds r20,nixiesleepstart
 3571 112a 5091 0000 		lds r21,nixiesleepstart+1
 3572 112e 6091 0000 		lds r22,nixiesleepstart+2
 3573 1132 7091 0000 		lds r23,nixiesleepstart+3
 3574 1136 80E0      		ldi r24,lo8(.LC51)
 3575 1138 90E0      		ldi r25,hi8(.LC51)
 3576 113a 0E94 0000 		call print_csv
 3577               	.LVL282:
 743:main.c        ****     	print_csv( ",", nixiesleepend );				
 3578               		.loc 3 743 0
 3579 113e 4091 0000 		lds r20,nixiesleepend
 3580 1142 5091 0000 		lds r21,nixiesleepend+1
 3581 1146 6091 0000 		lds r22,nixiesleepend+2
 3582 114a 7091 0000 		lds r23,nixiesleepend+3
 3583 114e 80E0      		ldi r24,lo8(.LC51)
 3584 1150 90E0      		ldi r25,hi8(.LC51)
 3585 1152 0E94 0000 		call print_csv
 3586               	.LVL283:
 744:main.c        ****     	print_csv( ",", SERIAL_NUMBER );			
 3587               		.loc 3 744 0
 3588 1156 44E6      		ldi r20,lo8(100)
 3589 1158 50E0      		ldi r21,0
 3590 115a 60E0      		ldi r22,0
 3591 115c 70E0      		ldi r23,0
 3592 115e 80E0      		ldi r24,lo8(.LC51)
 3593 1160 90E0      		ldi r25,hi8(.LC51)
 3594 1162 0E94 0000 		call print_csv
 3595               	.LVL284:
 747:main.c        ****     	double Volts = adc_raw[0] * 0.019375;
 3596               		.loc 3 747 0
 3597 1166 6091 0000 		lds r22,adc_raw
 3598               	.LVL285:
 3599 116a 70E0      		ldi r23,0
 3600 116c 80E0      		ldi r24,0
 3601 116e 90E0      		ldi r25,0
 3602 1170 0E94 0000 		call __floatsisf
 3603               	.LVL286:
 3604 1174 22E5      		ldi r18,lo8(82)
 3605 1176 38EB      		ldi r19,lo8(-72)
 3606 1178 4EE9      		ldi r20,lo8(-98)
 3607 117a 5CE3      		ldi r21,lo8(60)
 3608 117c 0E94 0000 		call __mulsf3
 3609               	.LVL287:
 748:main.c        ****         dtostrf(Volts , 10, 2, printBuffer);
 3610               		.loc 3 748 0
 3611 1180 00E0      		ldi r16,lo8(printBuffer)
 3612 1182 10E0      		ldi r17,hi8(printBuffer)
 3613 1184 22E0      		ldi r18,lo8(2)
 3614 1186 4AE0      		ldi r20,lo8(10)
 3615 1188 0E94 0000 		call dtostrf
 3616               	.LVL288:
 749:main.c        ****         uart_puts(printBuffer);
 3617               		.loc 3 749 0
 3618 118c C801      		movw r24,r16
 3619 118e 0E94 0000 		call uart_puts
 3620               	.LVL289:
 750:main.c        ****         uart_puts(",");
 3621               		.loc 3 750 0
 3622 1192 80E0      		ldi r24,lo8(.LC51)
 3623 1194 90E0      		ldi r25,hi8(.LC51)
 3624 1196 0E94 0000 		call uart_puts
 3625               	.LVL290:
 753:main.c        ****         Volts = adc_raw[1] * 1.9375;
 3626               		.loc 3 753 0
 3627 119a 6091 0000 		lds r22,adc_raw+1
 3628               	.LVL291:
 3629 119e 70E0      		ldi r23,0
 3630 11a0 80E0      		ldi r24,0
 3631 11a2 90E0      		ldi r25,0
 3632 11a4 0E94 0000 		call __floatsisf
 3633               	.LVL292:
 3634 11a8 20E0      		ldi r18,0
 3635 11aa 30E0      		ldi r19,0
 3636 11ac 48EF      		ldi r20,lo8(-8)
 3637 11ae 5FE3      		ldi r21,lo8(63)
 3638 11b0 0E94 0000 		call __mulsf3
 3639               	.LVL293:
 754:main.c        ****         dtostrf(Volts , 10, 2, printBuffer);
 3640               		.loc 3 754 0
 3641 11b4 22E0      		ldi r18,lo8(2)
 3642 11b6 4AE0      		ldi r20,lo8(10)
 3643 11b8 0E94 0000 		call dtostrf
 3644               	.LVL294:
 755:main.c        ****         uart_puts(printBuffer);
 3645               		.loc 3 755 0
 3646 11bc C801      		movw r24,r16
 3647 11be 0E94 0000 		call uart_puts
 3648               	.LVL295:
 756:main.c        ****         uart_puts(",");
 3649               		.loc 3 756 0
 3650 11c2 80E0      		ldi r24,lo8(.LC51)
 3651 11c4 90E0      		ldi r25,hi8(.LC51)
 3652 11c6 0E94 0000 		call uart_puts
 3653               	.LVL296:
 759:main.c        ****         Volts = adc_raw[2] * 0.019375;
 3654               		.loc 3 759 0
 3655 11ca 6091 0000 		lds r22,adc_raw+2
 3656               	.LVL297:
 3657 11ce 70E0      		ldi r23,0
 3658 11d0 80E0      		ldi r24,0
 3659 11d2 90E0      		ldi r25,0
 3660 11d4 0E94 0000 		call __floatsisf
 3661               	.LVL298:
 3662 11d8 22E5      		ldi r18,lo8(82)
 3663 11da 38EB      		ldi r19,lo8(-72)
 3664 11dc 4EE9      		ldi r20,lo8(-98)
 3665 11de 5CE3      		ldi r21,lo8(60)
 3666 11e0 0E94 0000 		call __mulsf3
 3667               	.LVL299:
 760:main.c        ****         dtostrf(Volts , 10, 2, printBuffer);
 3668               		.loc 3 760 0
 3669 11e4 22E0      		ldi r18,lo8(2)
 3670 11e6 4AE0      		ldi r20,lo8(10)
 3671 11e8 0E94 0000 		call dtostrf
 3672               	.LVL300:
 761:main.c        ****         uart_puts(printBuffer);
 3673               		.loc 3 761 0
 3674 11ec C801      		movw r24,r16
 3675 11ee 0E94 0000 		call uart_puts
 3676               	.LVL301:
 762:main.c        ****         uart_puts(",");
 3677               		.loc 3 762 0
 3678 11f2 80E0      		ldi r24,lo8(.LC51)
 3679 11f4 90E0      		ldi r25,hi8(.LC51)
 3680 11f6 0E94 0000 		call uart_puts
 3681               	.LVL302:
 765:main.c        ****         Volts = adc_raw[3] * 0.11;
 3682               		.loc 3 765 0
 3683 11fa 6091 0000 		lds r22,adc_raw+3
 3684               	.LVL303:
 3685 11fe 70E0      		ldi r23,0
 3686 1200 80E0      		ldi r24,0
 3687 1202 90E0      		ldi r25,0
 3688 1204 0E94 0000 		call __floatsisf
 3689               	.LVL304:
 3690 1208 2EEA      		ldi r18,lo8(-82)
 3691 120a 37E4      		ldi r19,lo8(71)
 3692 120c 41EE      		ldi r20,lo8(-31)
 3693 120e 5DE3      		ldi r21,lo8(61)
 3694 1210 0E94 0000 		call __mulsf3
 3695               	.LVL305:
 3696 1214 00C0      		rjmp .L211
 3697               	.L148:
 3698               	.LBE256:
 771:main.c        ****     else if( strcasestr( myUartString, "help" ) != NULL ){
 3699               		.loc 3 771 0
 3700 1216 60E0      		ldi r22,lo8(.LC52)
 3701 1218 70E0      		ldi r23,hi8(.LC52)
 3702 121a 80E0      		ldi r24,lo8(myUartString)
 3703 121c 90E0      		ldi r25,hi8(myUartString)
 3704 121e 0E94 0000 		call strcasestr
 3705               	.LVL306:
 3706 1222 892B      		or r24,r25
 3707 1224 01F4      		brne .+2
 3708 1226 00C0      		rjmp .L149
 773:main.c        ****     	uart_puts("Command");			uart_puts("\t\t");	uart_puts("Set/Read");	uart_puts("\t");	uart_puts("
 3709               		.loc 3 773 0
 3710 1228 80E0      		ldi r24,lo8(.LC53)
 3711 122a 90E0      		ldi r25,hi8(.LC53)
 3712 122c 0E94 0000 		call uart_puts
 3713               	.LVL307:
 3714 1230 80E0      		ldi r24,lo8(.LC54)
 3715 1232 90E0      		ldi r25,hi8(.LC54)
 3716 1234 0E94 0000 		call uart_puts
 3717               	.LVL308:
 3718 1238 80E0      		ldi r24,lo8(.LC55)
 3719 123a 90E0      		ldi r25,hi8(.LC55)
 3720 123c 0E94 0000 		call uart_puts
 3721               	.LVL309:
 3722 1240 80E0      		ldi r24,lo8(.LC56)
 3723 1242 90E0      		ldi r25,hi8(.LC56)
 3724 1244 0E94 0000 		call uart_puts
 3725               	.LVL310:
 3726 1248 80E0      		ldi r24,lo8(.LC57)
 3727 124a 90E0      		ldi r25,hi8(.LC57)
 3728 124c 0E94 0000 		call uart_puts
 3729               	.LVL311:
 3730 1250 80E0      		ldi r24,lo8(.LC58)
 3731 1252 90E0      		ldi r25,hi8(.LC58)
 3732 1254 0E94 0000 		call uart_puts
 3733               	.LVL312:
 3734 1258 80E0      		ldi r24,lo8(.LC59)
 3735 125a 90E0      		ldi r25,hi8(.LC59)
 3736 125c 0E94 0000 		call uart_puts
 3737               	.LVL313:
 3738 1260 80E0      		ldi r24,lo8(.LC3)
 3739 1262 90E0      		ldi r25,hi8(.LC3)
 3740 1264 0E94 0000 		call uart_puts
 3741               	.LVL314:
 774:main.c        ****     	uart_puts("hours");				uart_puts("\t\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0")
 3742               		.loc 3 774 0
 3743 1268 80E0      		ldi r24,lo8(.LC13)
 3744 126a 90E0      		ldi r25,hi8(.LC13)
 3745 126c 0E94 0000 		call uart_puts
 3746               	.LVL315:
 3747 1270 80E0      		ldi r24,lo8(.LC54)
 3748 1272 90E0      		ldi r25,hi8(.LC54)
 3749 1274 0E94 0000 		call uart_puts
 3750               	.LVL316:
 3751 1278 80E0      		ldi r24,lo8(.LC60)
 3752 127a 90E0      		ldi r25,hi8(.LC60)
 3753 127c 0E94 0000 		call uart_puts
 3754               	.LVL317:
 3755 1280 80E0      		ldi r24,lo8(.LC54)
 3756 1282 90E0      		ldi r25,hi8(.LC54)
 3757 1284 0E94 0000 		call uart_puts
 3758               	.LVL318:
 3759 1288 80E0      		ldi r24,lo8(.LC61)
 3760 128a 90E0      		ldi r25,hi8(.LC61)
 3761 128c 0E94 0000 		call uart_puts
 3762               	.LVL319:
 3763 1290 80E0      		ldi r24,lo8(.LC58)
 3764 1292 90E0      		ldi r25,hi8(.LC58)
 3765 1294 0E94 0000 		call uart_puts
 3766               	.LVL320:
 3767 1298 80E0      		ldi r24,lo8(.LC62)
 3768 129a 90E0      		ldi r25,hi8(.LC62)
 3769 129c 0E94 0000 		call uart_puts
 3770               	.LVL321:
 3771 12a0 80E0      		ldi r24,lo8(.LC3)
 3772 12a2 90E0      		ldi r25,hi8(.LC3)
 3773 12a4 0E94 0000 		call uart_puts
 3774               	.LVL322:
 775:main.c        ****     	uart_puts("minutes");			uart_puts("\t\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0"
 3775               		.loc 3 775 0
 3776 12a8 80E0      		ldi r24,lo8(.LC17)
 3777 12aa 90E0      		ldi r25,hi8(.LC17)
 3778 12ac 0E94 0000 		call uart_puts
 3779               	.LVL323:
 3780 12b0 80E0      		ldi r24,lo8(.LC54)
 3781 12b2 90E0      		ldi r25,hi8(.LC54)
 3782 12b4 0E94 0000 		call uart_puts
 3783               	.LVL324:
 3784 12b8 80E0      		ldi r24,lo8(.LC60)
 3785 12ba 90E0      		ldi r25,hi8(.LC60)
 3786 12bc 0E94 0000 		call uart_puts
 3787               	.LVL325:
 3788 12c0 80E0      		ldi r24,lo8(.LC54)
 3789 12c2 90E0      		ldi r25,hi8(.LC54)
 3790 12c4 0E94 0000 		call uart_puts
 3791               	.LVL326:
 3792 12c8 80E0      		ldi r24,lo8(.LC61)
 3793 12ca 90E0      		ldi r25,hi8(.LC61)
 3794 12cc 0E94 0000 		call uart_puts
 3795               	.LVL327:
 3796 12d0 80E0      		ldi r24,lo8(.LC58)
 3797 12d2 90E0      		ldi r25,hi8(.LC58)
 3798 12d4 0E94 0000 		call uart_puts
 3799               	.LVL328:
 3800 12d8 80E0      		ldi r24,lo8(.LC63)
 3801 12da 90E0      		ldi r25,hi8(.LC63)
 3802 12dc 0E94 0000 		call uart_puts
 3803               	.LVL329:
 3804 12e0 80E0      		ldi r24,lo8(.LC3)
 3805 12e2 90E0      		ldi r25,hi8(.LC3)
 3806 12e4 0E94 0000 		call uart_puts
 3807               	.LVL330:
 776:main.c        ****     	uart_puts("seconds");			uart_puts("\t\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0"
 3808               		.loc 3 776 0
 3809 12e8 80E0      		ldi r24,lo8(.LC19)
 3810 12ea 90E0      		ldi r25,hi8(.LC19)
 3811 12ec 0E94 0000 		call uart_puts
 3812               	.LVL331:
 3813 12f0 80E0      		ldi r24,lo8(.LC54)
 3814 12f2 90E0      		ldi r25,hi8(.LC54)
 3815 12f4 0E94 0000 		call uart_puts
 3816               	.LVL332:
 3817 12f8 80E0      		ldi r24,lo8(.LC60)
 3818 12fa 90E0      		ldi r25,hi8(.LC60)
 3819 12fc 0E94 0000 		call uart_puts
 3820               	.LVL333:
 3821 1300 80E0      		ldi r24,lo8(.LC54)
 3822 1302 90E0      		ldi r25,hi8(.LC54)
 3823 1304 0E94 0000 		call uart_puts
 3824               	.LVL334:
 3825 1308 80E0      		ldi r24,lo8(.LC61)
 3826 130a 90E0      		ldi r25,hi8(.LC61)
 3827 130c 0E94 0000 		call uart_puts
 3828               	.LVL335:
 3829 1310 80E0      		ldi r24,lo8(.LC58)
 3830 1312 90E0      		ldi r25,hi8(.LC58)
 3831 1314 0E94 0000 		call uart_puts
 3832               	.LVL336:
 3833 1318 80E0      		ldi r24,lo8(.LC63)
 3834 131a 90E0      		ldi r25,hi8(.LC63)
 3835 131c 0E94 0000 		call uart_puts
 3836               	.LVL337:
 3837 1320 80E0      		ldi r24,lo8(.LC3)
 3838 1322 90E0      		ldi r25,hi8(.LC3)
 3839 1324 0E94 0000 		call uart_puts
 3840               	.LVL338:
 777:main.c        ****     	uart_puts("mscal");				uart_puts("\t\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0")
 3841               		.loc 3 777 0
 3842 1328 80E0      		ldi r24,lo8(.LC21)
 3843 132a 90E0      		ldi r25,hi8(.LC21)
 3844 132c 0E94 0000 		call uart_puts
 3845               	.LVL339:
 3846 1330 80E0      		ldi r24,lo8(.LC54)
 3847 1332 90E0      		ldi r25,hi8(.LC54)
 3848 1334 0E94 0000 		call uart_puts
 3849               	.LVL340:
 3850 1338 80E0      		ldi r24,lo8(.LC60)
 3851 133a 90E0      		ldi r25,hi8(.LC60)
 3852 133c 0E94 0000 		call uart_puts
 3853               	.LVL341:
 3854 1340 80E0      		ldi r24,lo8(.LC54)
 3855 1342 90E0      		ldi r25,hi8(.LC54)
 3856 1344 0E94 0000 		call uart_puts
 3857               	.LVL342:
 3858 1348 80E0      		ldi r24,lo8(.LC61)
 3859 134a 90E0      		ldi r25,hi8(.LC61)
 3860 134c 0E94 0000 		call uart_puts
 3861               	.LVL343:
 3862 1350 80E0      		ldi r24,lo8(.LC58)
 3863 1352 90E0      		ldi r25,hi8(.LC58)
 3864 1354 0E94 0000 		call uart_puts
 3865               	.LVL344:
 3866 1358 80E0      		ldi r24,lo8(.LC64)
 3867 135a 90E0      		ldi r25,hi8(.LC64)
 3868 135c 0E94 0000 		call uart_puts
 3869               	.LVL345:
 3870 1360 80E0      		ldi r24,lo8(.LC3)
 3871 1362 90E0      		ldi r25,hi8(.LC3)
 3872 1364 0E94 0000 		call uart_puts
 3873               	.LVL346:
 778:main.c        ****     	uart_puts("miltime");			uart_puts("\t\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0"
 3874               		.loc 3 778 0
 3875 1368 80E0      		ldi r24,lo8(.LC23)
 3876 136a 90E0      		ldi r25,hi8(.LC23)
 3877 136c 0E94 0000 		call uart_puts
 3878               	.LVL347:
 3879 1370 80E0      		ldi r24,lo8(.LC54)
 3880 1372 90E0      		ldi r25,hi8(.LC54)
 3881 1374 0E94 0000 		call uart_puts
 3882               	.LVL348:
 3883 1378 80E0      		ldi r24,lo8(.LC60)
 3884 137a 90E0      		ldi r25,hi8(.LC60)
 3885 137c 0E94 0000 		call uart_puts
 3886               	.LVL349:
 3887 1380 80E0      		ldi r24,lo8(.LC54)
 3888 1382 90E0      		ldi r25,hi8(.LC54)
 3889 1384 0E94 0000 		call uart_puts
 3890               	.LVL350:
 3891 1388 80E0      		ldi r24,lo8(.LC61)
 3892 138a 90E0      		ldi r25,hi8(.LC61)
 3893 138c 0E94 0000 		call uart_puts
 3894               	.LVL351:
 3895 1390 80E0      		ldi r24,lo8(.LC58)
 3896 1392 90E0      		ldi r25,hi8(.LC58)
 3897 1394 0E94 0000 		call uart_puts
 3898               	.LVL352:
 3899 1398 80E0      		ldi r24,lo8(.LC65)
 3900 139a 90E0      		ldi r25,hi8(.LC65)
 3901 139c 0E94 0000 		call uart_puts
 3902               	.LVL353:
 3903 13a0 80E0      		ldi r24,lo8(.LC3)
 3904 13a2 90E0      		ldi r25,hi8(.LC3)
 3905 13a4 0E94 0000 		call uart_puts
 3906               	.LVL354:
 779:main.c        ****     	uart_puts("year");				uart_puts("\t\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0");
 3907               		.loc 3 779 0
 3908 13a8 80E0      		ldi r24,lo8(.LC25)
 3909 13aa 90E0      		ldi r25,hi8(.LC25)
 3910 13ac 0E94 0000 		call uart_puts
 3911               	.LVL355:
 3912 13b0 80E0      		ldi r24,lo8(.LC54)
 3913 13b2 90E0      		ldi r25,hi8(.LC54)
 3914 13b4 0E94 0000 		call uart_puts
 3915               	.LVL356:
 3916 13b8 80E0      		ldi r24,lo8(.LC60)
 3917 13ba 90E0      		ldi r25,hi8(.LC60)
 3918 13bc 0E94 0000 		call uart_puts
 3919               	.LVL357:
 3920 13c0 80E0      		ldi r24,lo8(.LC54)
 3921 13c2 90E0      		ldi r25,hi8(.LC54)
 3922 13c4 0E94 0000 		call uart_puts
 3923               	.LVL358:
 3924 13c8 80E0      		ldi r24,lo8(.LC61)
 3925 13ca 90E0      		ldi r25,hi8(.LC61)
 3926 13cc 0E94 0000 		call uart_puts
 3927               	.LVL359:
 3928 13d0 80E0      		ldi r24,lo8(.LC58)
 3929 13d2 90E0      		ldi r25,hi8(.LC58)
 3930 13d4 0E94 0000 		call uart_puts
 3931               	.LVL360:
 3932 13d8 80E0      		ldi r24,lo8(.LC66)
 3933 13da 90E0      		ldi r25,hi8(.LC66)
 3934 13dc 0E94 0000 		call uart_puts
 3935               	.LVL361:
 3936 13e0 80E0      		ldi r24,lo8(.LC3)
 3937 13e2 90E0      		ldi r25,hi8(.LC3)
 3938 13e4 0E94 0000 		call uart_puts
 3939               	.LVL362:
 780:main.c        ****     	uart_puts("month");				uart_puts("\t\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0")
 3940               		.loc 3 780 0
 3941 13e8 80E0      		ldi r24,lo8(.LC27)
 3942 13ea 90E0      		ldi r25,hi8(.LC27)
 3943 13ec 0E94 0000 		call uart_puts
 3944               	.LVL363:
 3945 13f0 80E0      		ldi r24,lo8(.LC54)
 3946 13f2 90E0      		ldi r25,hi8(.LC54)
 3947 13f4 0E94 0000 		call uart_puts
 3948               	.LVL364:
 3949 13f8 80E0      		ldi r24,lo8(.LC60)
 3950 13fa 90E0      		ldi r25,hi8(.LC60)
 3951 13fc 0E94 0000 		call uart_puts
 3952               	.LVL365:
 3953 1400 80E0      		ldi r24,lo8(.LC54)
 3954 1402 90E0      		ldi r25,hi8(.LC54)
 3955 1404 0E94 0000 		call uart_puts
 3956               	.LVL366:
 3957 1408 80E0      		ldi r24,lo8(.LC61)
 3958 140a 90E0      		ldi r25,hi8(.LC61)
 3959 140c 0E94 0000 		call uart_puts
 3960               	.LVL367:
 3961 1410 80E0      		ldi r24,lo8(.LC58)
 3962 1412 90E0      		ldi r25,hi8(.LC58)
 3963 1414 0E94 0000 		call uart_puts
 3964               	.LVL368:
 3965 1418 80E0      		ldi r24,lo8(.LC67)
 3966 141a 90E0      		ldi r25,hi8(.LC67)
 3967 141c 0E94 0000 		call uart_puts
 3968               	.LVL369:
 3969 1420 80E0      		ldi r24,lo8(.LC3)
 3970 1422 90E0      		ldi r25,hi8(.LC3)
 3971 1424 0E94 0000 		call uart_puts
 3972               	.LVL370:
 781:main.c        ****     	uart_puts("day");				uart_puts("\t\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0");	
 3973               		.loc 3 781 0
 3974 1428 80E0      		ldi r24,lo8(.LC29)
 3975 142a 90E0      		ldi r25,hi8(.LC29)
 3976 142c 0E94 0000 		call uart_puts
 3977               	.LVL371:
 3978 1430 80E0      		ldi r24,lo8(.LC54)
 3979 1432 90E0      		ldi r25,hi8(.LC54)
 3980 1434 0E94 0000 		call uart_puts
 3981               	.LVL372:
 3982 1438 80E0      		ldi r24,lo8(.LC60)
 3983 143a 90E0      		ldi r25,hi8(.LC60)
 3984 143c 0E94 0000 		call uart_puts
 3985               	.LVL373:
 3986 1440 80E0      		ldi r24,lo8(.LC54)
 3987 1442 90E0      		ldi r25,hi8(.LC54)
 3988 1444 0E94 0000 		call uart_puts
 3989               	.LVL374:
 3990 1448 80E0      		ldi r24,lo8(.LC61)
 3991 144a 90E0      		ldi r25,hi8(.LC61)
 3992 144c 0E94 0000 		call uart_puts
 3993               	.LVL375:
 3994 1450 80E0      		ldi r24,lo8(.LC58)
 3995 1452 90E0      		ldi r25,hi8(.LC58)
 3996 1454 0E94 0000 		call uart_puts
 3997               	.LVL376:
 3998 1458 80E0      		ldi r24,lo8(.LC68)
 3999 145a 90E0      		ldi r25,hi8(.LC68)
 4000 145c 0E94 0000 		call uart_puts
 4001               	.LVL377:
 4002 1460 80E0      		ldi r24,lo8(.LC3)
 4003 1462 90E0      		ldi r25,hi8(.LC3)
 4004 1464 0E94 0000 		call uart_puts
 4005               	.LVL378:
 782:main.c        ****     	uart_puts("celsius");			uart_puts("\t\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0"
 4006               		.loc 3 782 0
 4007 1468 80E0      		ldi r24,lo8(.LC31)
 4008 146a 90E0      		ldi r25,hi8(.LC31)
 4009 146c 0E94 0000 		call uart_puts
 4010               	.LVL379:
 4011 1470 80E0      		ldi r24,lo8(.LC54)
 4012 1472 90E0      		ldi r25,hi8(.LC54)
 4013 1474 0E94 0000 		call uart_puts
 4014               	.LVL380:
 4015 1478 80E0      		ldi r24,lo8(.LC60)
 4016 147a 90E0      		ldi r25,hi8(.LC60)
 4017 147c 0E94 0000 		call uart_puts
 4018               	.LVL381:
 4019 1480 80E0      		ldi r24,lo8(.LC54)
 4020 1482 90E0      		ldi r25,hi8(.LC54)
 4021 1484 0E94 0000 		call uart_puts
 4022               	.LVL382:
 4023 1488 80E0      		ldi r24,lo8(.LC61)
 4024 148a 90E0      		ldi r25,hi8(.LC61)
 4025 148c 0E94 0000 		call uart_puts
 4026               	.LVL383:
 4027 1490 80E0      		ldi r24,lo8(.LC58)
 4028 1492 90E0      		ldi r25,hi8(.LC58)
 4029 1494 0E94 0000 		call uart_puts
 4030               	.LVL384:
 4031 1498 80E0      		ldi r24,lo8(.LC65)
 4032 149a 90E0      		ldi r25,hi8(.LC65)
 4033 149c 0E94 0000 		call uart_puts
 4034               	.LVL385:
 4035 14a0 80E0      		ldi r24,lo8(.LC3)
 4036 14a2 90E0      		ldi r25,hi8(.LC3)
 4037 14a4 0E94 0000 		call uart_puts
 4038               	.LVL386:
 783:main.c        ****     	uart_puts("doecho");			uart_puts("\t\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0")
 4039               		.loc 3 783 0
 4040 14a8 80E0      		ldi r24,lo8(.LC33)
 4041 14aa 90E0      		ldi r25,hi8(.LC33)
 4042 14ac 0E94 0000 		call uart_puts
 4043               	.LVL387:
 4044 14b0 80E0      		ldi r24,lo8(.LC54)
 4045 14b2 90E0      		ldi r25,hi8(.LC54)
 4046 14b4 0E94 0000 		call uart_puts
 4047               	.LVL388:
 4048 14b8 80E0      		ldi r24,lo8(.LC60)
 4049 14ba 90E0      		ldi r25,hi8(.LC60)
 4050 14bc 0E94 0000 		call uart_puts
 4051               	.LVL389:
 4052 14c0 80E0      		ldi r24,lo8(.LC54)
 4053 14c2 90E0      		ldi r25,hi8(.LC54)
 4054 14c4 0E94 0000 		call uart_puts
 4055               	.LVL390:
 4056 14c8 80E0      		ldi r24,lo8(.LC61)
 4057 14ca 90E0      		ldi r25,hi8(.LC61)
 4058 14cc 0E94 0000 		call uart_puts
 4059               	.LVL391:
 4060 14d0 80E0      		ldi r24,lo8(.LC58)
 4061 14d2 90E0      		ldi r25,hi8(.LC58)
 4062 14d4 0E94 0000 		call uart_puts
 4063               	.LVL392:
 4064 14d8 80E0      		ldi r24,lo8(.LC65)
 4065 14da 90E0      		ldi r25,hi8(.LC65)
 4066 14dc 0E94 0000 		call uart_puts
 4067               	.LVL393:
 4068 14e0 80E0      		ldi r24,lo8(.LC3)
 4069 14e2 90E0      		ldi r25,hi8(.LC3)
 4070 14e4 0E94 0000 		call uart_puts
 4071               	.LVL394:
 784:main.c        ****     	uart_puts("accclock");			uart_puts("\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0")
 4072               		.loc 3 784 0
 4073 14e8 80E0      		ldi r24,lo8(.LC69)
 4074 14ea 90E0      		ldi r25,hi8(.LC69)
 4075 14ec 0E94 0000 		call uart_puts
 4076               	.LVL395:
 4077 14f0 80E0      		ldi r24,lo8(.LC56)
 4078 14f2 90E0      		ldi r25,hi8(.LC56)
 4079 14f4 0E94 0000 		call uart_puts
 4080               	.LVL396:
 4081 14f8 80E0      		ldi r24,lo8(.LC60)
 4082 14fa 90E0      		ldi r25,hi8(.LC60)
 4083 14fc 0E94 0000 		call uart_puts
 4084               	.LVL397:
 4085 1500 80E0      		ldi r24,lo8(.LC54)
 4086 1502 90E0      		ldi r25,hi8(.LC54)
 4087 1504 0E94 0000 		call uart_puts
 4088               	.LVL398:
 4089 1508 80E0      		ldi r24,lo8(.LC61)
 4090 150a 90E0      		ldi r25,hi8(.LC61)
 4091 150c 0E94 0000 		call uart_puts
 4092               	.LVL399:
 4093 1510 80E0      		ldi r24,lo8(.LC58)
 4094 1512 90E0      		ldi r25,hi8(.LC58)
 4095 1514 0E94 0000 		call uart_puts
 4096               	.LVL400:
 4097 1518 80E0      		ldi r24,lo8(.LC65)
 4098 151a 90E0      		ldi r25,hi8(.LC65)
 4099 151c 0E94 0000 		call uart_puts
 4100               	.LVL401:
 4101 1520 80E0      		ldi r24,lo8(.LC3)
 4102 1522 90E0      		ldi r25,hi8(.LC3)
 4103 1524 0E94 0000 		call uart_puts
 4104               	.LVL402:
 785:main.c        ****     	uart_puts("xtalisfast");		uart_puts("\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0"
 4105               		.loc 3 785 0
 4106 1528 80E0      		ldi r24,lo8(.LC37)
 4107 152a 90E0      		ldi r25,hi8(.LC37)
 4108 152c 0E94 0000 		call uart_puts
 4109               	.LVL403:
 4110 1530 80E0      		ldi r24,lo8(.LC56)
 4111 1532 90E0      		ldi r25,hi8(.LC56)
 4112 1534 0E94 0000 		call uart_puts
 4113               	.LVL404:
 4114 1538 80E0      		ldi r24,lo8(.LC60)
 4115 153a 90E0      		ldi r25,hi8(.LC60)
 4116 153c 0E94 0000 		call uart_puts
 4117               	.LVL405:
 4118 1540 80E0      		ldi r24,lo8(.LC54)
 4119 1542 90E0      		ldi r25,hi8(.LC54)
 4120 1544 0E94 0000 		call uart_puts
 4121               	.LVL406:
 4122 1548 80E0      		ldi r24,lo8(.LC61)
 4123 154a 90E0      		ldi r25,hi8(.LC61)
 4124 154c 0E94 0000 		call uart_puts
 4125               	.LVL407:
 4126 1550 80E0      		ldi r24,lo8(.LC58)
 4127 1552 90E0      		ldi r25,hi8(.LC58)
 4128 1554 0E94 0000 		call uart_puts
 4129               	.LVL408:
 4130 1558 80E0      		ldi r24,lo8(.LC65)
 4131 155a 90E0      		ldi r25,hi8(.LC65)
 4132 155c 0E94 0000 		call uart_puts
 4133               	.LVL409:
 4134 1560 80E0      		ldi r24,lo8(.LC3)
 4135 1562 90E0      		ldi r25,hi8(.LC3)
 4136 1564 0E94 0000 		call uart_puts
 4137               	.LVL410:
 786:main.c        ****     	uart_puts("showtherm");			uart_puts("\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0"
 4138               		.loc 3 786 0
 4139 1568 80E0      		ldi r24,lo8(.LC38)
 4140 156a 90E0      		ldi r25,hi8(.LC38)
 4141 156c 0E94 0000 		call uart_puts
 4142               	.LVL411:
 4143 1570 80E0      		ldi r24,lo8(.LC56)
 4144 1572 90E0      		ldi r25,hi8(.LC56)
 4145 1574 0E94 0000 		call uart_puts
 4146               	.LVL412:
 4147 1578 80E0      		ldi r24,lo8(.LC60)
 4148 157a 90E0      		ldi r25,hi8(.LC60)
 4149 157c 0E94 0000 		call uart_puts
 4150               	.LVL413:
 4151 1580 80E0      		ldi r24,lo8(.LC54)
 4152 1582 90E0      		ldi r25,hi8(.LC54)
 4153 1584 0E94 0000 		call uart_puts
 4154               	.LVL414:
 4155 1588 80E0      		ldi r24,lo8(.LC61)
 4156 158a 90E0      		ldi r25,hi8(.LC61)
 4157 158c 0E94 0000 		call uart_puts
 4158               	.LVL415:
 4159 1590 80E0      		ldi r24,lo8(.LC58)
 4160 1592 90E0      		ldi r25,hi8(.LC58)
 4161 1594 0E94 0000 		call uart_puts
 4162               	.LVL416:
 4163 1598 80E0      		ldi r24,lo8(.LC65)
 4164 159a 90E0      		ldi r25,hi8(.LC65)
 4165 159c 0E94 0000 		call uart_puts
 4166               	.LVL417:
 4167 15a0 80E0      		ldi r24,lo8(.LC3)
 4168 15a2 90E0      		ldi r25,hi8(.LC3)
 4169 15a4 0E94 0000 		call uart_puts
 4170               	.LVL418:
 787:main.c        ****     	uart_puts("showfreq");			uart_puts("\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0")
 4171               		.loc 3 787 0
 4172 15a8 80E0      		ldi r24,lo8(.LC40)
 4173 15aa 90E0      		ldi r25,hi8(.LC40)
 4174 15ac 0E94 0000 		call uart_puts
 4175               	.LVL419:
 4176 15b0 80E0      		ldi r24,lo8(.LC56)
 4177 15b2 90E0      		ldi r25,hi8(.LC56)
 4178 15b4 0E94 0000 		call uart_puts
 4179               	.LVL420:
 4180 15b8 80E0      		ldi r24,lo8(.LC60)
 4181 15ba 90E0      		ldi r25,hi8(.LC60)
 4182 15bc 0E94 0000 		call uart_puts
 4183               	.LVL421:
 4184 15c0 80E0      		ldi r24,lo8(.LC54)
 4185 15c2 90E0      		ldi r25,hi8(.LC54)
 4186 15c4 0E94 0000 		call uart_puts
 4187               	.LVL422:
 4188 15c8 80E0      		ldi r24,lo8(.LC61)
 4189 15ca 90E0      		ldi r25,hi8(.LC61)
 4190 15cc 0E94 0000 		call uart_puts
 4191               	.LVL423:
 4192 15d0 80E0      		ldi r24,lo8(.LC58)
 4193 15d2 90E0      		ldi r25,hi8(.LC58)
 4194 15d4 0E94 0000 		call uart_puts
 4195               	.LVL424:
 4196 15d8 80E0      		ldi r24,lo8(.LC65)
 4197 15da 90E0      		ldi r25,hi8(.LC65)
 4198 15dc 0E94 0000 		call uart_puts
 4199               	.LVL425:
 4200 15e0 80E0      		ldi r24,lo8(.LC3)
 4201 15e2 90E0      		ldi r25,hi8(.LC3)
 4202 15e4 0E94 0000 		call uart_puts
 4203               	.LVL426:
 788:main.c        ****     	uart_puts("showdate");			uart_puts("\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0")
 4204               		.loc 3 788 0
 4205 15e8 80E0      		ldi r24,lo8(.LC42)
 4206 15ea 90E0      		ldi r25,hi8(.LC42)
 4207 15ec 0E94 0000 		call uart_puts
 4208               	.LVL427:
 4209 15f0 80E0      		ldi r24,lo8(.LC56)
 4210 15f2 90E0      		ldi r25,hi8(.LC56)
 4211 15f4 0E94 0000 		call uart_puts
 4212               	.LVL428:
 4213 15f8 80E0      		ldi r24,lo8(.LC60)
 4214 15fa 90E0      		ldi r25,hi8(.LC60)
 4215 15fc 0E94 0000 		call uart_puts
 4216               	.LVL429:
 4217 1600 80E0      		ldi r24,lo8(.LC54)
 4218 1602 90E0      		ldi r25,hi8(.LC54)
 4219 1604 0E94 0000 		call uart_puts
 4220               	.LVL430:
 4221 1608 80E0      		ldi r24,lo8(.LC61)
 4222 160a 90E0      		ldi r25,hi8(.LC61)
 4223 160c 0E94 0000 		call uart_puts
 4224               	.LVL431:
 4225 1610 80E0      		ldi r24,lo8(.LC58)
 4226 1612 90E0      		ldi r25,hi8(.LC58)
 4227 1614 0E94 0000 		call uart_puts
 4228               	.LVL432:
 4229 1618 80E0      		ldi r24,lo8(.LC65)
 4230 161a 90E0      		ldi r25,hi8(.LC65)
 4231 161c 0E94 0000 		call uart_puts
 4232               	.LVL433:
 4233 1620 80E0      		ldi r24,lo8(.LC3)
 4234 1622 90E0      		ldi r25,hi8(.LC3)
 4235 1624 0E94 0000 		call uart_puts
 4236               	.LVL434:
 789:main.c        ****     	uart_puts("toggleled");			uart_puts("\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts("0"
 4237               		.loc 3 789 0
 4238 1628 80E0      		ldi r24,lo8(.LC44)
 4239 162a 90E0      		ldi r25,hi8(.LC44)
 4240 162c 0E94 0000 		call uart_puts
 4241               	.LVL435:
 4242 1630 80E0      		ldi r24,lo8(.LC56)
 4243 1632 90E0      		ldi r25,hi8(.LC56)
 4244 1634 0E94 0000 		call uart_puts
 4245               	.LVL436:
 4246 1638 80E0      		ldi r24,lo8(.LC60)
 4247 163a 90E0      		ldi r25,hi8(.LC60)
 4248 163c 0E94 0000 		call uart_puts
 4249               	.LVL437:
 4250 1640 80E0      		ldi r24,lo8(.LC54)
 4251 1642 90E0      		ldi r25,hi8(.LC54)
 4252 1644 0E94 0000 		call uart_puts
 4253               	.LVL438:
 4254 1648 80E0      		ldi r24,lo8(.LC61)
 4255 164a 90E0      		ldi r25,hi8(.LC61)
 4256 164c 0E94 0000 		call uart_puts
 4257               	.LVL439:
 4258 1650 80E0      		ldi r24,lo8(.LC58)
 4259 1652 90E0      		ldi r25,hi8(.LC58)
 4260 1654 0E94 0000 		call uart_puts
 4261               	.LVL440:
 4262 1658 80E0      		ldi r24,lo8(.LC65)
 4263 165a 90E0      		ldi r25,hi8(.LC65)
 4264 165c 0E94 0000 		call uart_puts
 4265               	.LVL441:
 4266 1660 80E0      		ldi r24,lo8(.LC3)
 4267 1662 90E0      		ldi r25,hi8(.LC3)
 4268 1664 0E94 0000 		call uart_puts
 4269               	.LVL442:
 790:main.c        ****     	uart_puts("nixiesleepstart");	uart_puts("\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts
 4270               		.loc 3 790 0
 4271 1668 80E0      		ldi r24,lo8(.LC46)
 4272 166a 90E0      		ldi r25,hi8(.LC46)
 4273 166c 0E94 0000 		call uart_puts
 4274               	.LVL443:
 4275 1670 80E0      		ldi r24,lo8(.LC56)
 4276 1672 90E0      		ldi r25,hi8(.LC56)
 4277 1674 0E94 0000 		call uart_puts
 4278               	.LVL444:
 4279 1678 80E0      		ldi r24,lo8(.LC60)
 4280 167a 90E0      		ldi r25,hi8(.LC60)
 4281 167c 0E94 0000 		call uart_puts
 4282               	.LVL445:
 4283 1680 80E0      		ldi r24,lo8(.LC54)
 4284 1682 90E0      		ldi r25,hi8(.LC54)
 4285 1684 0E94 0000 		call uart_puts
 4286               	.LVL446:
 4287 1688 80E0      		ldi r24,lo8(.LC61)
 4288 168a 90E0      		ldi r25,hi8(.LC61)
 4289 168c 0E94 0000 		call uart_puts
 4290               	.LVL447:
 4291 1690 80E0      		ldi r24,lo8(.LC58)
 4292 1692 90E0      		ldi r25,hi8(.LC58)
 4293 1694 0E94 0000 		call uart_puts
 4294               	.LVL448:
 4295 1698 80E0      		ldi r24,lo8(.LC70)
 4296 169a 90E0      		ldi r25,hi8(.LC70)
 4297 169c 0E94 0000 		call uart_puts
 4298               	.LVL449:
 4299 16a0 80E0      		ldi r24,lo8(.LC3)
 4300 16a2 90E0      		ldi r25,hi8(.LC3)
 4301 16a4 0E94 0000 		call uart_puts
 4302               	.LVL450:
 791:main.c        ****     	uart_puts("nixiesleepend");		uart_puts("\t");	uart_puts("=/?");		uart_puts("\t\t");	uart_puts(
 4303               		.loc 3 791 0
 4304 16a8 80E0      		ldi r24,lo8(.LC48)
 4305 16aa 90E0      		ldi r25,hi8(.LC48)
 4306 16ac 0E94 0000 		call uart_puts
 4307               	.LVL451:
 4308 16b0 80E0      		ldi r24,lo8(.LC56)
 4309 16b2 90E0      		ldi r25,hi8(.LC56)
 4310 16b4 0E94 0000 		call uart_puts
 4311               	.LVL452:
 4312 16b8 80E0      		ldi r24,lo8(.LC60)
 4313 16ba 90E0      		ldi r25,hi8(.LC60)
 4314 16bc 0E94 0000 		call uart_puts
 4315               	.LVL453:
 4316 16c0 80E0      		ldi r24,lo8(.LC54)
 4317 16c2 90E0      		ldi r25,hi8(.LC54)
 4318 16c4 0E94 0000 		call uart_puts
 4319               	.LVL454:
 4320 16c8 80E0      		ldi r24,lo8(.LC71)
 4321 16ca 90E0      		ldi r25,hi8(.LC71)
 4322 16cc 0E94 0000 		call uart_puts
 4323               	.LVL455:
 4324 16d0 80E0      		ldi r24,lo8(.LC56)
 4325 16d2 90E0      		ldi r25,hi8(.LC56)
 4326 16d4 0E94 0000 		call uart_puts
 4327               	.LVL456:
 4328 16d8 80E0      		ldi r24,lo8(.LC72)
 4329 16da 90E0      		ldi r25,hi8(.LC72)
 4330 16dc 0E94 0000 		call uart_puts
 4331               	.LVL457:
 4332 16e0 80E0      		ldi r24,lo8(.LC3)
 4333 16e2 90E0      		ldi r25,hi8(.LC3)
 4334 16e4 0E94 0000 		call uart_puts
 4335               	.LVL458:
 792:main.c        ****     	uart_puts("getall");			uart_puts("\t\t");	uart_puts("[ENTER]");	uart_puts( RETURN_NEWLINE );
 4336               		.loc 3 792 0
 4337 16e8 80E0      		ldi r24,lo8(.LC50)
 4338 16ea 90E0      		ldi r25,hi8(.LC50)
 4339 16ec 0E94 0000 		call uart_puts
 4340               	.LVL459:
 4341 16f0 80E0      		ldi r24,lo8(.LC54)
 4342 16f2 90E0      		ldi r25,hi8(.LC54)
 4343 16f4 0E94 0000 		call uart_puts
 4344               	.LVL460:
 4345 16f8 80E0      		ldi r24,lo8(.LC73)
 4346 16fa 90E0      		ldi r25,hi8(.LC73)
 4347 16fc 0E94 0000 		call uart_puts
 4348               	.LVL461:
 4349 1700 80E0      		ldi r24,lo8(.LC3)
 4350 1702 90E0      		ldi r25,hi8(.LC3)
 4351 1704 0E94 0000 		call uart_puts
 4352               	.LVL462:
 793:main.c        ****     	uart_puts("ramtoeeprom");		uart_puts("\t");	uart_puts("[ENTER]");	uart_puts( RETURN_NEWLINE );
 4353               		.loc 3 793 0
 4354 1708 80E0      		ldi r24,lo8(.LC74)
 4355 170a 90E0      		ldi r25,hi8(.LC74)
 4356 170c 0E94 0000 		call uart_puts
 4357               	.LVL463:
 4358 1710 80E0      		ldi r24,lo8(.LC56)
 4359 1712 90E0      		ldi r25,hi8(.LC56)
 4360 1714 0E94 0000 		call uart_puts
 4361               	.LVL464:
 4362 1718 80E0      		ldi r24,lo8(.LC73)
 4363 171a 90E0      		ldi r25,hi8(.LC73)
 4364 171c 0E94 0000 		call uart_puts
 4365               	.LVL465:
 4366 1720 80E0      		ldi r24,lo8(.LC3)
 4367 1722 90E0      		ldi r25,hi8(.LC3)
 4368 1724 0E94 0000 		call uart_puts
 4369               	.LVL466:
 794:main.c        ****     	uart_puts("poke");				uart_puts("\t\t");	uart_puts("[ENTER]");	uart_puts( RETURN_NEWLINE );
 4370               		.loc 3 794 0
 4371 1728 80E0      		ldi r24,lo8(.LC75)
 4372 172a 90E0      		ldi r25,hi8(.LC75)
 4373 172c 0E94 0000 		call uart_puts
 4374               	.LVL467:
 4375 1730 80E0      		ldi r24,lo8(.LC54)
 4376 1732 90E0      		ldi r25,hi8(.LC54)
 4377 1734 0E94 0000 		call uart_puts
 4378               	.LVL468:
 4379 1738 80E0      		ldi r24,lo8(.LC73)
 4380 173a 90E0      		ldi r25,hi8(.LC73)
 4381 173c 0E94 0000 		call uart_puts
 4382               	.LVL469:
 4383 1740 80E0      		ldi r24,lo8(.LC3)
 4384 1742 90E0      		ldi r25,hi8(.LC3)
 4385 1744 0E94 0000 		call uart_puts
 4386               	.LVL470:
 795:main.c        ****     	uart_puts("pwrok");				uart_puts("\t\t");	uart_puts("[ENTER]");	uart_puts( RETURN_NEWLINE );
 4387               		.loc 3 795 0
 4388 1748 80E0      		ldi r24,lo8(.LC76)
 4389 174a 90E0      		ldi r25,hi8(.LC76)
 4390 174c 0E94 0000 		call uart_puts
 4391               	.LVL471:
 4392 1750 80E0      		ldi r24,lo8(.LC54)
 4393 1752 90E0      		ldi r25,hi8(.LC54)
 4394 1754 0E94 0000 		call uart_puts
 4395               	.LVL472:
 4396 1758 80E0      		ldi r24,lo8(.LC73)
 4397 175a 90E0      		ldi r25,hi8(.LC73)
 4398 175c 0E94 0000 		call uart_puts
 4399               	.LVL473:
 4400 1760 80E0      		ldi r24,lo8(.LC3)
 4401 1762 90E0      		ldi r25,hi8(.LC3)
 4402 1764 0E94 0000 		call uart_puts
 4403               	.LVL474:
 796:main.c        ****     	uart_puts("hvfeedback");		uart_puts("\t");	uart_puts("[ENTER]");	uart_puts( RETURN_NEWLINE );
 4404               		.loc 3 796 0
 4405 1768 80E0      		ldi r24,lo8(.LC77)
 4406 176a 90E0      		ldi r25,hi8(.LC77)
 4407 176c 0E94 0000 		call uart_puts
 4408               	.LVL475:
 4409 1770 80E0      		ldi r24,lo8(.LC56)
 4410 1772 90E0      		ldi r25,hi8(.LC56)
 4411 1774 0E94 0000 		call uart_puts
 4412               	.LVL476:
 4413 1778 80E0      		ldi r24,lo8(.LC73)
 4414 177a 90E0      		ldi r25,hi8(.LC73)
 4415 177c 0E94 0000 		call uart_puts
 4416               	.LVL477:
 4417 1780 80E0      		ldi r24,lo8(.LC3)
 4418 1782 90E0      		ldi r25,hi8(.LC3)
 4419 1784 0E94 0000 		call uart_puts
 4420               	.LVL478:
 797:main.c        ****     	uart_puts("battvoltage");		uart_puts("\t");	uart_puts("[ENTER]");	uart_puts( RETURN_NEWLINE );
 4421               		.loc 3 797 0
 4422 1788 80E0      		ldi r24,lo8(.LC78)
 4423 178a 90E0      		ldi r25,hi8(.LC78)
 4424 178c 0E94 0000 		call uart_puts
 4425               	.LVL479:
 4426 1790 80E0      		ldi r24,lo8(.LC56)
 4427 1792 90E0      		ldi r25,hi8(.LC56)
 4428 1794 0E94 0000 		call uart_puts
 4429               	.LVL480:
 4430 1798 80E0      		ldi r24,lo8(.LC73)
 4431 179a 90E0      		ldi r25,hi8(.LC73)
 4432 179c 0E94 0000 		call uart_puts
 4433               	.LVL481:
 4434 17a0 80E0      		ldi r24,lo8(.LC3)
 4435 17a2 90E0      		ldi r25,hi8(.LC3)
 4436 17a4 0E94 0000 		call uart_puts
 4437               	.LVL482:
 798:main.c        ****     	uart_puts("rectifiedac");		uart_puts("\t");	uart_puts("[ENTER]");	uart_puts( RETURN_NEWLINE );
 4438               		.loc 3 798 0
 4439 17a8 80E0      		ldi r24,lo8(.LC79)
 4440 17aa 90E0      		ldi r25,hi8(.LC79)
 4441 17ac 0E94 0000 		call uart_puts
 4442               	.LVL483:
 4443 17b0 80E0      		ldi r24,lo8(.LC56)
 4444 17b2 90E0      		ldi r25,hi8(.LC56)
 4445 17b4 0E94 0000 		call uart_puts
 4446               	.LVL484:
 4447 17b8 80E0      		ldi r24,lo8(.LC73)
 4448 17ba 90E0      		ldi r25,hi8(.LC73)
 4449 17bc 0E94 0000 		call uart_puts
 4450               	.LVL485:
 4451 17c0 80E0      		ldi r24,lo8(.LC3)
 4452 17c2 90E0      		ldi r25,hi8(.LC3)
 4453 17c4 00C0      		rjmp .L212
 4454               	.L149:
 801:main.c        ****     else if(strcasestr(myUartString,"ramtoeeprom") != NULL){
 4455               		.loc 3 801 0
 4456 17c6 60E0      		ldi r22,lo8(.LC74)
 4457 17c8 70E0      		ldi r23,hi8(.LC74)
 4458 17ca 80E0      		ldi r24,lo8(myUartString)
 4459 17cc 90E0      		ldi r25,hi8(myUartString)
 4460 17ce 0E94 0000 		call strcasestr
 4461               	.LVL486:
 4462 17d2 892B      		or r24,r25
 4463 17d4 01F0      		breq .L150
 802:main.c        ****     	updateVarsToEeprom();   
 4464               		.loc 3 802 0
 4465 17d6 0E94 0000 		call updateVarsToEeprom
 4466               	.LVL487:
 803:main.c        **** 		uart_puts( "EEPROM Storage Complete");
 4467               		.loc 3 803 0
 4468 17da 80E0      		ldi r24,lo8(.LC80)
 4469 17dc 90E0      		ldi r25,hi8(.LC80)
 4470 17de 00C0      		rjmp .L212
 4471               	.L150:
 806:main.c        ****     else if(strstr(myUartString,"poke") != NULL){
 4472               		.loc 3 806 0
 4473 17e0 60E0      		ldi r22,lo8(.LC75)
 4474 17e2 70E0      		ldi r23,hi8(.LC75)
 4475 17e4 80E0      		ldi r24,lo8(myUartString)
 4476 17e6 90E0      		ldi r25,hi8(myUartString)
 4477 17e8 0E94 0000 		call strstr
 4478               	.LVL488:
 4479 17ec 892B      		or r24,r25
 4480 17ee 01F0      		breq .L151
 808:main.c        ****         uart_puts( "Hello!");
 4481               		.loc 3 808 0
 4482 17f0 80E0      		ldi r24,lo8(.LC81)
 4483 17f2 90E0      		ldi r25,hi8(.LC81)
 4484 17f4 0E94 0000 		call uart_puts
 4485               	.LVL489:
 809:main.c        ****         uart_puts( RETURN_NEWLINE );
 4486               		.loc 3 809 0
 4487 17f8 80E0      		ldi r24,lo8(.LC3)
 4488 17fa 90E0      		ldi r25,hi8(.LC3)
 4489 17fc 0E94 0000 		call uart_puts
 4490               	.LVL490:
 810:main.c        ****         uart_puts( "I'm Serial Number: ");
 4491               		.loc 3 810 0
 4492 1800 80E0      		ldi r24,lo8(.LC82)
 4493 1802 90E0      		ldi r25,hi8(.LC82)
 4494 1804 0E94 0000 		call uart_puts
 4495               	.LVL491:
 811:main.c        ****         uart_puts( itoa( SERIAL_NUMBER, printBuffer, 10 ) );
 4496               		.loc 3 811 0
 4497 1808 4AE0      		ldi r20,lo8(10)
 4498 180a 50E0      		ldi r21,0
 4499 180c 60E0      		ldi r22,lo8(printBuffer)
 4500 180e 70E0      		ldi r23,hi8(printBuffer)
 4501 1810 84E6      		ldi r24,lo8(100)
 4502 1812 90E0      		ldi r25,0
 4503 1814 0E94 0000 		call itoa
 4504               	.LVL492:
 4505 1818 00C0      		rjmp .L212
 4506               	.L151:
 815:main.c        ****     else if(strstr(myUartString,"pwrok") != NULL){
 4507               		.loc 3 815 0
 4508 181a 60E0      		ldi r22,lo8(.LC76)
 4509 181c 70E0      		ldi r23,hi8(.LC76)
 4510 181e 80E0      		ldi r24,lo8(myUartString)
 4511 1820 90E0      		ldi r25,hi8(myUartString)
 4512 1822 0E94 0000 		call strstr
 4513               	.LVL493:
 4514 1826 892B      		or r24,r25
 4515 1828 01F0      		breq .L152
 4516               	.LBB257:
 817:main.c        ****         double pwrokVolts = adc_raw[0] * 0.019375;
 4517               		.loc 3 817 0
 4518 182a 6091 0000 		lds r22,adc_raw
 4519               	.LVL494:
 4520 182e 00C0      		rjmp .L214
 4521               	.LVL495:
 4522               	.L152:
 4523               	.LBE257:
 822:main.c        ****     else if(strstr(myUartString,"hvfeedback") != NULL){
 4524               		.loc 3 822 0
 4525 1830 60E0      		ldi r22,lo8(.LC77)
 4526 1832 70E0      		ldi r23,hi8(.LC77)
 4527 1834 80E0      		ldi r24,lo8(myUartString)
 4528 1836 90E0      		ldi r25,hi8(myUartString)
 4529 1838 0E94 0000 		call strstr
 4530               	.LVL496:
 4531 183c 892B      		or r24,r25
 4532 183e 01F0      		breq .L153
 4533               	.LBB258:
 824:main.c        ****         double hvVolts = adc_raw[1] * 1.9375;
 4534               		.loc 3 824 0
 4535 1840 6091 0000 		lds r22,adc_raw+1
 4536               	.LVL497:
 4537 1844 70E0      		ldi r23,0
 4538 1846 80E0      		ldi r24,0
 4539 1848 90E0      		ldi r25,0
 4540 184a 0E94 0000 		call __floatsisf
 4541               	.LVL498:
 4542 184e 20E0      		ldi r18,0
 4543 1850 30E0      		ldi r19,0
 4544 1852 48EF      		ldi r20,lo8(-8)
 4545 1854 5FE3      		ldi r21,lo8(63)
 4546 1856 00C0      		rjmp .L213
 4547               	.L153:
 4548               	.LBE258:
 829:main.c        ****     else if(strstr(myUartString,"battvoltage") != NULL){
 4549               		.loc 3 829 0
 4550 1858 60E0      		ldi r22,lo8(.LC78)
 4551 185a 70E0      		ldi r23,hi8(.LC78)
 4552 185c 80E0      		ldi r24,lo8(myUartString)
 4553 185e 90E0      		ldi r25,hi8(myUartString)
 4554 1860 0E94 0000 		call strstr
 4555               	.LVL499:
 4556 1864 892B      		or r24,r25
 4557 1866 01F0      		breq .L154
 4558               	.LBB259:
 831:main.c        ****         double battVolts = adc_raw[2] * 0.019375;
 4559               		.loc 3 831 0
 4560 1868 6091 0000 		lds r22,adc_raw+2
 4561               	.L214:
 4562               	.LVL500:
 4563 186c 70E0      		ldi r23,0
 4564 186e 80E0      		ldi r24,0
 4565 1870 90E0      		ldi r25,0
 4566 1872 0E94 0000 		call __floatsisf
 4567               	.LVL501:
 4568 1876 22E5      		ldi r18,lo8(82)
 4569 1878 38EB      		ldi r19,lo8(-72)
 4570 187a 4EE9      		ldi r20,lo8(-98)
 4571 187c 5CE3      		ldi r21,lo8(60)
 4572 187e 00C0      		rjmp .L213
 4573               	.L154:
 4574               	.LBE259:
 836:main.c        ****     else if(strstr(myUartString,"rectifiedac") != NULL){
 4575               		.loc 3 836 0
 4576 1880 60E0      		ldi r22,lo8(.LC79)
 4577 1882 70E0      		ldi r23,hi8(.LC79)
 4578 1884 80E0      		ldi r24,lo8(myUartString)
 4579 1886 90E0      		ldi r25,hi8(myUartString)
 4580 1888 0E94 0000 		call strstr
 4581               	.LVL502:
 4582 188c 892B      		or r24,r25
 4583 188e 01F0      		breq .L94
 4584               	.LBB260:
 840:main.c        ****         double rectVolts = adc_raw[3] * 0.11;
 4585               		.loc 3 840 0
 4586 1890 6091 0000 		lds r22,adc_raw+3
 4587               	.LVL503:
 4588 1894 70E0      		ldi r23,0
 4589 1896 80E0      		ldi r24,0
 4590 1898 90E0      		ldi r25,0
 4591 189a 0E94 0000 		call __floatsisf
 4592               	.LVL504:
 4593 189e 2EEA      		ldi r18,lo8(-82)
 4594 18a0 37E4      		ldi r19,lo8(71)
 4595 18a2 41EE      		ldi r20,lo8(-31)
 4596 18a4 5DE3      		ldi r21,lo8(61)
 4597               	.L213:
 4598 18a6 0E94 0000 		call __mulsf3
 4599               	.LVL505:
 841:main.c        ****         dtostrf(rectVolts , 10, 2, printBuffer);
 4600               		.loc 3 841 0
 4601 18aa 00E0      		ldi r16,lo8(printBuffer)
 4602 18ac 10E0      		ldi r17,hi8(printBuffer)
 4603               	.L211:
 4604 18ae 22E0      		ldi r18,lo8(2)
 4605 18b0 4AE0      		ldi r20,lo8(10)
 4606 18b2 0E94 0000 		call dtostrf
 4607               	.LVL506:
 842:main.c        ****         uart_puts(printBuffer);
 4608               		.loc 3 842 0
 4609 18b6 C801      		movw r24,r16
 4610               	.L212:
 4611 18b8 0E94 0000 		call uart_puts
 4612               	.LVL507:
 4613               	.L94:
 4614               	.LBE260:
 844:main.c        ****     uart_puts( RETURN_NEWLINE );
 4615               		.loc 3 844 0
 4616 18bc 80E0      		ldi r24,lo8(.LC3)
 4617 18be 90E0      		ldi r25,hi8(.LC3)
 4618               	/* epilogue start */
 845:main.c        **** }
 4619               		.loc 3 845 0
 4620 18c0 1F91      		pop r17
 4621 18c2 0F91      		pop r16
 4622 18c4 FF90      		pop r15
 4623 18c6 EF90      		pop r14
 4624 18c8 DF90      		pop r13
 4625 18ca CF90      		pop r12
 844:main.c        ****     uart_puts( RETURN_NEWLINE );
 4626               		.loc 3 844 0
 4627 18cc 0C94 0000 		jmp uart_puts
 4628               	.LVL508:
 4629               	.L96:
 533:main.c        ****             		hours = splitString(myUartString);
 4630               		.loc 3 533 0
 4631 18d0 80E0      		ldi r24,lo8(myUartString)
 4632 18d2 90E0      		ldi r25,hi8(myUartString)
 4633 18d4 0E94 0000 		call splitString
 4634               	.LVL509:
 4635 18d8 6093 0000 		sts hours,r22
 4636 18dc 00C0      		rjmp .L94
 4637               	.LVL510:
 4638               	.L100:
 544:main.c        ****             		minutes = splitString(myUartString);
 4639               		.loc 3 544 0
 4640 18de 80E0      		ldi r24,lo8(myUartString)
 4641 18e0 90E0      		ldi r25,hi8(myUartString)
 4642 18e2 0E94 0000 		call splitString
 4643               	.LVL511:
 4644 18e6 6093 0000 		sts minutes,r22
 4645 18ea 00C0      		rjmp .L94
 4646               	.LVL512:
 4647               	.L103:
 555:main.c        ****             		seconds = splitString(myUartString);
 4648               		.loc 3 555 0
 4649 18ec 80E0      		ldi r24,lo8(myUartString)
 4650 18ee 90E0      		ldi r25,hi8(myUartString)
 4651 18f0 0E94 0000 		call splitString
 4652               	.LVL513:
 4653 18f4 6093 0000 		sts seconds,r22
 4654 18f8 00C0      		rjmp .L94
 4655               	.LVL514:
 4656               	.L108:
 577:main.c        ****             		miltime = splitString(myUartString);
 4657               		.loc 3 577 0
 4658 18fa 80E0      		ldi r24,lo8(myUartString)
 4659 18fc 90E0      		ldi r25,hi8(myUartString)
 4660 18fe 0E94 0000 		call splitString
 4661               	.LVL515:
 4662 1902 6093 0000 		sts miltime,r22
 4663 1906 00C0      		rjmp .L94
 4664               	.LVL516:
 4665               	.L111:
 588:main.c        ****             		year = splitString(myUartString);
 4666               		.loc 3 588 0
 4667 1908 80E0      		ldi r24,lo8(myUartString)
 4668 190a 90E0      		ldi r25,hi8(myUartString)
 4669 190c 0E94 0000 		call splitString
 4670               	.LVL517:
 4671 1910 7093 0000 		sts year+1,r23
 4672 1914 6093 0000 		sts year,r22
 4673 1918 00C0      		rjmp .L94
 4674               	.LVL518:
 4675               	.L114:
 599:main.c        ****             		month = splitString(myUartString);
 4676               		.loc 3 599 0
 4677 191a 80E0      		ldi r24,lo8(myUartString)
 4678 191c 90E0      		ldi r25,hi8(myUartString)
 4679 191e 0E94 0000 		call splitString
 4680               	.LVL519:
 4681 1922 6093 0000 		sts month,r22
 4682 1926 00C0      		rjmp .L94
 4683               	.LVL520:
 4684               	.L117:
 610:main.c        ****             		day = splitString(myUartString);
 4685               		.loc 3 610 0
 4686 1928 80E0      		ldi r24,lo8(myUartString)
 4687 192a 90E0      		ldi r25,hi8(myUartString)
 4688 192c 0E94 0000 		call splitString
 4689               	.LVL521:
 4690 1930 6093 0000 		sts day,r22
 4691 1934 00C0      		rjmp .L94
 4692               	.LVL522:
 4693               	.L120:
 621:main.c        ****             		celsius = splitString(myUartString);
 4694               		.loc 3 621 0
 4695 1936 80E0      		ldi r24,lo8(myUartString)
 4696 1938 90E0      		ldi r25,hi8(myUartString)
 4697 193a 0E94 0000 		call splitString
 4698               	.LVL523:
 4699 193e 6093 0000 		sts celsius,r22
 4700 1942 00C0      		rjmp .L94
 4701               	.LVL524:
 4702               	.L123:
 632:main.c        ****             		doecho = splitString(myUartString);
 4703               		.loc 3 632 0
 4704 1944 80E0      		ldi r24,lo8(myUartString)
 4705 1946 90E0      		ldi r25,hi8(myUartString)
 4706 1948 0E94 0000 		call splitString
 4707               	.LVL525:
 4708 194c 6093 0000 		sts doecho,r22
 4709 1950 00C0      		rjmp .L94
 4710               	.LVL526:
 4711               	.L126:
 643:main.c        ****             		acclock = splitString(myUartString);
 4712               		.loc 3 643 0
 4713 1952 80E0      		ldi r24,lo8(myUartString)
 4714 1954 90E0      		ldi r25,hi8(myUartString)
 4715 1956 0E94 0000 		call splitString
 4716               	.LVL527:
 4717 195a 6093 0000 		sts acclock,r22
 4718 195e 00C0      		rjmp .L94
 4719               	.LVL528:
 4720               	.L129:
 654:main.c        ****             		xtalisfast = splitString(myUartString);
 4721               		.loc 3 654 0
 4722 1960 80E0      		ldi r24,lo8(myUartString)
 4723 1962 90E0      		ldi r25,hi8(myUartString)
 4724 1964 0E94 0000 		call splitString
 4725               	.LVL529:
 4726 1968 6093 0000 		sts xtalisfast,r22
 4727 196c 00C0      		rjmp .L94
 4728               	.LVL530:
 4729               	.L132:
 665:main.c        ****             		showtherm = splitString(myUartString);
 4730               		.loc 3 665 0
 4731 196e 80E0      		ldi r24,lo8(myUartString)
 4732 1970 90E0      		ldi r25,hi8(myUartString)
 4733 1972 0E94 0000 		call splitString
 4734               	.LVL531:
 4735 1976 6093 0000 		sts showtherm,r22
 4736 197a 00C0      		rjmp .L94
 4737               	.LVL532:
 4738               	.L135:
 676:main.c        ****             		showfreq = splitString(myUartString);
 4739               		.loc 3 676 0
 4740 197c 80E0      		ldi r24,lo8(myUartString)
 4741 197e 90E0      		ldi r25,hi8(myUartString)
 4742 1980 0E94 0000 		call splitString
 4743               	.LVL533:
 4744 1984 6093 0000 		sts showfreq,r22
 4745 1988 00C0      		rjmp .L94
 4746               	.LVL534:
 4747               	.L138:
 687:main.c        ****             		showdate = splitString(myUartString);
 4748               		.loc 3 687 0
 4749 198a 80E0      		ldi r24,lo8(myUartString)
 4750 198c 90E0      		ldi r25,hi8(myUartString)
 4751 198e 0E94 0000 		call splitString
 4752               	.LVL535:
 4753 1992 6093 0000 		sts showdate,r22
 4754 1996 00C0      		rjmp .L94
 4755               	.LVL536:
 4756               	.L141:
 698:main.c        ****             		toggleled = splitString(myUartString);
 4757               		.loc 3 698 0
 4758 1998 80E0      		ldi r24,lo8(myUartString)
 4759 199a 90E0      		ldi r25,hi8(myUartString)
 4760 199c 0E94 0000 		call splitString
 4761               	.LVL537:
 4762 19a0 6093 0000 		sts toggleled,r22
 4763 19a4 00C0      		rjmp .L94
 4764               	.LVL538:
 4765               	.L144:
 709:main.c        ****             		nixiesleepstart = splitString(myUartString);
 4766               		.loc 3 709 0
 4767 19a6 80E0      		ldi r24,lo8(myUartString)
 4768 19a8 90E0      		ldi r25,hi8(myUartString)
 4769 19aa 0E94 0000 		call splitString
 4770               	.LVL539:
 4771 19ae 6093 0000 		sts nixiesleepstart,r22
 4772 19b2 7093 0000 		sts nixiesleepstart+1,r23
 4773 19b6 8093 0000 		sts nixiesleepstart+2,r24
 4774 19ba 9093 0000 		sts nixiesleepstart+3,r25
 4775 19be 00C0      		rjmp .L94
 4776               	.LVL540:
 4777               	.L147:
 720:main.c        ****             		nixiesleepend = splitString(myUartString);
 4778               		.loc 3 720 0
 4779 19c0 80E0      		ldi r24,lo8(myUartString)
 4780 19c2 90E0      		ldi r25,hi8(myUartString)
 4781 19c4 0E94 0000 		call splitString
 4782               	.LVL541:
 4783 19c8 6093 0000 		sts nixiesleepend,r22
 4784 19cc 7093 0000 		sts nixiesleepend+1,r23
 4785 19d0 8093 0000 		sts nixiesleepend+2,r24
 4786 19d4 9093 0000 		sts nixiesleepend+3,r25
 4787 19d8 00C0      		rjmp .L94
 4788               		.cfi_endproc
 4789               	.LFE27:
 4791               	.global	checkSerialIn
 4793               	checkSerialIn:
 4794               	.LFB31:
 885:main.c        **** {
 4795               		.loc 3 885 0
 4796               		.cfi_startproc
 4797 19da CF93      		push r28
 4798               	.LCFI53:
 4799               		.cfi_def_cfa_offset 3
 4800               		.cfi_offset 28, -2
 4801 19dc DF93      		push r29
 4802               	.LCFI54:
 4803               		.cfi_def_cfa_offset 4
 4804               		.cfi_offset 29, -3
 4805               	/* prologue: function */
 4806               	/* frame size = 0 */
 4807               	/* stack size = 2 */
 4808               	.L__stack_usage = 2
 887:main.c        ****     unsigned int aChar = uart_getc();
 4809               		.loc 3 887 0
 4810 19de 0E94 0000 		call uart_getc
 4811               	.LVL542:
 4812 19e2 EC01      		movw r28,r24
 4813               	.LVL543:
 889:main.c        ****     if ( aChar & UART_NO_DATA )
 4814               		.loc 3 889 0
 4815 19e4 90FD      		sbrc r25,0
 4816 19e6 00C0      		rjmp .L215
 902:main.c        ****         if ( aChar & UART_FRAME_ERROR )
 4817               		.loc 3 902 0
 4818 19e8 93FF      		sbrs r25,3
 4819 19ea 00C0      		rjmp .L218
 905:main.c        ****             uart_puts_P("UART Frame Error: ");
 4820               		.loc 3 905 0
 4821 19ec 80E0      		ldi r24,lo8(__c.2230)
 4822 19ee 90E0      		ldi r25,hi8(__c.2230)
 4823               	.LVL544:
 4824 19f0 0E94 0000 		call uart_puts_p
 4825               	.LVL545:
 4826               	.L218:
 907:main.c        ****         if ( aChar & UART_OVERRUN_ERROR )
 4827               		.loc 3 907 0
 4828 19f4 D2FF      		sbrs r29,2
 4829 19f6 00C0      		rjmp .L219
 914:main.c        ****             uart_puts_P("UART Overrun Error: ");
 4830               		.loc 3 914 0
 4831 19f8 80E0      		ldi r24,lo8(__c.2232)
 4832 19fa 90E0      		ldi r25,hi8(__c.2232)
 4833 19fc 0E94 0000 		call uart_puts_p
 4834               	.LVL546:
 4835               	.L219:
 916:main.c        ****         if ( aChar & UART_BUFFER_OVERFLOW )
 4836               		.loc 3 916 0
 4837 1a00 D1FF      		sbrs r29,1
 4838 1a02 00C0      		rjmp .L220
 922:main.c        ****             uart_puts_P("Buffer overflow error: ");
 4839               		.loc 3 922 0
 4840 1a04 80E0      		ldi r24,lo8(__c.2234)
 4841 1a06 90E0      		ldi r25,hi8(__c.2234)
 4842 1a08 0E94 0000 		call uart_puts_p
 4843               	.LVL547:
 4844               	.L220:
 929:main.c        ****     uartString[uartStringIndex] = aChar;
 4845               		.loc 3 929 0
 4846 1a0c 8091 0000 		lds r24,uartStringIndex
 4847 1a10 DC2F      		mov r29,r28
 4848 1a12 E82F      		mov r30,r24
 4849 1a14 F0E0      		ldi r31,0
 4850 1a16 E050      		subi r30,lo8(-(uartString))
 4851 1a18 F040      		sbci r31,hi8(-(uartString))
 4852 1a1a C083      		st Z,r28
 932:main.c        ****     if (uartString[uartStringIndex] == CHAR_RETURN) {
 4853               		.loc 3 932 0
 4854 1a1c CD30      		cpi r28,lo8(13)
 4855 1a1e 01F4      		brne .L221
 934:main.c        ****         uartStringIndex = 0;
 4856               		.loc 3 934 0
 4857 1a20 1092 0000 		sts uartStringIndex,__zero_reg__
 935:main.c        ****         uart_puts(RETURN_NEWLINE);
 4858               		.loc 3 935 0
 4859 1a24 80E0      		ldi r24,lo8(.LC3)
 4860 1a26 90E0      		ldi r25,hi8(.LC3)
 4861 1a28 0E94 0000 		call uart_puts
 4862               	.LVL548:
 937:main.c        ****         copy_command();
 4863               		.loc 3 937 0
 4864 1a2c 0E94 0000 		call copy_command
 4865               	.LVL549:
 938:main.c        ****         process_command();
 4866               		.loc 3 938 0
 4867 1a30 0E94 0000 		call process_command
 4868               	.LVL550:
 4869 1a34 00C0      		rjmp .L222
 4870               	.L221:
 941:main.c        ****         uartStringIndex++;
 4871               		.loc 3 941 0
 4872 1a36 8F5F      		subi r24,lo8(-(1))
 4873 1a38 8093 0000 		sts uartStringIndex,r24
 4874               	.L222:
 944:main.c        ****     if( doecho ){
 4875               		.loc 3 944 0
 4876 1a3c 8091 0000 		lds r24,doecho
 4877 1a40 8823      		tst r24
 4878 1a42 01F0      		breq .L215
 945:main.c        ****     	uart_putc( (unsigned char)aChar ); //echo
 4879               		.loc 3 945 0
 4880 1a44 8D2F      		mov r24,r29
 4881               	/* epilogue start */
 949:main.c        **** }
 4882               		.loc 3 949 0
 4883 1a46 DF91      		pop r29
 4884 1a48 CF91      		pop r28
 4885               	.LVL551:
 945:main.c        ****     	uart_putc( (unsigned char)aChar ); //echo
 4886               		.loc 3 945 0
 4887 1a4a 0C94 0000 		jmp uart_putc
 4888               	.LVL552:
 4889               	.L215:
 4890               	/* epilogue start */
 949:main.c        **** }
 4891               		.loc 3 949 0
 4892 1a4e DF91      		pop r29
 4893 1a50 CF91      		pop r28
 4894               	.LVL553:
 4895 1a52 0895      		ret
 4896               		.cfi_endproc
 4897               	.LFE31:
 4899               	.global	acPowerOk
 4901               	acPowerOk:
 4902               	.LFB46:
1358:main.c        **** 
1359:main.c        **** }
1360:main.c        **** 
1361:main.c        **** 
1362:main.c        **** 
1363:main.c        **** 
1364:main.c        **** uint8_t acPowerOk( void )
1365:main.c        **** {
 4903               		.loc 3 1365 0
 4904               		.cfi_startproc
 4905               	/* prologue: function */
 4906               	/* frame size = 0 */
 4907               	/* stack size = 0 */
 4908               	.L__stack_usage = 0
1366:main.c        **** 	if( adc_raw[0] < 51 ){	// If PWR_OK < ~2 V
 4909               		.loc 3 1366 0
 4910 1a54 9091 0000 		lds r25,adc_raw
 4911 1a58 81E0      		ldi r24,lo8(1)
 4912 1a5a 9333      		cpi r25,lo8(51)
 4913 1a5c 00F4      		brsh .L237
 4914 1a5e 80E0      		ldi r24,0
 4915               	.L237:
1367:main.c        **** 		return 0;
1368:main.c        **** 	}else{
1369:main.c        **** 		return 1;
1370:main.c        **** 	}
1371:main.c        **** 
1372:main.c        **** }
 4916               		.loc 3 1372 0
 4917 1a60 0895      		ret
 4918               		.cfi_endproc
 4919               	.LFE46:
 4921               	.global	__vector_11
 4923               	__vector_11:
 4924               	.LFB34:
 994:main.c        **** {
 4925               		.loc 3 994 0
 4926               		.cfi_startproc
 4927 1a62 1F92      		push r1
 4928               	.LCFI55:
 4929               		.cfi_def_cfa_offset 3
 4930               		.cfi_offset 1, -2
 4931 1a64 0F92      		push r0
 4932               	.LCFI56:
 4933               		.cfi_def_cfa_offset 4
 4934               		.cfi_offset 0, -3
 4935 1a66 0FB6      		in r0,__SREG__
 4936 1a68 0F92      		push r0
 4937 1a6a 1124      		clr __zero_reg__
 4938 1a6c 2F93      		push r18
 4939               	.LCFI57:
 4940               		.cfi_def_cfa_offset 5
 4941               		.cfi_offset 18, -4
 4942 1a6e 3F93      		push r19
 4943               	.LCFI58:
 4944               		.cfi_def_cfa_offset 6
 4945               		.cfi_offset 19, -5
 4946 1a70 4F93      		push r20
 4947               	.LCFI59:
 4948               		.cfi_def_cfa_offset 7
 4949               		.cfi_offset 20, -6
 4950 1a72 5F93      		push r21
 4951               	.LCFI60:
 4952               		.cfi_def_cfa_offset 8
 4953               		.cfi_offset 21, -7
 4954 1a74 6F93      		push r22
 4955               	.LCFI61:
 4956               		.cfi_def_cfa_offset 9
 4957               		.cfi_offset 22, -8
 4958 1a76 7F93      		push r23
 4959               	.LCFI62:
 4960               		.cfi_def_cfa_offset 10
 4961               		.cfi_offset 23, -9
 4962 1a78 8F93      		push r24
 4963               	.LCFI63:
 4964               		.cfi_def_cfa_offset 11
 4965               		.cfi_offset 24, -10
 4966 1a7a 9F93      		push r25
 4967               	.LCFI64:
 4968               		.cfi_def_cfa_offset 12
 4969               		.cfi_offset 25, -11
 4970 1a7c AF93      		push r26
 4971               	.LCFI65:
 4972               		.cfi_def_cfa_offset 13
 4973               		.cfi_offset 26, -12
 4974 1a7e BF93      		push r27
 4975               	.LCFI66:
 4976               		.cfi_def_cfa_offset 14
 4977               		.cfi_offset 27, -13
 4978 1a80 EF93      		push r30
 4979               	.LCFI67:
 4980               		.cfi_def_cfa_offset 15
 4981               		.cfi_offset 30, -14
 4982 1a82 FF93      		push r31
 4983               	.LCFI68:
 4984               		.cfi_def_cfa_offset 16
 4985               		.cfi_offset 31, -15
 4986               	/* prologue: Signal */
 4987               	/* frame size = 0 */
 4988               	/* stack size = 15 */
 4989               	.L__stack_usage = 15
 4990               	.LVL554:
 999:main.c        ****     milliSeconds++;
 4991               		.loc 3 999 0
 4992 1a84 2091 0000 		lds r18,milliSeconds.2247
 4993 1a88 3091 0000 		lds r19,milliSeconds.2247+1
 4994 1a8c 2F5F      		subi r18,-1
 4995 1a8e 3F4F      		sbci r19,-1
 4996 1a90 3093 0000 		sts milliSeconds.2247+1,r19
 4997 1a94 2093 0000 		sts milliSeconds.2247,r18
1000:main.c        ****     clockCalCounter++;
 4998               		.loc 3 1000 0
 4999 1a98 8091 0000 		lds r24,clockCalCounter.2248
 5000 1a9c 9091 0000 		lds r25,clockCalCounter.2248+1
 5001 1aa0 A091 0000 		lds r26,clockCalCounter.2248+2
 5002 1aa4 B091 0000 		lds r27,clockCalCounter.2248+3
 5003 1aa8 0196      		adiw r24,1
 5004 1aaa A11D      		adc r26,__zero_reg__
 5005 1aac B11D      		adc r27,__zero_reg__
 5006 1aae 8093 0000 		sts clockCalCounter.2248,r24
 5007 1ab2 9093 0000 		sts clockCalCounter.2248+1,r25
 5008 1ab6 A093 0000 		sts clockCalCounter.2248+2,r26
 5009 1aba B093 0000 		sts clockCalCounter.2248+3,r27
1003:main.c        ****     if( milliSeconds >= MS_IN_SEC )
 5010               		.loc 3 1003 0
 5011 1abe 283E      		cpi r18,-24
 5012 1ac0 3340      		sbci r19,3
 5013 1ac2 00F0      		brlo .L239
1005:main.c        ****     	if( acclock == 0 || acPowerOk() == 0 ){	// If we are meant to use the internal xtal, not power
 5014               		.loc 3 1005 0
 5015 1ac4 8091 0000 		lds r24,acclock
 5016 1ac8 8111      		cpse r24,__zero_reg__
 5017 1aca 00C0      		rjmp .L240
 5018               	.L242:
1007:main.c        ****         	seconds++;          // increment seconds
 5019               		.loc 3 1007 0
 5020 1acc 8091 0000 		lds r24,seconds
 5021 1ad0 8F5F      		subi r24,lo8(-(1))
 5022 1ad2 8093 0000 		sts seconds,r24
 5023 1ad6 00C0      		rjmp .L241
 5024               	.L240:
1005:main.c        ****     	if( acclock == 0 || acPowerOk() == 0 ){	// If we are meant to use the internal xtal, not power
 5025               		.loc 3 1005 0 discriminator 1
 5026 1ad8 0E94 0000 		call acPowerOk
 5027               	.LVL555:
 5028 1adc 8823      		tst r24
 5029 1ade 01F0      		breq .L242
 5030               	.L241:
1010:main.c        ****         	milliSeconds = 0;   // reset milliseconds
 5031               		.loc 3 1010 0
 5032 1ae0 1092 0000 		sts milliSeconds.2247+1,__zero_reg__
 5033 1ae4 1092 0000 		sts milliSeconds.2247,__zero_reg__
1012:main.c        ****         	if( toggleled )		// Clearly toggling the LED is only available when using the internal xta
 5034               		.loc 3 1012 0
 5035 1ae8 8091 0000 		lds r24,toggleled
 5036 1aec 8111      		cpse r24,__zero_reg__
1013:main.c        ****         		toggle_led();	// Toggle the LED if allowed.
 5037               		.loc 3 1013 0
 5038 1aee 0E94 0000 		call toggle_led
 5039               	.LVL556:
 5040               	.L243:
1014:main.c        ****         	acFreqFiltCtr++;	// Increment the frequency filter counter.	
 5041               		.loc 3 1014 0
 5042 1af2 8091 0000 		lds r24,acFreqFiltCtr.2250
 5043 1af6 9091 0000 		lds r25,acFreqFiltCtr.2250+1
 5044 1afa 0196      		adiw r24,1
 5045 1afc 9093 0000 		sts acFreqFiltCtr.2250+1,r25
 5046 1b00 8093 0000 		sts acFreqFiltCtr.2250,r24
 5047               	.L239:
1018:main.c        **** 	if( acFreqFiltCtr >= AC_FRQ_FILT_SEC )
 5048               		.loc 3 1018 0
 5049 1b04 8091 0000 		lds r24,acFreqFiltCtr.2250
 5050 1b08 9091 0000 		lds r25,acFreqFiltCtr.2250+1
 5051 1b0c CC97      		sbiw r24,60
 5052 1b0e 00F0      		brlo .L244
1020:main.c        **** 		acZeroCrossSnapshot = acZeroCrossCounter;	// Grab the current number of zero crossings since the 
 5053               		.loc 3 1020 0
 5054 1b10 8091 0000 		lds r24,acZeroCrossCounter
 5055 1b14 9091 0000 		lds r25,acZeroCrossCounter+1
 5056 1b18 9093 0000 		sts acZeroCrossSnapshot+1,r25
 5057 1b1c 8093 0000 		sts acZeroCrossSnapshot,r24
1021:main.c        **** 		acZeroCrossCounter = 0;				// Reset the number of zero crossings.
 5058               		.loc 3 1021 0
 5059 1b20 1092 0000 		sts acZeroCrossCounter+1,__zero_reg__
 5060 1b24 1092 0000 		sts acZeroCrossCounter,__zero_reg__
1022:main.c        **** 		acFreqFlag = 1;						// Signal that a computation is ready to be made.
 5061               		.loc 3 1022 0
 5062 1b28 81E0      		ldi r24,lo8(1)
 5063 1b2a 8093 0000 		sts acFreqFlag,r24
1023:main.c        **** 		acFreqFiltCtr = 0;					// Reset the measurement interval counter.
 5064               		.loc 3 1023 0
 5065 1b2e 1092 0000 		sts acFreqFiltCtr.2250+1,__zero_reg__
 5066 1b32 1092 0000 		sts acFreqFiltCtr.2250,__zero_reg__
 5067               	.L244:
1030:main.c        ****     if( mscal != 0 )
 5068               		.loc 3 1030 0
 5069 1b36 8091 0000 		lds r24,mscal
 5070 1b3a 9091 0000 		lds r25,mscal+1
 5071 1b3e A091 0000 		lds r26,mscal+2
 5072 1b42 B091 0000 		lds r27,mscal+3
 5073 1b46 892B      		or r24,r25
 5074 1b48 8A2B      		or r24,r26
 5075 1b4a 8B2B      		or r24,r27
 5076 1b4c 01F4      		brne .+2
 5077 1b4e 00C0      		rjmp .L245
1032:main.c        ****         if( xtalisfast == 1 )
 5078               		.loc 3 1032 0
 5079 1b50 2091 0000 		lds r18,xtalisfast
 5080 1b54 8091 0000 		lds r24,clockCalCounter.2248
 5081 1b58 9091 0000 		lds r25,clockCalCounter.2248+1
 5082 1b5c A091 0000 		lds r26,clockCalCounter.2248+2
 5083 1b60 B091 0000 		lds r27,clockCalCounter.2248+3
1034:main.c        ****             if( ( clockCalCounter >= mscal ) && ( milliSeconds > 1 ))
 5084               		.loc 3 1034 0
 5085 1b64 4091 0000 		lds r20,mscal
 5086 1b68 5091 0000 		lds r21,mscal+1
 5087 1b6c 6091 0000 		lds r22,mscal+2
 5088 1b70 7091 0000 		lds r23,mscal+3
1032:main.c        ****         if( xtalisfast == 1 )
 5089               		.loc 3 1032 0
 5090 1b74 2130      		cpi r18,lo8(1)
 5091 1b76 01F4      		brne .L246
1034:main.c        ****             if( ( clockCalCounter >= mscal ) && ( milliSeconds > 1 ))
 5092               		.loc 3 1034 0
 5093 1b78 8417      		cp r24,r20
 5094 1b7a 9507      		cpc r25,r21
 5095 1b7c A607      		cpc r26,r22
 5096 1b7e B707      		cpc r27,r23
 5097 1b80 00F0      		brlo .L245
1034:main.c        ****             if( ( clockCalCounter >= mscal ) && ( milliSeconds > 1 ))
 5098               		.loc 3 1034 0 is_stmt 0 discriminator 1
 5099 1b82 2091 0000 		lds r18,milliSeconds.2247
 5100 1b86 3091 0000 		lds r19,milliSeconds.2247+1
 5101 1b8a 2230      		cpi r18,2
 5102 1b8c 3105      		cpc r19,__zero_reg__
 5103 1b8e 00F0      		brlo .L245
1036:main.c        ****                 milliSeconds--;
 5104               		.loc 3 1036 0 is_stmt 1
 5105 1b90 2150      		subi r18,1
 5106 1b92 3109      		sbc r19,__zero_reg__
 5107 1b94 00C0      		rjmp .L256
 5108               	.L246:
1046:main.c        ****             if( ( clockCalCounter >= mscal ) && ( milliSeconds < MS_IN_SEC - 1 ) )
 5109               		.loc 3 1046 0
 5110 1b96 8417      		cp r24,r20
 5111 1b98 9507      		cpc r25,r21
 5112 1b9a A607      		cpc r26,r22
 5113 1b9c B707      		cpc r27,r23
 5114 1b9e 00F0      		brlo .L245
1046:main.c        ****             if( ( clockCalCounter >= mscal ) && ( milliSeconds < MS_IN_SEC - 1 ) )
 5115               		.loc 3 1046 0 is_stmt 0 discriminator 1
 5116 1ba0 2091 0000 		lds r18,milliSeconds.2247
 5117 1ba4 3091 0000 		lds r19,milliSeconds.2247+1
 5118 1ba8 273E      		cpi r18,-25
 5119 1baa 43E0      		ldi r20,3
 5120 1bac 3407      		cpc r19,r20
 5121 1bae 00F4      		brsh .L245
1048:main.c        ****                 milliSeconds++;
 5122               		.loc 3 1048 0 is_stmt 1
 5123 1bb0 2F5F      		subi r18,-1
 5124 1bb2 3F4F      		sbci r19,-1
 5125               	.L256:
 5126 1bb4 3093 0000 		sts milliSeconds.2247+1,r19
 5127 1bb8 2093 0000 		sts milliSeconds.2247,r18
1053:main.c        ****                 clockCalCounter = clockCalCounter - mscal;
 5128               		.loc 3 1053 0
 5129 1bbc 4091 0000 		lds r20,mscal
 5130 1bc0 5091 0000 		lds r21,mscal+1
 5131 1bc4 6091 0000 		lds r22,mscal+2
 5132 1bc8 7091 0000 		lds r23,mscal+3
 5133 1bcc 841B      		sub r24,r20
 5134 1bce 950B      		sbc r25,r21
 5135 1bd0 A60B      		sbc r26,r22
 5136 1bd2 B70B      		sbc r27,r23
 5137 1bd4 8093 0000 		sts clockCalCounter.2248,r24
 5138 1bd8 9093 0000 		sts clockCalCounter.2248+1,r25
 5139 1bdc A093 0000 		sts clockCalCounter.2248+2,r26
 5140 1be0 B093 0000 		sts clockCalCounter.2248+3,r27
 5141               	.L245:
1058:main.c        ****     updateBoostConverter();	// Updated here for determinism.
 5142               		.loc 3 1058 0
 5143 1be4 0E94 0000 		call updateBoostConverter
 5144               	.LVL557:
 5145               	/* epilogue start */
1059:main.c        **** }
 5146               		.loc 3 1059 0
 5147 1be8 FF91      		pop r31
 5148 1bea EF91      		pop r30
 5149 1bec BF91      		pop r27
 5150 1bee AF91      		pop r26
 5151 1bf0 9F91      		pop r25
 5152 1bf2 8F91      		pop r24
 5153 1bf4 7F91      		pop r23
 5154 1bf6 6F91      		pop r22
 5155 1bf8 5F91      		pop r21
 5156 1bfa 4F91      		pop r20
 5157 1bfc 3F91      		pop r19
 5158 1bfe 2F91      		pop r18
 5159 1c00 0F90      		pop r0
 5160 1c02 0FBE      		out __SREG__,r0
 5161 1c04 0F90      		pop r0
 5162 1c06 1F90      		pop r1
 5163 1c08 1895      		reti
 5164               		.cfi_endproc
 5165               	.LFE34:
 5167               	.global	turnOnOffBoostConverter
 5169               	turnOnOffBoostConverter:
 5170               	.LFB48:
1373:main.c        **** 
1374:main.c        **** 
1375:main.c        **** 
1376:main.c        **** 
1377:main.c        **** void updateNixieOutputState( void )
1378:main.c        **** {
1379:main.c        **** 	uint16_t aTimeToCompare = 0;
1380:main.c        **** 	
1381:main.c        **** 	// Check to see if we have lost AC power.
1382:main.c        **** 	
1383:main.c        **** 	
1384:main.c        **** 	if( acPowerOk() == 0 )			// If we have lost AC power.
1385:main.c        **** 	{
1386:main.c        **** 		//
1387:main.c        **** 		turnOnOffBoostConverter( 0 );	// Turn off the boost converter.
1388:main.c        **** 		return;						// Leave.
1389:main.c        **** 	}
1390:main.c        **** 	
1391:main.c        **** 
1392:main.c        **** 		// Check to see if the nixies will go to sleep at night.
1393:main.c        **** 		if( nixiesleepstart != 0 )
1394:main.c        **** 		{
1395:main.c        **** 			// We aren't really comparing time here, just some integers.
1396:main.c        **** 			// This is because 10 AM is stored as 10000 in the sleep time vars.
1397:main.c        **** 			// This is OK, as it works out mathematically the same.
1398:main.c        **** 			
1399:main.c        **** 			aTimeToCompare = ( hours * 100 ) + minutes;
1400:main.c        **** 			
1401:main.c        **** 			// If the turn back ON time is the next day, it could be a smaller number than the turn OFF time
1402:main.c        **** 			// If the turn back ON time is the same day, it could be a larger  number than the turn OFF time
1403:main.c        **** 			// This matters due to the logic of checking if you are "inside" or "outside" the time window.
1404:main.c        **** 			
1405:main.c        **** 			// For turn ON/OFF times that are on the same day, the turn OFF time is smaller than the turn ON
1406:main.c        **** 			if( nixiesleepend >= nixiesleepstart ){
1407:main.c        **** 				// Check to see if the time is in the sleep window.
1408:main.c        **** 				if( aTimeToCompare >= nixiesleepstart && aTimeToCompare < nixiesleepend )
1409:main.c        **** 				{
1410:main.c        **** 					turnOnOffBoostConverter( 0 );	// Turn off the boost converter.
1411:main.c        **** 					return;
1412:main.c        **** 				}
1413:main.c        **** 			}else{	// For turn ON/OFF times that are on different days, the turn OFF time is larger than the
1414:main.c        **** 				// Check to see if the time is in the sleep window.
1415:main.c        **** 				if( aTimeToCompare >= nixiesleepstart || aTimeToCompare < nixiesleepend ) 
1416:main.c        **** 				{
1417:main.c        **** 					turnOnOffBoostConverter( 0 );	// Turn off the boost converter.
1418:main.c        **** 					return;
1419:main.c        **** 				}
1420:main.c        **** 			}
1421:main.c        **** 		}
1422:main.c        **** 		
1423:main.c        **** 	// Otherwise, the voltage is good, and the nixie sleep window is either not now or is inactive.
1424:main.c        **** 	turnOnOffBoostConverter( 1 );	// Turn on the boost converter.
1425:main.c        **** 	
1426:main.c        **** }
1427:main.c        **** 
1428:main.c        **** 
1429:main.c        **** // Very important to use this function to turn ON or OFF the boost converter.  Read below to find o
1430:main.c        **** // Send 1 to turn ON, send 0 ( or anything else ) to turn OFF
1431:main.c        **** void turnOnOffBoostConverter( uint8_t state )
1432:main.c        **** {
 5171               		.loc 3 1432 0
 5172               		.cfi_startproc
 5173               	.LVL558:
 5174               	/* prologue: function */
 5175               	/* frame size = 0 */
 5176               	/* stack size = 0 */
 5177               	.L__stack_usage = 0
1433:main.c        **** 	if( state ){
 5178               		.loc 3 1433 0
 5179 1c0a 8823      		tst r24
 5180 1c0c 01F0      		breq .L258
 5181               	.LBB263:
 5182               	.LBB264:
1434:main.c        **** 		TCCR0A |= ( 1 << COM0A1 );	// Connect the output pin to the PWM controller.
 5183               		.loc 3 1434 0
 5184 1c0e 84B5      		in r24,0x24
 5185               	.LVL559:
 5186 1c10 8068      		ori r24,lo8(-128)
 5187 1c12 84BD      		out 0x24,r24
 5188 1c14 0895      		ret
 5189               	.LVL560:
 5190               	.L258:
 5191               	.LBE264:
 5192               	.LBE263:
1435:main.c        **** 	}
1436:main.c        **** 	else{
1437:main.c        **** 		TCCR0A &= ~( 1 << COM0A1 );	// Disconnect the output pin from the PWM controller.
 5193               		.loc 3 1437 0
 5194 1c16 84B5      		in r24,0x24
 5195               	.LVL561:
 5196 1c18 8F77      		andi r24,lo8(127)
 5197 1c1a 84BD      		out 0x24,r24
1438:main.c        **** 		PORTD &= ~( 1 << F_BOOST );	// Set the output pin low, otherwise you will have a direct short 
 5198               		.loc 3 1438 0
 5199 1c1c 5E98      		cbi 0xb,6
 5200 1c1e 0895      		ret
 5201               		.cfi_endproc
 5202               	.LFE48:
 5204               	.global	updateNixieOutputState
 5206               	updateNixieOutputState:
 5207               	.LFB47:
1378:main.c        **** {
 5208               		.loc 3 1378 0
 5209               		.cfi_startproc
 5210 1c20 0F93      		push r16
 5211               	.LCFI69:
 5212               		.cfi_def_cfa_offset 3
 5213               		.cfi_offset 16, -2
 5214 1c22 1F93      		push r17
 5215               	.LCFI70:
 5216               		.cfi_def_cfa_offset 4
 5217               		.cfi_offset 17, -3
 5218               	/* prologue: function */
 5219               	/* frame size = 0 */
 5220               	/* stack size = 2 */
 5221               	.L__stack_usage = 2
 5222               	.LVL562:
1384:main.c        **** 	if( acPowerOk() == 0 )			// If we have lost AC power.
 5223               		.loc 3 1384 0
 5224 1c24 0E94 0000 		call acPowerOk
 5225               	.LVL563:
 5226 1c28 8111      		cpse r24,__zero_reg__
 5227 1c2a 00C0      		rjmp .L261
 5228               	.LVL564:
 5229               	.L264:
1387:main.c        **** 		turnOnOffBoostConverter( 0 );	// Turn off the boost converter.
 5230               		.loc 3 1387 0
 5231 1c2c 80E0      		ldi r24,0
 5232               	/* epilogue start */
1426:main.c        **** }
 5233               		.loc 3 1426 0
 5234 1c2e 1F91      		pop r17
 5235 1c30 0F91      		pop r16
1387:main.c        **** 		turnOnOffBoostConverter( 0 );	// Turn off the boost converter.
 5236               		.loc 3 1387 0
 5237 1c32 0C94 0000 		jmp turnOnOffBoostConverter
 5238               	.LVL565:
 5239               	.L261:
1393:main.c        **** 		if( nixiesleepstart != 0 )
 5240               		.loc 3 1393 0
 5241 1c36 4091 0000 		lds r20,nixiesleepstart
 5242 1c3a 5091 0000 		lds r21,nixiesleepstart+1
 5243 1c3e 6091 0000 		lds r22,nixiesleepstart+2
 5244 1c42 7091 0000 		lds r23,nixiesleepstart+3
 5245 1c46 4115      		cp r20,__zero_reg__
 5246 1c48 5105      		cpc r21,__zero_reg__
 5247 1c4a 6105      		cpc r22,__zero_reg__
 5248 1c4c 7105      		cpc r23,__zero_reg__
 5249 1c4e 01F0      		breq .L262
1399:main.c        **** 			aTimeToCompare = ( hours * 100 ) + minutes;
 5250               		.loc 3 1399 0
 5251 1c50 2091 0000 		lds r18,hours
 5252 1c54 8091 0000 		lds r24,minutes
 5253 1c58 90E0      		ldi r25,0
 5254 1c5a 34E6      		ldi r19,lo8(100)
 5255 1c5c 239F      		mul r18,r19
 5256 1c5e 800D      		add r24,r0
 5257 1c60 911D      		adc r25,r1
 5258 1c62 1124      		clr __zero_reg__
 5259               	.LVL566:
1406:main.c        **** 			if( nixiesleepend >= nixiesleepstart ){
 5260               		.loc 3 1406 0
 5261 1c64 0091 0000 		lds r16,nixiesleepend
 5262 1c68 1091 0000 		lds r17,nixiesleepend+1
 5263 1c6c 2091 0000 		lds r18,nixiesleepend+2
 5264 1c70 3091 0000 		lds r19,nixiesleepend+3
 5265 1c74 AA27      		clr r26
 5266 1c76 97FD      		sbrc r25,7
 5267 1c78 A095      		com r26
 5268 1c7a BA2F      		mov r27,r26
 5269 1c7c 0417      		cp r16,r20
 5270 1c7e 1507      		cpc r17,r21
 5271 1c80 2607      		cpc r18,r22
 5272 1c82 3707      		cpc r19,r23
 5273 1c84 00F0      		brlo .L263
1408:main.c        **** 				if( aTimeToCompare >= nixiesleepstart && aTimeToCompare < nixiesleepend )
 5274               		.loc 3 1408 0
 5275 1c86 8417      		cp r24,r20
 5276 1c88 9507      		cpc r25,r21
 5277 1c8a A607      		cpc r26,r22
 5278 1c8c B707      		cpc r27,r23
 5279 1c8e 00F0      		brlo .L262
 5280 1c90 00C0      		rjmp .L269
 5281               	.L263:
1415:main.c        **** 				if( aTimeToCompare >= nixiesleepstart || aTimeToCompare < nixiesleepend ) 
 5282               		.loc 3 1415 0
 5283 1c92 8417      		cp r24,r20
 5284 1c94 9507      		cpc r25,r21
 5285 1c96 A607      		cpc r26,r22
 5286 1c98 B707      		cpc r27,r23
 5287 1c9a 00F4      		brsh .L264
 5288               	.L269:
1415:main.c        **** 				if( aTimeToCompare >= nixiesleepstart || aTimeToCompare < nixiesleepend ) 
 5289               		.loc 3 1415 0 is_stmt 0 discriminator 1
 5290 1c9c 8017      		cp r24,r16
 5291 1c9e 9107      		cpc r25,r17
 5292 1ca0 A207      		cpc r26,r18
 5293 1ca2 B307      		cpc r27,r19
 5294 1ca4 00F0      		brlo .L264
 5295               	.LVL567:
 5296               	.L262:
 5297               	.LBB269:
 5298               	.LBB270:
 5299               	.LBB271:
1434:main.c        **** 		TCCR0A |= ( 1 << COM0A1 );	// Connect the output pin to the PWM controller.
 5300               		.loc 3 1434 0 is_stmt 1
 5301 1ca6 84B5      		in r24,0x24
 5302 1ca8 8068      		ori r24,lo8(-128)
 5303 1caa 84BD      		out 0x24,r24
 5304               	/* epilogue start */
 5305               	.LBE271:
 5306               	.LBE270:
 5307               	.LBE269:
1426:main.c        **** }
 5308               		.loc 3 1426 0
 5309 1cac 1F91      		pop r17
 5310 1cae 0F91      		pop r16
 5311 1cb0 0895      		ret
 5312               		.cfi_endproc
 5313               	.LFE47:
 5315               	.global	updateAcFrequency
 5317               	updateAcFrequency:
 5318               	.LFB49:
1439:main.c        **** 	}								// thru the inductor and burn thru 5 fuses trying to figure it out. 
1440:main.c        **** 									// I have been told that the default state is low, so setting low may
1441:main.c        **** }									// be redundant.  I leave it here as I have not tested this.
1442:main.c        **** 
1443:main.c        **** 
1444:main.c        **** 
1445:main.c        **** 
1446:main.c        **** 
1447:main.c        **** void updateAcFrequency( void )
1448:main.c        **** {
 5319               		.loc 3 1448 0
 5320               		.cfi_startproc
 5321               	/* prologue: function */
 5322               	/* frame size = 0 */
 5323               	/* stack size = 0 */
 5324               	.L__stack_usage = 0
1449:main.c        **** 	if( acFreqFlag )	// acFreqFlag is set in ISR( TIMER1_COMPA_vect ) and cleared here.
 5325               		.loc 3 1449 0
 5326 1cb2 8091 0000 		lds r24,acFreqFlag
 5327 1cb6 8823      		tst r24
 5328 1cb8 01F0      		breq .L270
1450:main.c        **** 	{
1451:main.c        **** 		// If acFreqFlag == 1, then acZeroCrossSnapshot contains the total number of AC waveform 
1452:main.c        **** 		// "zero crossings" in AC_FRQ_FILT_SEC seconds.  Here we just need to compute the average and
1453:main.c        **** 		// stuff the result into acFrequency.
1454:main.c        **** 		// Then, in out main app: The contents of acFrequency is the frequency of the AC line input.
1455:main.c        **** 		
1456:main.c        **** 		acFrequency = ( acZeroCrossSnapshot / ( AC_FRQ_FILT_SEC * 60.0 ) ) * 60.0;
 5329               		.loc 3 1456 0
 5330 1cba 6091 0000 		lds r22,acZeroCrossSnapshot
 5331 1cbe 7091 0000 		lds r23,acZeroCrossSnapshot+1
 5332 1cc2 80E0      		ldi r24,0
 5333 1cc4 90E0      		ldi r25,0
 5334 1cc6 0E94 0000 		call __floatunsisf
 5335               	.LVL568:
 5336 1cca 20E0      		ldi r18,0
 5337 1ccc 30E0      		ldi r19,0
 5338 1cce 41E6      		ldi r20,lo8(97)
 5339 1cd0 55E4      		ldi r21,lo8(69)
 5340 1cd2 0E94 0000 		call __divsf3
 5341               	.LVL569:
 5342 1cd6 20E0      		ldi r18,0
 5343 1cd8 30E0      		ldi r19,0
 5344 1cda 40E7      		ldi r20,lo8(112)
 5345 1cdc 52E4      		ldi r21,lo8(66)
 5346 1cde 0E94 0000 		call __mulsf3
 5347               	.LVL570:
 5348 1ce2 AB01      		movw r20,r22
 5349 1ce4 BC01      		movw r22,r24
 5350 1ce6 4093 0000 		sts acFrequency,r20
 5351 1cea 5093 0000 		sts acFrequency+1,r21
 5352 1cee 6093 0000 		sts acFrequency+2,r22
 5353 1cf2 7093 0000 		sts acFrequency+3,r23
1457:main.c        **** 		
1458:main.c        **** 		// Since a pin change interrupt counts rising and falling edges, there are twice as many events.
1459:main.c        **** 		acFrequency /= 2.0;
 5354               		.loc 3 1459 0
 5355 1cf6 6091 0000 		lds r22,acFrequency
 5356 1cfa 7091 0000 		lds r23,acFrequency+1
 5357 1cfe 8091 0000 		lds r24,acFrequency+2
 5358 1d02 9091 0000 		lds r25,acFrequency+3
 5359 1d06 20E0      		ldi r18,0
 5360 1d08 30E0      		ldi r19,0
 5361 1d0a 40E0      		ldi r20,0
 5362 1d0c 5FE3      		ldi r21,lo8(63)
 5363 1d0e 0E94 0000 		call __mulsf3
 5364               	.LVL571:
 5365 1d12 AB01      		movw r20,r22
 5366 1d14 BC01      		movw r22,r24
 5367 1d16 4093 0000 		sts acFrequency,r20
 5368 1d1a 5093 0000 		sts acFrequency+1,r21
 5369 1d1e 6093 0000 		sts acFrequency+2,r22
 5370 1d22 7093 0000 		sts acFrequency+3,r23
1460:main.c        **** 		
1461:main.c        **** 		acFreqFlag = 0;	// Reset the counter.
 5371               		.loc 3 1461 0
 5372 1d26 1092 0000 		sts acFreqFlag,__zero_reg__
 5373               	.L270:
 5374 1d2a 0895      		ret
 5375               		.cfi_endproc
 5376               	.LFE49:
 5378               	.global	shiftRegisterPulse
 5380               	shiftRegisterPulse:
 5381               	.LFB52:
1462:main.c        **** 	}
1463:main.c        **** 	
1464:main.c        **** }
1465:main.c        **** 
1466:main.c        **** 
1467:main.c        **** 
1468:main.c        **** // Read about cathode poisoning on the web.  
1469:main.c        **** // Basically we just want to make sure each nixie element gets some burn time
1470:main.c        **** // otherwise the unused elements will underperform and get dim or dark spots.
1471:main.c        **** void antiCathodePoisonPattern( uint16_t delay )
1472:main.c        **** {		
1473:main.c        **** 		// Count up.
1474:main.c        **** 		for( int i = 0; i < 10; i++ ){
1475:main.c        **** 			for( int j = 0; j < 6; j++ ){
1476:main.c        **** 				sendIntegerToNixie( i, 1 );
1477:main.c        **** 			}
1478:main.c        **** 			
1479:main.c        **** 			shiftRegisterSetOutput();
1480:main.c        **** 			_delay_ms( delay );
1481:main.c        **** 		}
1482:main.c        **** 		
1483:main.c        **** 		// Count down.
1484:main.c        **** 		for( int i = 8; i >= 1; i-- ){
1485:main.c        **** 			for( int j = 0; j < 6; j++ ){
1486:main.c        **** 				sendIntegerToNixie( i, 1 );
1487:main.c        **** 			}
1488:main.c        **** 			
1489:main.c        **** 			shiftRegisterSetOutput();
1490:main.c        **** 			_delay_ms( delay );
1491:main.c        **** 		}
1492:main.c        **** }
1493:main.c        **** 
1494:main.c        **** 
1495:main.c        **** // See antiCathodePoisonPattern() comments.
1496:main.c        **** void checkCathodePoison( void )
1497:main.c        **** {
1498:main.c        **** 		// Anti-poison the cathodes every 30 minutes.
1499:main.c        ****         if( minutes == 30 || minutes == 0){
1500:main.c        ****         	if( cathodePoisonFlag == 1 ){
1501:main.c        ****         		antiCathodePoisonPattern( 250 );
1502:main.c        ****         		antiCathodePoisonPattern( 225 );
1503:main.c        ****         		antiCathodePoisonPattern( 200 );
1504:main.c        ****         		antiCathodePoisonPattern( 175 );
1505:main.c        ****         		antiCathodePoisonPattern( 150 );
1506:main.c        ****         		antiCathodePoisonPattern( 125 );
1507:main.c        ****         		antiCathodePoisonPattern( 100 );
1508:main.c        ****         		antiCathodePoisonPattern( 75 );
1509:main.c        ****         		antiCathodePoisonPattern( 50 );
1510:main.c        ****         		antiCathodePoisonPattern( 25 );
1511:main.c        ****         		antiCathodePoisonPattern( 10 );
1512:main.c        ****         		antiCathodePoisonPattern( 10 );
1513:main.c        ****         		antiCathodePoisonPattern( 5 );
1514:main.c        ****         		cathodePoisonFlag = 0;				// Reset the counter.
1515:main.c        ****         	}
1516:main.c        ****         }	
1517:main.c        **** 
1518:main.c        **** }
1519:main.c        **** 
1520:main.c        **** 
1521:main.c        **** 
1522:main.c        **** void shiftRegisterPulse( void )
1523:main.c        **** {
 5382               		.loc 3 1523 0
 5383               		.cfi_startproc
 5384               	/* prologue: function */
 5385               	/* frame size = 0 */
 5386               	/* stack size = 0 */
 5387               	.L__stack_usage = 0
1524:main.c        **** 
1525:main.c        **** 	PORTD |= ( 1 << SRCLK );		// set the serial clock line high.
 5388               		.loc 3 1525 0
 5389 1d2c 5C9A      		sbi 0xb,4
1526:main.c        **** 	//_delay_us( 1 );							// No delay
1527:main.c        ****     PORTD &= ~( 1 << SRCLK );	// Set the serial Clock line low.
 5390               		.loc 3 1527 0
 5391 1d2e 5C98      		cbi 0xb,4
 5392 1d30 0895      		ret
 5393               		.cfi_endproc
 5394               	.LFE52:
 5396               	.global	shiftRegisterSetOutput
 5398               	shiftRegisterSetOutput:
 5399               	.LFB53:
1528:main.c        **** 
1529:main.c        **** }
1530:main.c        **** 
1531:main.c        **** 
1532:main.c        **** 
1533:main.c        **** 
1534:main.c        **** void shiftRegisterSetOutput( void )
1535:main.c        **** {
 5400               		.loc 3 1535 0
 5401               		.cfi_startproc
 5402               	/* prologue: function */
 5403               	/* frame size = 0 */
 5404               	/* stack size = 0 */
 5405               	.L__stack_usage = 0
1536:main.c        **** 
1537:main.c        **** 	PORTD |= ( 1 << RCLK );		// set the store output line high.
 5406               		.loc 3 1537 0
 5407 1d32 5D9A      		sbi 0xb,5
1538:main.c        **** 	//_delay_us(1);							// No delay, might need a nop or 2.
1539:main.c        ****     PORTD &= ~( 1 << RCLK );	// Set the store output line low.
 5408               		.loc 3 1539 0
 5409 1d34 5D98      		cbi 0xb,5
 5410 1d36 0895      		ret
 5411               		.cfi_endproc
 5412               	.LFE53:
 5414               	.global	shiftByteOut
 5416               	shiftByteOut:
 5417               	.LFB54:
1540:main.c        ****     //_delay_us(1);							// No delay, might need a nop or 2.
1541:main.c        **** }
1542:main.c        **** 
1543:main.c        **** 
1544:main.c        **** 
1545:main.c        **** 
1546:main.c        **** 
1547:main.c        **** void shiftByteOut( uint8_t byteToShift )
1548:main.c        **** {
 5418               		.loc 3 1548 0
 5419               		.cfi_startproc
 5420               	.LVL572:
 5421 1d38 0F93      		push r16
 5422               	.LCFI71:
 5423               		.cfi_def_cfa_offset 3
 5424               		.cfi_offset 16, -2
 5425 1d3a 1F93      		push r17
 5426               	.LCFI72:
 5427               		.cfi_def_cfa_offset 4
 5428               		.cfi_offset 17, -3
 5429 1d3c CF93      		push r28
 5430               	.LCFI73:
 5431               		.cfi_def_cfa_offset 5
 5432               		.cfi_offset 28, -4
 5433 1d3e DF93      		push r29
 5434               	.LCFI74:
 5435               		.cfi_def_cfa_offset 6
 5436               		.cfi_offset 29, -5
 5437               	/* prologue: function */
 5438               	/* frame size = 0 */
 5439               	/* stack size = 4 */
 5440               	.L__stack_usage = 4
1549:main.c        **** 	PORTD &= ~( 1 << RCLK );		// Hold low while transmitting.
 5441               		.loc 3 1549 0
 5442 1d40 5D98      		cbi 0xb,5
 5443               	.LVL573:
 5444 1d42 C7E0      		ldi r28,lo8(7)
 5445 1d44 D0E0      		ldi r29,0
 5446               	.LBB272:
1550:main.c        **** 	
1551:main.c        **** 	for( uint8_t i = 0; i < 8; i++ ) 
1552:main.c        **** 	{
1553:main.c        **** 		// If the MSB is high.
1554:main.c        **** 		if ( byteToShift & _BV( 7 - i ) ){
 5447               		.loc 3 1554 0
 5448 1d46 082F      		mov r16,r24
 5449 1d48 10E0      		ldi r17,0
 5450               	.LVL574:
 5451               	.L280:
 5452 1d4a C801      		movw r24,r16
 5453 1d4c 0C2E      		mov r0,r28
 5454 1d4e 00C0      		rjmp 2f
 5455               		1:
 5456 1d50 9595      		asr r25
 5457 1d52 8795      		ror r24
 5458               		2:
 5459 1d54 0A94      		dec r0
 5460 1d56 02F4      		brpl 1b
 5461 1d58 80FF      		sbrs r24,0
 5462 1d5a 00C0      		rjmp .L278
1555:main.c        **** 		
1556:main.c        ****             PORTD |= ( 1 << SER );	// set the output high
 5463               		.loc 3 1556 0
 5464 1d5c 5B9A      		sbi 0xb,3
 5465 1d5e 00C0      		rjmp .L279
 5466               	.L278:
1557:main.c        ****         
1558:main.c        ****         } else {
1559:main.c        ****         
1560:main.c        ****             PORTD &= ~( 1 << SER );	// Set the output low.
 5467               		.loc 3 1560 0
 5468 1d60 5B98      		cbi 0xb,3
 5469               	.L279:
1561:main.c        ****         
1562:main.c        ****         }
1563:main.c        ****         
1564:main.c        ****         shiftRegisterPulse();
 5470               		.loc 3 1564 0
 5471 1d62 0E94 0000 		call shiftRegisterPulse
 5472               	.LVL575:
 5473 1d66 2197      		sbiw r28,1
 5474 1d68 00F4      		brcc .L280
 5475               	.LBE272:
1565:main.c        ****     }
1566:main.c        ****     
1567:main.c        ****     PORTD |= ( 1 << RCLK );	
 5476               		.loc 3 1567 0
 5477 1d6a 5D9A      		sbi 0xb,5
 5478               	/* epilogue start */
1568:main.c        **** 
1569:main.c        **** }
 5479               		.loc 3 1569 0
 5480 1d6c DF91      		pop r29
 5481 1d6e CF91      		pop r28
 5482 1d70 1F91      		pop r17
 5483 1d72 0F91      		pop r16
 5484               	.LVL576:
 5485 1d74 0895      		ret
 5486               		.cfi_endproc
 5487               	.LFE54:
 5489               	.global	sendIntegerToNixie
 5491               	sendIntegerToNixie:
 5492               	.LFB55:
1570:main.c        **** 
1571:main.c        **** 
1572:main.c        **** 
1573:main.c        **** 
1574:main.c        **** void sendIntegerToNixie( uint8_t intToSend, uint8_t doDecimal )
1575:main.c        **** {
 5493               		.loc 3 1575 0
 5494               		.cfi_startproc
 5495               	.LVL577:
 5496               	/* prologue: function */
 5497               	/* frame size = 0 */
 5498               	/* stack size = 0 */
 5499               	.L__stack_usage = 0
1576:main.c        **** 	// Sends an int thru a shift register, thru a HV BCD driver and to a Nixie tube.
1577:main.c        **** 	// doDecimal passed in will turn the decimal point inside the nixie ON if 1, off if 0.
1578:main.c        **** /*
1579:main.c        **** //~~~~~~~~~~~~~~~~~~~~~~*********** Nixie Digits to BCD to Byte ***********~~~~~~~~~~~~~~~~~~~~~~~~
1580:main.c        **** 
1581:main.c        **** Nixie Digit		  K155ID BCD		Byte for shift register
1582:main.c        **** 				A	B	C	D
1583:main.c        **** _____________________________________________________________				
1584:main.c        **** 		0		L	L	L	L		0b00000000	
1585:main.c        **** 		1		L	L	L	H		0b00010000
1586:main.c        **** 		2		L	L	H	L		0b00100000
1587:main.c        **** 		3		L	L	H	H		0b00110000		
1588:main.c        **** 		4		L	H	L	L		0b01000000
1589:main.c        **** 		5		L	H	L	H		0b01010000
1590:main.c        **** 		6		L	H	H	L		0b01100000
1591:main.c        **** 		7		L	H	H	H		0b01110000
1592:main.c        **** 		8		H	L	L	L		0b10000000
1593:main.c        **** 		9		H	L	L	H		0b10010000
1594:main.c        ****   Decimal			N/A				0b00001000	// & this with the digit above to turn the decimal ON.
1595:main.c        **** 
1596:main.c        **** //~~~~~~~~~~~~~~~~~~~~~~*********** Nixie Digits to BCD to Byte ***********~~~~~~~~~~~~~~~~~~~~~~~~
1597:main.c        **** */
1598:main.c        **** 
1599:main.c        **** switch ( intToSend ){
 5500               		.loc 3 1599 0
 5501 1d76 8430      		cpi r24,lo8(4)
 5502 1d78 01F0      		breq .L288
 5503 1d7a 00F4      		brsh .L294
 5504 1d7c 8130      		cpi r24,lo8(1)
 5505 1d7e 01F0      		breq .L285
 5506 1d80 00F0      		brlo .L284
 5507 1d82 8230      		cpi r24,lo8(2)
 5508 1d84 01F0      		breq .L286
 5509 1d86 8330      		cpi r24,lo8(3)
 5510 1d88 01F0      		breq .+2
 5511 1d8a 00C0      		rjmp .L282
 5512 1d8c 00C0      		rjmp .L287
 5513               	.L294:
 5514 1d8e 8730      		cpi r24,lo8(7)
 5515 1d90 01F0      		breq .L291
 5516 1d92 00F4      		brsh .L295
 5517 1d94 8530      		cpi r24,lo8(5)
 5518 1d96 01F0      		breq .L289
 5519 1d98 8630      		cpi r24,lo8(6)
 5520 1d9a 01F0      		breq .+2
 5521 1d9c 00C0      		rjmp .L282
 5522 1d9e 00C0      		rjmp .L290
 5523               	.L295:
 5524 1da0 8830      		cpi r24,lo8(8)
 5525 1da2 01F0      		breq .L292
 5526 1da4 8930      		cpi r24,lo8(9)
 5527 1da6 01F4      		brne .L282
 5528 1da8 00C0      		rjmp .L293
 5529               	.L284:
1600:main.c        **** 	
1601:main.c        **** 	case 0:
1602:main.c        **** 		if( doDecimal ){
 5530               		.loc 3 1602 0
 5531 1daa 6623      		tst r22
 5532 1dac 01F0      		breq .L296
1603:main.c        **** 			shiftByteOut( 0b00000000 | 0b00010000 );
 5533               		.loc 3 1603 0
 5534 1dae 80E1      		ldi r24,lo8(16)
 5535               	.LVL578:
 5536 1db0 00C0      		rjmp .L306
 5537               	.LVL579:
 5538               	.L296:
1604:main.c        **** 		}else{
1605:main.c        **** 			shiftByteOut( 0b00000000 );
 5539               		.loc 3 1605 0
 5540 1db2 80E0      		ldi r24,0
 5541               	.LVL580:
 5542 1db4 00C0      		rjmp .L306
 5543               	.LVL581:
 5544               	.L285:
1606:main.c        **** 		}
1607:main.c        **** 	break;
1608:main.c        **** 	
1609:main.c        **** 	
1610:main.c        **** 	case 1:
1611:main.c        **** 	if( doDecimal ){
 5545               		.loc 3 1611 0
 5546 1db6 6623      		tst r22
 5547 1db8 01F0      		breq .L297
1612:main.c        **** 		shiftByteOut( 0b00000001 | 0b00010000 );
 5548               		.loc 3 1612 0
 5549 1dba 81E1      		ldi r24,lo8(17)
 5550               	.LVL582:
 5551 1dbc 00C0      		rjmp .L306
 5552               	.LVL583:
 5553               	.L297:
1613:main.c        **** 	}else{
1614:main.c        **** 		shiftByteOut( 0b00000001 );
 5554               		.loc 3 1614 0
 5555 1dbe 81E0      		ldi r24,lo8(1)
 5556               	.LVL584:
 5557 1dc0 00C0      		rjmp .L306
 5558               	.LVL585:
 5559               	.L286:
1615:main.c        **** 	}
1616:main.c        **** 	break;
1617:main.c        **** 	
1618:main.c        **** 
1619:main.c        **** 	case 2:
1620:main.c        **** 	if( doDecimal ){
 5560               		.loc 3 1620 0
 5561 1dc2 6623      		tst r22
 5562 1dc4 01F0      		breq .L298
1621:main.c        **** 		shiftByteOut( 0b00000010 | 0b00010000 );
 5563               		.loc 3 1621 0
 5564 1dc6 82E1      		ldi r24,lo8(18)
 5565               	.LVL586:
 5566 1dc8 00C0      		rjmp .L306
 5567               	.LVL587:
 5568               	.L298:
1622:main.c        **** 	}else{
1623:main.c        **** 		shiftByteOut( 0b00000010 );
 5569               		.loc 3 1623 0
 5570 1dca 82E0      		ldi r24,lo8(2)
 5571               	.LVL588:
 5572 1dcc 00C0      		rjmp .L306
 5573               	.LVL589:
 5574               	.L287:
1624:main.c        **** 	}
1625:main.c        **** 	break;
1626:main.c        **** 	
1627:main.c        **** 	
1628:main.c        **** 	case 3:
1629:main.c        **** 	if( doDecimal ){
 5575               		.loc 3 1629 0
 5576 1dce 6623      		tst r22
 5577 1dd0 01F0      		breq .L299
1630:main.c        **** 		shiftByteOut( 0b00000011 | 0b00010000 );
 5578               		.loc 3 1630 0
 5579 1dd2 83E1      		ldi r24,lo8(19)
 5580               	.LVL590:
 5581 1dd4 00C0      		rjmp .L306
 5582               	.LVL591:
 5583               	.L299:
1631:main.c        **** 	}else{
1632:main.c        **** 		shiftByteOut( 0b00000011 );
 5584               		.loc 3 1632 0
 5585 1dd6 83E0      		ldi r24,lo8(3)
 5586               	.LVL592:
 5587 1dd8 00C0      		rjmp .L306
 5588               	.LVL593:
 5589               	.L288:
1633:main.c        **** 	}
1634:main.c        **** 	break;
1635:main.c        **** 	
1636:main.c        **** 	
1637:main.c        **** 	case 4:
1638:main.c        **** 	if( doDecimal ){
 5590               		.loc 3 1638 0
 5591 1dda 6623      		tst r22
 5592 1ddc 01F0      		breq .L300
1639:main.c        **** 		shiftByteOut( 0b00000100 | 0b00010000 );
 5593               		.loc 3 1639 0
 5594 1dde 84E1      		ldi r24,lo8(20)
 5595               	.LVL594:
 5596 1de0 00C0      		rjmp .L306
 5597               	.LVL595:
 5598               	.L300:
1640:main.c        **** 	}else{
1641:main.c        **** 		shiftByteOut( 0b00000100 );
 5599               		.loc 3 1641 0
 5600 1de2 84E0      		ldi r24,lo8(4)
 5601               	.LVL596:
 5602 1de4 00C0      		rjmp .L306
 5603               	.LVL597:
 5604               	.L289:
1642:main.c        **** 	}
1643:main.c        **** 	break;
1644:main.c        **** 	
1645:main.c        **** 	
1646:main.c        **** 	case 5:
1647:main.c        **** 	if( doDecimal ){
 5605               		.loc 3 1647 0
 5606 1de6 6623      		tst r22
 5607 1de8 01F0      		breq .L301
1648:main.c        **** 		shiftByteOut( 0b00000101 | 0b00010000 );
 5608               		.loc 3 1648 0
 5609 1dea 85E1      		ldi r24,lo8(21)
 5610               	.LVL598:
 5611 1dec 00C0      		rjmp .L306
 5612               	.LVL599:
 5613               	.L301:
1649:main.c        **** 	}else{
1650:main.c        **** 		shiftByteOut( 0b00000101 );
 5614               		.loc 3 1650 0
 5615 1dee 85E0      		ldi r24,lo8(5)
 5616               	.LVL600:
 5617 1df0 00C0      		rjmp .L306
 5618               	.LVL601:
 5619               	.L290:
1651:main.c        **** 	}
1652:main.c        **** 	break;
1653:main.c        **** 	
1654:main.c        **** 	
1655:main.c        **** 	case 6:
1656:main.c        **** 	if( doDecimal ){
 5620               		.loc 3 1656 0
 5621 1df2 6623      		tst r22
 5622 1df4 01F0      		breq .L302
1657:main.c        **** 		shiftByteOut( 0b00000110 | 0b00010000 );
 5623               		.loc 3 1657 0
 5624 1df6 86E1      		ldi r24,lo8(22)
 5625               	.LVL602:
 5626 1df8 00C0      		rjmp .L306
 5627               	.LVL603:
 5628               	.L302:
1658:main.c        **** 	}else{
1659:main.c        **** 		shiftByteOut( 0b00000110 );
 5629               		.loc 3 1659 0
 5630 1dfa 86E0      		ldi r24,lo8(6)
 5631               	.LVL604:
 5632 1dfc 00C0      		rjmp .L306
 5633               	.LVL605:
 5634               	.L291:
1660:main.c        **** 	}
1661:main.c        **** 	break;
1662:main.c        **** 	
1663:main.c        **** 	
1664:main.c        **** 	case 7:
1665:main.c        **** 	if( doDecimal ){
 5635               		.loc 3 1665 0
 5636 1dfe 6623      		tst r22
 5637 1e00 01F0      		breq .L303
1666:main.c        **** 		shiftByteOut( 0b00000111 | 0b00010000 );
 5638               		.loc 3 1666 0
 5639 1e02 87E1      		ldi r24,lo8(23)
 5640               	.LVL606:
 5641 1e04 00C0      		rjmp .L306
 5642               	.LVL607:
 5643               	.L303:
1667:main.c        **** 	}else{
1668:main.c        **** 		shiftByteOut( 0b00000111 );
 5644               		.loc 3 1668 0
 5645 1e06 87E0      		ldi r24,lo8(7)
 5646               	.LVL608:
 5647 1e08 00C0      		rjmp .L306
 5648               	.LVL609:
 5649               	.L292:
1669:main.c        **** 	}
1670:main.c        **** 	break;
1671:main.c        **** 	
1672:main.c        **** 	
1673:main.c        **** 	case 8:
1674:main.c        **** 	if( doDecimal ){
 5650               		.loc 3 1674 0
 5651 1e0a 6623      		tst r22
 5652 1e0c 01F0      		breq .L304
1675:main.c        **** 		shiftByteOut( 0b00001000 | 0b00010000 );
 5653               		.loc 3 1675 0
 5654 1e0e 88E1      		ldi r24,lo8(24)
 5655               	.LVL610:
 5656 1e10 00C0      		rjmp .L306
 5657               	.LVL611:
 5658               	.L304:
1676:main.c        **** 	}else{
1677:main.c        **** 		shiftByteOut( 0b00001000 );
 5659               		.loc 3 1677 0
 5660 1e12 88E0      		ldi r24,lo8(8)
 5661               	.LVL612:
 5662 1e14 00C0      		rjmp .L306
 5663               	.LVL613:
 5664               	.L293:
1678:main.c        **** 	}
1679:main.c        **** 	break;
1680:main.c        **** 	
1681:main.c        **** 	
1682:main.c        **** 	case 9:
1683:main.c        **** 	if( doDecimal ){
 5665               		.loc 3 1683 0
 5666 1e16 6623      		tst r22
 5667 1e18 01F0      		breq .L305
1684:main.c        **** 		shiftByteOut( 0b00001001 | 0b00010000 );
 5668               		.loc 3 1684 0
 5669 1e1a 89E1      		ldi r24,lo8(25)
 5670               	.LVL614:
 5671 1e1c 00C0      		rjmp .L306
 5672               	.LVL615:
 5673               	.L305:
1685:main.c        **** 	}else{
1686:main.c        **** 		shiftByteOut( 0b00001001 );
 5674               		.loc 3 1686 0
 5675 1e1e 89E0      		ldi r24,lo8(9)
 5676               	.LVL616:
 5677               	.L306:
 5678 1e20 0C94 0000 		jmp shiftByteOut
 5679               	.LVL617:
 5680               	.L282:
 5681 1e24 0895      		ret
 5682               		.cfi_endproc
 5683               	.LFE55:
 5685               	.global	__ltsf2
 5686               	.global	__gtsf2
 5687               	.global	__fixunssfsi
 5688               	.global	antiCathodePoisonPattern
 5690               	antiCathodePoisonPattern:
 5691               	.LFB50:
1472:main.c        **** {		
 5692               		.loc 3 1472 0
 5693               		.cfi_startproc
 5694               	.LVL618:
 5695 1e26 3F92      		push r3
 5696               	.LCFI75:
 5697               		.cfi_def_cfa_offset 3
 5698               		.cfi_offset 3, -2
 5699 1e28 4F92      		push r4
 5700               	.LCFI76:
 5701               		.cfi_def_cfa_offset 4
 5702               		.cfi_offset 4, -3
 5703 1e2a 5F92      		push r5
 5704               	.LCFI77:
 5705               		.cfi_def_cfa_offset 5
 5706               		.cfi_offset 5, -4
 5707 1e2c 6F92      		push r6
 5708               	.LCFI78:
 5709               		.cfi_def_cfa_offset 6
 5710               		.cfi_offset 6, -5
 5711 1e2e 7F92      		push r7
 5712               	.LCFI79:
 5713               		.cfi_def_cfa_offset 7
 5714               		.cfi_offset 7, -6
 5715 1e30 8F92      		push r8
 5716               	.LCFI80:
 5717               		.cfi_def_cfa_offset 8
 5718               		.cfi_offset 8, -7
 5719 1e32 9F92      		push r9
 5720               	.LCFI81:
 5721               		.cfi_def_cfa_offset 9
 5722               		.cfi_offset 9, -8
 5723 1e34 AF92      		push r10
 5724               	.LCFI82:
 5725               		.cfi_def_cfa_offset 10
 5726               		.cfi_offset 10, -9
 5727 1e36 BF92      		push r11
 5728               	.LCFI83:
 5729               		.cfi_def_cfa_offset 11
 5730               		.cfi_offset 11, -10
 5731 1e38 CF92      		push r12
 5732               	.LCFI84:
 5733               		.cfi_def_cfa_offset 12
 5734               		.cfi_offset 12, -11
 5735 1e3a DF92      		push r13
 5736               	.LCFI85:
 5737               		.cfi_def_cfa_offset 13
 5738               		.cfi_offset 13, -12
 5739 1e3c EF92      		push r14
 5740               	.LCFI86:
 5741               		.cfi_def_cfa_offset 14
 5742               		.cfi_offset 14, -13
 5743 1e3e FF92      		push r15
 5744               	.LCFI87:
 5745               		.cfi_def_cfa_offset 15
 5746               		.cfi_offset 15, -14
 5747 1e40 0F93      		push r16
 5748               	.LCFI88:
 5749               		.cfi_def_cfa_offset 16
 5750               		.cfi_offset 16, -15
 5751 1e42 1F93      		push r17
 5752               	.LCFI89:
 5753               		.cfi_def_cfa_offset 17
 5754               		.cfi_offset 17, -16
 5755 1e44 CF93      		push r28
 5756               	.LCFI90:
 5757               		.cfi_def_cfa_offset 18
 5758               		.cfi_offset 28, -17
 5759 1e46 DF93      		push r29
 5760               	.LCFI91:
 5761               		.cfi_def_cfa_offset 19
 5762               		.cfi_offset 29, -18
 5763               	/* prologue: function */
 5764               	/* frame size = 0 */
 5765               	/* stack size = 17 */
 5766               	.L__stack_usage = 17
 5767               	.LVL619:
 5768               	.LBB273:
 5769               	.LBB274:
 5770               	.LBB275:
 5771               		.file 4 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h"
   1:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
   6:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
   9:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  12:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  17:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  21:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  33:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  35:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  38:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
  41:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  42:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  46:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     \code
  49:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  54:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     used.
  58:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  59:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  68:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  77:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  81:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** */
  82:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  83:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
  87:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  88:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
  93:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  94:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
  97:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  98:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
 103:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 104:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /**
 105:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 107:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 109:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 112:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 114:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 120:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 125:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 129:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 132:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 140:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****  */
 141:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** void
 142:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** {
 144:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 153:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 156:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 159:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#else
 160:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 164:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 166:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #else
 167:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 5772               		.loc 4 169 0
 5773 1e48 10E0      		ldi r17,0
 5774               	.LBE275:
 5775               	.LBE274:
1480:main.c        **** 			_delay_ms( delay );
 5776               		.loc 3 1480 0
 5777 1e4a 6C01      		movw r12,r24
 5778 1e4c E12C      		mov r14,__zero_reg__
 5779 1e4e F12C      		mov r15,__zero_reg__
 5780               	.LBB285:
 5781               	.LBB282:
 5782               	.LBB276:
 5783               	.LBB277:
 5784               		.loc 2 105 0
 5785 1e50 C9E9      		ldi r28,lo8(-103)
 5786 1e52 D1E0      		ldi r29,lo8(1)
 5787 1e54 00C0      		rjmp .L308
 5788               	.LVL620:
 5789               	.L309:
 5790               	.LBE277:
 5791               	.LBE276:
 5792               	.LBE282:
 5793               	.LBE285:
 5794               	.LBB286:
1476:main.c        **** 				sendIntegerToNixie( i, 1 );
 5795               		.loc 3 1476 0 discriminator 2
 5796 1e56 61E0      		ldi r22,lo8(1)
 5797 1e58 812F      		mov r24,r17
 5798 1e5a 0E94 0000 		call sendIntegerToNixie
 5799               	.LVL621:
 5800 1e5e 81E0      		ldi r24,1
 5801 1e60 A81A      		sub r10,r24
 5802 1e62 B108      		sbc r11,__zero_reg__
1475:main.c        **** 			for( int j = 0; j < 6; j++ ){
 5803               		.loc 3 1475 0 discriminator 2
 5804 1e64 01F4      		brne .L309
 5805               	.LBE286:
1479:main.c        **** 			shiftRegisterSetOutput();
 5806               		.loc 3 1479 0
 5807 1e66 0E94 0000 		call shiftRegisterSetOutput
 5808               	.LVL622:
1480:main.c        **** 			_delay_ms( delay );
 5809               		.loc 3 1480 0
 5810 1e6a C701      		movw r24,r14
 5811 1e6c B601      		movw r22,r12
 5812 1e6e 0E94 0000 		call __floatunsisf
 5813               	.LVL623:
 5814 1e72 4B01      		movw r8,r22
 5815 1e74 5C01      		movw r10,r24
 5816               	.LVL624:
 5817               	.LBB287:
 5818               	.LBB283:
 167:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 5819               		.loc 4 167 0
 5820 1e76 20E0      		ldi r18,0
 5821 1e78 30E0      		ldi r19,0
 5822 1e7a 40E8      		ldi r20,lo8(-128)
 5823 1e7c 55E4      		ldi r21,lo8(69)
 5824 1e7e 0E94 0000 		call __mulsf3
 5825               	.LVL625:
 5826 1e82 762E      		mov r7,r22
 5827 1e84 672E      		mov r6,r23
 5828 1e86 582E      		mov r5,r24
 5829 1e88 492E      		mov r4,r25
 5830               	.LVL626:
 168:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 5831               		.loc 4 168 0
 5832 1e8a 20E0      		ldi r18,0
 5833 1e8c 30E0      		ldi r19,0
 5834 1e8e 40E8      		ldi r20,lo8(-128)
 5835 1e90 5FE3      		ldi r21,lo8(63)
 5836 1e92 D301      		movw r26,r6
 5837 1e94 F201      		movw r30,r4
 5838 1e96 6B2F      		mov r22,r27
 5839 1e98 7A2F      		mov r23,r26
 5840 1e9a 8F2F      		mov r24,r31
 5841 1e9c 9E2F      		mov r25,r30
 5842 1e9e 0E94 0000 		call __ltsf2
 5843               	.LVL627:
 5844 1ea2 87FD      		sbrc r24,7
 5845 1ea4 00C0      		rjmp .L327
 170:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 5846               		.loc 4 170 0
 5847 1ea6 20E0      		ldi r18,0
 5848 1ea8 3FEF      		ldi r19,lo8(-1)
 5849 1eaa 4FE7      		ldi r20,lo8(127)
 5850 1eac 57E4      		ldi r21,lo8(71)
 5851 1eae D301      		movw r26,r6
 5852 1eb0 F201      		movw r30,r4
 5853 1eb2 6B2F      		mov r22,r27
 5854 1eb4 7A2F      		mov r23,r26
 5855 1eb6 8F2F      		mov r24,r31
 5856 1eb8 9E2F      		mov r25,r30
 5857 1eba 0E94 0000 		call __gtsf2
 5858               	.LVL628:
 5859 1ebe 1816      		cp __zero_reg__,r24
 5860 1ec0 04F4      		brge .L333
 171:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	{
 172:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 5861               		.loc 4 173 0
 5862 1ec2 20E0      		ldi r18,0
 5863 1ec4 30E0      		ldi r19,0
 5864 1ec6 40E2      		ldi r20,lo8(32)
 5865 1ec8 51E4      		ldi r21,lo8(65)
 5866 1eca C501      		movw r24,r10
 5867 1ecc B401      		movw r22,r8
 5868 1ece 0E94 0000 		call __mulsf3
 5869               	.LVL629:
 5870 1ed2 0E94 0000 		call __fixunssfsi
 5871               	.LVL630:
 5872 1ed6 00C0      		rjmp .L313
 5873               	.L314:
 5874               	.LVL631:
 5875               	.LBB279:
 5876               	.LBB278:
 5877               		.loc 2 105 0
 5878 1ed8 CE01      		movw r24,r28
 5879               	/* #APP */
 5880               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 5881 1eda 0197      		1: sbiw r24,1
 5882 1edc 01F4      		brne 1b
 5883               	 ;  0 "" 2
 5884               	.LVL632:
 5885               	/* #NOAPP */
 5886               	.LBE278:
 5887               	.LBE279:
 174:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		{
 176:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 			__ticks --;
 5888               		.loc 4 178 0
 5889 1ede 6150      		subi r22,1
 5890 1ee0 7109      		sbc r23,__zero_reg__
 5891               	.LVL633:
 5892               	.L313:
 174:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 5893               		.loc 4 174 0
 5894 1ee2 6115      		cp r22,__zero_reg__
 5895 1ee4 7105      		cpc r23,__zero_reg__
 5896 1ee6 01F4      		brne .L314
 5897 1ee8 00C0      		rjmp .L315
 5898               	.LVL634:
 5899               	.L333:
 179:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		}
 180:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		return;
 181:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	}
 182:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	else
 183:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 5900               		.loc 4 183 0
 5901 1eea A301      		movw r20,r6
 5902 1eec 9201      		movw r18,r4
 5903 1eee 652F      		mov r22,r21
 5904 1ef0 742F      		mov r23,r20
 5905 1ef2 832F      		mov r24,r19
 5906 1ef4 922F      		mov r25,r18
 5907 1ef6 0E94 0000 		call __fixunssfsi
 5908               	.LVL635:
 5909 1efa 00C0      		rjmp .L310
 5910               	.LVL636:
 5911               	.L327:
 169:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 5912               		.loc 4 169 0
 5913 1efc 61E0      		ldi r22,lo8(1)
 5914 1efe 70E0      		ldi r23,0
 5915               	.L310:
 5916               	.LVL637:
 5917               	.LBB280:
 5918               	.LBB281:
 5919               		.loc 2 105 0
 5920 1f00 CB01      		movw r24,r22
 5921               	/* #APP */
 5922               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 5923 1f02 0197      		1: sbiw r24,1
 5924 1f04 01F4      		brne 1b
 5925               	 ;  0 "" 2
 5926               	.LVL638:
 5927               	/* #NOAPP */
 5928               	.L315:
 5929 1f06 1F5F      		subi r17,lo8(-(1))
 5930               	.LBE281:
 5931               	.LBE280:
 5932               	.LBE283:
 5933               	.LBE287:
1474:main.c        **** 		for( int i = 0; i < 10; i++ ){
 5934               		.loc 3 1474 0
 5935 1f08 1A30      		cpi r17,lo8(10)
 5936 1f0a 01F4      		brne .L308
 5937               	.LBE273:
 5938               	.LBB289:
 5939               	.LBB290:
 5940               	.LBB291:
 5941               		.loc 4 183 0
 5942 1f0c A301      		movw r20,r6
 5943 1f0e 9201      		movw r18,r4
 5944 1f10 652F      		mov r22,r21
 5945               	.LVL639:
 5946 1f12 762D      		mov r23,r6
 5947 1f14 832F      		mov r24,r19
 5948 1f16 942D      		mov r25,r4
 5949 1f18 0E94 0000 		call __fixunssfsi
 5950               	.LVL640:
 5951 1f1c 8B01      		movw r16,r22
 5952 1f1e 20E0      		ldi r18,0
 5953 1f20 30E0      		ldi r19,0
 5954 1f22 40E8      		ldi r20,lo8(-128)
 5955 1f24 5FE3      		ldi r21,lo8(63)
 5956 1f26 D301      		movw r26,r6
 5957 1f28 F201      		movw r30,r4
 5958 1f2a 6B2F      		mov r22,r27
 5959 1f2c 762D      		mov r23,r6
 5960 1f2e 8F2F      		mov r24,r31
 5961 1f30 942D      		mov r25,r4
 5962 1f32 0E94 0000 		call __ltsf2
 5963               	.LVL641:
 5964 1f36 87FF      		sbrs r24,7
 5965 1f38 00C0      		rjmp .L334
 5966 1f3a C1E0      		ldi r28,lo8(1)
 5967 1f3c D0E0      		ldi r29,0
 5968 1f3e 00C0      		rjmp .L317
 5969               	.L334:
 5970 1f40 E801      		movw r28,r16
 5971               	.L317:
 5972 1f42 38E0      		ldi r19,lo8(8)
 5973 1f44 332E      		mov r3,r19
 5974               	.LBB292:
 5975               	.LBB293:
 5976               		.loc 2 105 0
 5977 1f46 09E9      		ldi r16,lo8(-103)
 5978 1f48 11E0      		ldi r17,lo8(1)
 5979 1f4a 00C0      		rjmp .L319
 5980               	.LVL642:
 5981               	.L308:
 5982               	.LBE293:
 5983               	.LBE292:
 5984               	.LBE291:
 5985               	.LBE290:
 5986               	.LBE289:
1472:main.c        **** {		
 5987               		.loc 3 1472 0 discriminator 1
 5988 1f4c 26E0      		ldi r18,lo8(6)
 5989 1f4e A22E      		mov r10,r18
 5990 1f50 B12C      		mov r11,__zero_reg__
 5991 1f52 00C0      		rjmp .L309
 5992               	.LVL643:
 5993               	.L320:
 5994               	.LBB301:
 5995               	.LBB299:
1486:main.c        **** 				sendIntegerToNixie( i, 1 );
 5996               		.loc 3 1486 0 discriminator 2
 5997 1f54 61E0      		ldi r22,lo8(1)
 5998 1f56 832D      		mov r24,r3
 5999 1f58 0E94 0000 		call sendIntegerToNixie
 6000               	.LVL644:
 6001 1f5c 81E0      		ldi r24,1
 6002 1f5e E81A      		sub r14,r24
 6003 1f60 F108      		sbc r15,__zero_reg__
1485:main.c        **** 			for( int j = 0; j < 6; j++ ){
 6004               		.loc 3 1485 0 discriminator 2
 6005 1f62 01F4      		brne .L320
 6006               	.LBE299:
1489:main.c        **** 			shiftRegisterSetOutput();
 6007               		.loc 3 1489 0
 6008 1f64 0E94 0000 		call shiftRegisterSetOutput
 6009               	.LVL645:
 6010               	.LBB300:
 6011               	.LBB298:
 168:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 6012               		.loc 4 168 0
 6013 1f68 20E0      		ldi r18,0
 6014 1f6a 30E0      		ldi r19,0
 6015 1f6c 40E8      		ldi r20,lo8(-128)
 6016 1f6e 5FE3      		ldi r21,lo8(63)
 6017 1f70 D301      		movw r26,r6
 6018 1f72 F201      		movw r30,r4
 6019 1f74 6B2F      		mov r22,r27
 6020 1f76 762D      		mov r23,r6
 6021 1f78 8F2F      		mov r24,r31
 6022 1f7a 942D      		mov r25,r4
 6023 1f7c 0E94 0000 		call __ltsf2
 6024               	.LVL646:
 6025 1f80 87FD      		sbrc r24,7
 6026 1f82 00C0      		rjmp .L321
 170:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 6027               		.loc 4 170 0
 6028 1f84 20E0      		ldi r18,0
 6029 1f86 3FEF      		ldi r19,lo8(-1)
 6030 1f88 4FE7      		ldi r20,lo8(127)
 6031 1f8a 57E4      		ldi r21,lo8(71)
 6032 1f8c D301      		movw r26,r6
 6033 1f8e F201      		movw r30,r4
 6034 1f90 6B2F      		mov r22,r27
 6035 1f92 762D      		mov r23,r6
 6036 1f94 8F2F      		mov r24,r31
 6037 1f96 942D      		mov r25,r4
 6038 1f98 0E94 0000 		call __gtsf2
 6039               	.LVL647:
 6040 1f9c 1816      		cp __zero_reg__,r24
 6041 1f9e 04F4      		brge .L321
 173:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 6042               		.loc 4 173 0
 6043 1fa0 20E0      		ldi r18,0
 6044 1fa2 30E0      		ldi r19,0
 6045 1fa4 40E2      		ldi r20,lo8(32)
 6046 1fa6 51E4      		ldi r21,lo8(65)
 6047 1fa8 C501      		movw r24,r10
 6048 1faa B401      		movw r22,r8
 6049 1fac 0E94 0000 		call __mulsf3
 6050               	.LVL648:
 6051 1fb0 0E94 0000 		call __fixunssfsi
 6052               	.LVL649:
 6053 1fb4 00C0      		rjmp .L323
 6054               	.L324:
 6055               	.LVL650:
 6056               	.LBB295:
 6057               	.LBB294:
 6058               		.loc 2 105 0
 6059 1fb6 C801      		movw r24,r16
 6060               	/* #APP */
 6061               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 6062 1fb8 0197      		1: sbiw r24,1
 6063 1fba 01F4      		brne 1b
 6064               	 ;  0 "" 2
 6065               	.LVL651:
 6066               	/* #NOAPP */
 6067               	.LBE294:
 6068               	.LBE295:
 178:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 			__ticks --;
 6069               		.loc 4 178 0
 6070 1fbc 6150      		subi r22,1
 6071 1fbe 7109      		sbc r23,__zero_reg__
 6072               	.LVL652:
 6073               	.L323:
 174:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 6074               		.loc 4 174 0
 6075 1fc0 6115      		cp r22,__zero_reg__
 6076 1fc2 7105      		cpc r23,__zero_reg__
 6077 1fc4 01F4      		brne .L324
 6078 1fc6 00C0      		rjmp .L325
 6079               	.LVL653:
 6080               	.L321:
 6081               	.LBB296:
 6082               	.LBB297:
 6083               		.loc 2 105 0
 6084 1fc8 CE01      		movw r24,r28
 6085               	/* #APP */
 6086               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 6087 1fca 0197      		1: sbiw r24,1
 6088 1fcc 01F4      		brne 1b
 6089               	 ;  0 "" 2
 6090               	.LVL654:
 6091               	/* #NOAPP */
 6092               	.L325:
 6093 1fce 3A94      		dec r3
 6094               	.LBE297:
 6095               	.LBE296:
 6096               	.LBE298:
 6097               	.LBE300:
1484:main.c        **** 		for( int i = 8; i >= 1; i-- ){
 6098               		.loc 3 1484 0
 6099 1fd0 01F0      		breq .L307
 6100               	.LVL655:
 6101               	.L319:
 6102               	.LBE301:
 6103               	.LBB302:
 6104               	.LBB288:
 6105               	.LBB284:
 169:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 6106               		.loc 4 169 0 discriminator 1
 6107 1fd2 96E0      		ldi r25,lo8(6)
 6108 1fd4 E92E      		mov r14,r25
 6109 1fd6 F12C      		mov r15,__zero_reg__
 6110 1fd8 00C0      		rjmp .L320
 6111               	.LVL656:
 6112               	.L307:
 6113               	/* epilogue start */
 6114               	.LBE284:
 6115               	.LBE288:
 6116               	.LBE302:
1492:main.c        **** }
 6117               		.loc 3 1492 0
 6118 1fda DF91      		pop r29
 6119 1fdc CF91      		pop r28
 6120 1fde 1F91      		pop r17
 6121 1fe0 0F91      		pop r16
 6122 1fe2 FF90      		pop r15
 6123 1fe4 EF90      		pop r14
 6124 1fe6 DF90      		pop r13
 6125 1fe8 CF90      		pop r12
 6126               	.LVL657:
 6127 1fea BF90      		pop r11
 6128 1fec AF90      		pop r10
 6129 1fee 9F90      		pop r9
 6130 1ff0 8F90      		pop r8
 6131               	.LVL658:
 6132 1ff2 7F90      		pop r7
 6133               	.LVL659:
 6134 1ff4 6F90      		pop r6
 6135 1ff6 5F90      		pop r5
 6136 1ff8 4F90      		pop r4
 6137 1ffa 3F90      		pop r3
 6138 1ffc 0895      		ret
 6139               		.cfi_endproc
 6140               	.LFE50:
 6142               	.global	checkCathodePoison
 6144               	checkCathodePoison:
 6145               	.LFB51:
1497:main.c        **** {
 6146               		.loc 3 1497 0
 6147               		.cfi_startproc
 6148               	/* prologue: function */
 6149               	/* frame size = 0 */
 6150               	/* stack size = 0 */
 6151               	.L__stack_usage = 0
1499:main.c        ****         if( minutes == 30 || minutes == 0){
 6152               		.loc 3 1499 0
 6153 1ffe 8091 0000 		lds r24,minutes
 6154 2002 8E31      		cpi r24,lo8(30)
 6155 2004 01F0      		breq .L336
1499:main.c        ****         if( minutes == 30 || minutes == 0){
 6156               		.loc 3 1499 0 is_stmt 0 discriminator 1
 6157 2006 8111      		cpse r24,__zero_reg__
 6158 2008 00C0      		rjmp .L335
 6159               	.L336:
1500:main.c        ****         	if( cathodePoisonFlag == 1 ){
 6160               		.loc 3 1500 0 is_stmt 1
 6161 200a 8091 0000 		lds r24,cathodePoisonFlag
 6162 200e 8130      		cpi r24,lo8(1)
 6163 2010 01F4      		brne .L335
1501:main.c        ****         		antiCathodePoisonPattern( 250 );
 6164               		.loc 3 1501 0
 6165 2012 8AEF      		ldi r24,lo8(-6)
 6166 2014 90E0      		ldi r25,0
 6167 2016 0E94 0000 		call antiCathodePoisonPattern
 6168               	.LVL660:
1502:main.c        ****         		antiCathodePoisonPattern( 225 );
 6169               		.loc 3 1502 0
 6170 201a 81EE      		ldi r24,lo8(-31)
 6171 201c 90E0      		ldi r25,0
 6172 201e 0E94 0000 		call antiCathodePoisonPattern
 6173               	.LVL661:
1503:main.c        ****         		antiCathodePoisonPattern( 200 );
 6174               		.loc 3 1503 0
 6175 2022 88EC      		ldi r24,lo8(-56)
 6176 2024 90E0      		ldi r25,0
 6177 2026 0E94 0000 		call antiCathodePoisonPattern
 6178               	.LVL662:
1504:main.c        ****         		antiCathodePoisonPattern( 175 );
 6179               		.loc 3 1504 0
 6180 202a 8FEA      		ldi r24,lo8(-81)
 6181 202c 90E0      		ldi r25,0
 6182 202e 0E94 0000 		call antiCathodePoisonPattern
 6183               	.LVL663:
1505:main.c        ****         		antiCathodePoisonPattern( 150 );
 6184               		.loc 3 1505 0
 6185 2032 86E9      		ldi r24,lo8(-106)
 6186 2034 90E0      		ldi r25,0
 6187 2036 0E94 0000 		call antiCathodePoisonPattern
 6188               	.LVL664:
1506:main.c        ****         		antiCathodePoisonPattern( 125 );
 6189               		.loc 3 1506 0
 6190 203a 8DE7      		ldi r24,lo8(125)
 6191 203c 90E0      		ldi r25,0
 6192 203e 0E94 0000 		call antiCathodePoisonPattern
 6193               	.LVL665:
1507:main.c        ****         		antiCathodePoisonPattern( 100 );
 6194               		.loc 3 1507 0
 6195 2042 84E6      		ldi r24,lo8(100)
 6196 2044 90E0      		ldi r25,0
 6197 2046 0E94 0000 		call antiCathodePoisonPattern
 6198               	.LVL666:
1508:main.c        ****         		antiCathodePoisonPattern( 75 );
 6199               		.loc 3 1508 0
 6200 204a 8BE4      		ldi r24,lo8(75)
 6201 204c 90E0      		ldi r25,0
 6202 204e 0E94 0000 		call antiCathodePoisonPattern
 6203               	.LVL667:
1509:main.c        ****         		antiCathodePoisonPattern( 50 );
 6204               		.loc 3 1509 0
 6205 2052 82E3      		ldi r24,lo8(50)
 6206 2054 90E0      		ldi r25,0
 6207 2056 0E94 0000 		call antiCathodePoisonPattern
 6208               	.LVL668:
1510:main.c        ****         		antiCathodePoisonPattern( 25 );
 6209               		.loc 3 1510 0
 6210 205a 89E1      		ldi r24,lo8(25)
 6211 205c 90E0      		ldi r25,0
 6212 205e 0E94 0000 		call antiCathodePoisonPattern
 6213               	.LVL669:
1511:main.c        ****         		antiCathodePoisonPattern( 10 );
 6214               		.loc 3 1511 0
 6215 2062 8AE0      		ldi r24,lo8(10)
 6216 2064 90E0      		ldi r25,0
 6217 2066 0E94 0000 		call antiCathodePoisonPattern
 6218               	.LVL670:
1512:main.c        ****         		antiCathodePoisonPattern( 10 );
 6219               		.loc 3 1512 0
 6220 206a 8AE0      		ldi r24,lo8(10)
 6221 206c 90E0      		ldi r25,0
 6222 206e 0E94 0000 		call antiCathodePoisonPattern
 6223               	.LVL671:
1513:main.c        ****         		antiCathodePoisonPattern( 5 );
 6224               		.loc 3 1513 0
 6225 2072 85E0      		ldi r24,lo8(5)
 6226 2074 90E0      		ldi r25,0
 6227 2076 0E94 0000 		call antiCathodePoisonPattern
 6228               	.LVL672:
1514:main.c        ****         		cathodePoisonFlag = 0;				// Reset the counter.
 6229               		.loc 3 1514 0
 6230 207a 1092 0000 		sts cathodePoisonFlag,__zero_reg__
 6231               	.L335:
 6232 207e 0895      		ret
 6233               		.cfi_endproc
 6234               	.LFE51:
 6236               	.global	__gesf2
 6237               	.global	__subsf3
 6238               	.global	nixiePrintTemperature
 6240               	nixiePrintTemperature:
 6241               	.LFB56:
1687:main.c        **** 	}
1688:main.c        **** 	break;
1689:main.c        **** 
1690:main.c        **** 	}
1691:main.c        **** }
1692:main.c        **** 
1693:main.c        **** 
1694:main.c        **** 
1695:main.c        **** 
1696:main.c        **** void nixiePrintTemperature( void )
1697:main.c        **** {
 6242               		.loc 3 1697 0
 6243               		.cfi_startproc
 6244 2080 CF92      		push r12
 6245               	.LCFI92:
 6246               		.cfi_def_cfa_offset 3
 6247               		.cfi_offset 12, -2
 6248 2082 DF92      		push r13
 6249               	.LCFI93:
 6250               		.cfi_def_cfa_offset 4
 6251               		.cfi_offset 13, -3
 6252 2084 EF92      		push r14
 6253               	.LCFI94:
 6254               		.cfi_def_cfa_offset 5
 6255               		.cfi_offset 14, -4
 6256 2086 FF92      		push r15
 6257               	.LCFI95:
 6258               		.cfi_def_cfa_offset 6
 6259               		.cfi_offset 15, -5
 6260 2088 1F93      		push r17
 6261               	.LCFI96:
 6262               		.cfi_def_cfa_offset 7
 6263               		.cfi_offset 17, -6
 6264 208a CF93      		push r28
 6265               	.LCFI97:
 6266               		.cfi_def_cfa_offset 8
 6267               		.cfi_offset 28, -7
 6268 208c DF93      		push r29
 6269               	.LCFI98:
 6270               		.cfi_def_cfa_offset 9
 6271               		.cfi_offset 29, -8
 6272               	/* prologue: function */
 6273               	/* frame size = 0 */
 6274               	/* stack size = 7 */
 6275               	.L__stack_usage = 7
 6276               	.LVL673:
1698:main.c        **** 	// We have 6 nixie tubes.  Let's let the left most digit be "0" for positive temperaures
1699:main.c        **** 	// and "1" for negative.  Let's do 2 decimal places, and that leaves 3 places for the
1700:main.c        **** 	// whole number temperature.
1701:main.c        **** 
1702:main.c        **** 	//averageCelsiusTemperature = -104.23;	// For testing.
1703:main.c        **** 	
1704:main.c        **** 	uint8_t isNegative = 0;		// 0 for positive temperatures, 1 for negative
1705:main.c        **** 	
1706:main.c        **** 	// Determine if the temperature is negative.
1707:main.c        **** 	// If so, we will set the leftmost nixie to "1".
1708:main.c        **** 	if( averageCelsiusTemperature >= 0 ){
 6277               		.loc 3 1708 0
 6278 208e C090 0000 		lds r12,averageCelsiusTemperature
 6279 2092 D090 0000 		lds r13,averageCelsiusTemperature+1
 6280 2096 E090 0000 		lds r14,averageCelsiusTemperature+2
 6281 209a F090 0000 		lds r15,averageCelsiusTemperature+3
 6282 209e D1E0      		ldi r29,lo8(1)
 6283 20a0 20E0      		ldi r18,0
 6284 20a2 30E0      		ldi r19,0
 6285 20a4 A901      		movw r20,r18
 6286 20a6 C701      		movw r24,r14
 6287 20a8 B601      		movw r22,r12
 6288 20aa 0E94 0000 		call __gesf2
 6289               	.LVL674:
 6290 20ae 87FD      		sbrc r24,7
 6291 20b0 D0E0      		ldi r29,0
 6292               	.L342:
 6293 20b2 C1E0      		ldi r28,lo8(1)
 6294 20b4 CD27      		eor r28,r29
 6295               	.LVL675:
1709:main.c        **** 		isNegative = 0;
1710:main.c        **** 	}else{
1711:main.c        **** 		isNegative = 1;
1712:main.c        **** 	}
1713:main.c        **** 	
1714:main.c        **** 	// Get the current temperature reading.
1715:main.c        **** 	double absValTemperature = averageCelsiusTemperature;
1716:main.c        **** 	
1717:main.c        **** 	// And if negative, convert to absolute value of the temperature reading.
1718:main.c        **** 	if( averageCelsiusTemperature < 0 )
 6296               		.loc 3 1718 0
 6297 20b6 20E0      		ldi r18,0
 6298 20b8 30E0      		ldi r19,0
 6299 20ba A901      		movw r20,r18
 6300 20bc C701      		movw r24,r14
 6301 20be B601      		movw r22,r12
 6302 20c0 0E94 0000 		call __ltsf2
 6303               	.LVL676:
 6304 20c4 87FF      		sbrs r24,7
 6305 20c6 00C0      		rjmp .L343
1719:main.c        **** 		absValTemperature *= -1; 
 6306               		.loc 3 1719 0
 6307 20c8 F7FA      		bst r15,7
 6308 20ca F094      		com r15
 6309 20cc F7F8      		bld r15,7
 6310 20ce F094      		com r15
 6311               	.LVL677:
 6312               	.L343:
1720:main.c        **** 	
1721:main.c        **** 		
1722:main.c        **** 	// Convert to Fahrenheit if necessary. 
1723:main.c        **** 	if( celsius == 0 )	
 6313               		.loc 3 1723 0
 6314 20d0 8091 0000 		lds r24,celsius
 6315 20d4 8111      		cpse r24,__zero_reg__
 6316 20d6 00C0      		rjmp .L345
1724:main.c        ****     {
1725:main.c        ****     	absValTemperature = ( absValTemperature * 1.8 ) + 32;
 6317               		.loc 3 1725 0
 6318 20d8 26E6      		ldi r18,lo8(102)
 6319 20da 36E6      		ldi r19,lo8(102)
 6320 20dc 46EE      		ldi r20,lo8(-26)
 6321 20de 5FE3      		ldi r21,lo8(63)
 6322 20e0 C701      		movw r24,r14
 6323 20e2 B601      		movw r22,r12
 6324 20e4 0E94 0000 		call __mulsf3
 6325               	.LVL678:
 6326 20e8 20E0      		ldi r18,0
 6327 20ea 30E0      		ldi r19,0
 6328 20ec 40E0      		ldi r20,0
 6329 20ee 52E4      		ldi r21,lo8(66)
 6330 20f0 0E94 0000 		call __addsf3
 6331               	.LVL679:
 6332 20f4 C62E      		mov r12,r22
 6333               	.LVL680:
 6334 20f6 D72E      		mov r13,r23
 6335 20f8 E82E      		mov r14,r24
 6336 20fa F92E      		mov r15,r25
 6337               	.LVL681:
 6338               	.L345:
1726:main.c        ****     }
1727:main.c        ****    
1728:main.c        ****     
1729:main.c        ****     // The temperature reading to the left of the decimal point. 
1730:main.c        **** 	uint8_t intPartTemperature = absValTemperature;	
 6339               		.loc 3 1730 0
 6340 20fc C701      		movw r24,r14
 6341 20fe B601      		movw r22,r12
 6342 2100 0E94 0000 		call __fixunssfsi
 6343               	.LVL682:
 6344 2104 D62F      		mov r29,r22
 6345               	.LVL683:
1731:main.c        **** 		
1732:main.c        **** 		
1733:main.c        **** 	// Temperature reading to the right of the decimal point.						
1734:main.c        **** 	uint8_t decimalPartTemperature = ( absValTemperature - intPartTemperature ) * 100;
 6346               		.loc 3 1734 0
 6347 2106 70E0      		ldi r23,0
 6348 2108 80E0      		ldi r24,0
 6349 210a 90E0      		ldi r25,0
 6350 210c 0E94 0000 		call __floatsisf
 6351               	.LVL684:
 6352 2110 9B01      		movw r18,r22
 6353 2112 AC01      		movw r20,r24
 6354 2114 C701      		movw r24,r14
 6355 2116 B601      		movw r22,r12
 6356 2118 0E94 0000 		call __subsf3
 6357               	.LVL685:
 6358 211c 20E0      		ldi r18,0
 6359 211e 30E0      		ldi r19,0
 6360 2120 48EC      		ldi r20,lo8(-56)
 6361 2122 52E4      		ldi r21,lo8(66)
 6362 2124 0E94 0000 		call __mulsf3
 6363               	.LVL686:
 6364 2128 0E94 0000 		call __fixunssfsi
 6365               	.LVL687:
 6366 212c 862F      		mov r24,r22
 6367               	.LVL688:
1735:main.c        ****             
1736:main.c        ****             
1737:main.c        **** 	uint8_t ones = 0;		// For outputting the digits to the nixies in order.
1738:main.c        **** 	uint8_t tens = 0;
1739:main.c        **** 	uint8_t hundreds = 0;
1740:main.c        **** 				
1741:main.c        **** 	// starting from the rightmost, decimal portion of the temperature.
1742:main.c        **** 	ones = decimalPartTemperature % 10;	// Grab the specific digits.
 6368               		.loc 3 1742 0
 6369 212e 1AE0      		ldi r17,lo8(10)
 6370 2130 612F      		mov r22,r17
 6371               	.LVL689:
 6372 2132 0E94 0000 		call __udivmodqi4
 6373               	.LVL690:
 6374 2136 F82E      		mov r15,r24
 6375 2138 892F      		mov r24,r25
 6376               	.LVL691:
1743:main.c        **** 	tens = decimalPartTemperature / 10;		
1744:main.c        **** 	
1745:main.c        **** 	sendIntegerToNixie( ones, 0 );		// Display the digits.
 6377               		.loc 3 1745 0
 6378 213a 60E0      		ldi r22,0
 6379 213c 0E94 0000 		call sendIntegerToNixie
 6380               	.LVL692:
1746:main.c        **** 	sendIntegerToNixie( tens, 1 );		// Display the decimal point.
 6381               		.loc 3 1746 0
 6382 2140 61E0      		ldi r22,lo8(1)
 6383 2142 8F2D      		mov r24,r15
 6384 2144 0E94 0000 		call sendIntegerToNixie
 6385               	.LVL693:
1747:main.c        **** 	
1748:main.c        **** 	
1749:main.c        **** 	// And now the integer portion.
1750:main.c        ****     ones = intPartTemperature % 10;   
1751:main.c        ****     intPartTemperature /= 10;
 6386               		.loc 3 1751 0
 6387 2148 8D2F      		mov r24,r29
 6388 214a 612F      		mov r22,r17
 6389 214c 0E94 0000 		call __udivmodqi4
 6390               	.LVL694:
 6391 2150 D82F      		mov r29,r24
 6392               	.LVL695:
 6393 2152 892F      		mov r24,r25
 6394               	.LVL696:
1752:main.c        ****     tens = intPartTemperature % 10;
1753:main.c        ****     intPartTemperature /= 10;
1754:main.c        ****     hundreds = intPartTemperature %10;		
1755:main.c        **** 	
1756:main.c        **** 	sendIntegerToNixie( ones, 0 );		// Display the digits.
 6395               		.loc 3 1756 0
 6396 2154 60E0      		ldi r22,0
 6397 2156 0E94 0000 		call sendIntegerToNixie
 6398               	.LVL697:
1752:main.c        ****     tens = intPartTemperature % 10;
 6399               		.loc 3 1752 0
 6400 215a 8D2F      		mov r24,r29
 6401 215c 612F      		mov r22,r17
 6402 215e 0E94 0000 		call __udivmodqi4
 6403               	.LVL698:
 6404 2162 D82F      		mov r29,r24
 6405               	.LVL699:
 6406 2164 892F      		mov r24,r25
 6407               	.LVL700:
1757:main.c        **** 	sendIntegerToNixie( tens, 0 );		
 6408               		.loc 3 1757 0
 6409 2166 60E0      		ldi r22,0
 6410 2168 0E94 0000 		call sendIntegerToNixie
 6411               	.LVL701:
1754:main.c        ****     hundreds = intPartTemperature %10;		
 6412               		.loc 3 1754 0
 6413 216c 8D2F      		mov r24,r29
 6414 216e 612F      		mov r22,r17
 6415 2170 0E94 0000 		call __udivmodqi4
 6416               	.LVL702:
 6417 2174 892F      		mov r24,r25
1758:main.c        **** 	sendIntegerToNixie( hundreds, 0 );
 6418               		.loc 3 1758 0
 6419 2176 60E0      		ldi r22,0
 6420 2178 0E94 0000 		call sendIntegerToNixie
 6421               	.LVL703:
1759:main.c        **** 	
1760:main.c        **** 	sendIntegerToNixie( isNegative, 0 );	// Is the temperature negative?
 6422               		.loc 3 1760 0
 6423 217c 60E0      		ldi r22,0
 6424 217e 8C2F      		mov r24,r28
 6425               	/* epilogue start */
1761:main.c        **** 
1762:main.c        **** }
 6426               		.loc 3 1762 0
 6427 2180 DF91      		pop r29
 6428               	.LVL704:
 6429 2182 CF91      		pop r28
 6430               	.LVL705:
 6431 2184 1F91      		pop r17
 6432 2186 FF90      		pop r15
 6433 2188 EF90      		pop r14
 6434 218a DF90      		pop r13
 6435 218c CF90      		pop r12
 6436               	.LVL706:
1760:main.c        **** 	sendIntegerToNixie( isNegative, 0 );	// Is the temperature negative?
 6437               		.loc 3 1760 0
 6438 218e 0C94 0000 		jmp sendIntegerToNixie
 6439               	.LVL707:
 6440               		.cfi_endproc
 6441               	.LFE56:
 6443               	.global	nixiePrintTime
 6445               	nixiePrintTime:
 6446               	.LFB57:
1763:main.c        **** 
1764:main.c        **** 
1765:main.c        **** 
1766:main.c        **** 
1767:main.c        **** void nixiePrintTime( uint8_t doToggleDecimal )
1768:main.c        **** {
 6447               		.loc 3 1768 0
 6448               		.cfi_startproc
 6449               	.LVL708:
 6450 2192 1F93      		push r17
 6451               	.LCFI99:
 6452               		.cfi_def_cfa_offset 3
 6453               		.cfi_offset 17, -2
 6454 2194 CF93      		push r28
 6455               	.LCFI100:
 6456               		.cfi_def_cfa_offset 4
 6457               		.cfi_offset 28, -3
 6458 2196 DF93      		push r29
 6459               	.LCFI101:
 6460               		.cfi_def_cfa_offset 5
 6461               		.cfi_offset 29, -4
 6462               	/* prologue: function */
 6463               	/* frame size = 0 */
 6464               	/* stack size = 3 */
 6465               	.L__stack_usage = 3
 6466               	.LVL709:
1769:main.c        **** 	int myDecimal = 1;
1770:main.c        **** 	
1771:main.c        **** 	if( doToggleDecimal ){			// Toggle the nixie Decimal point.
 6467               		.loc 3 1771 0
 6468 2198 8823      		tst r24
 6469 219a 01F0      		breq .L351
1772:main.c        **** 		if( seconds % 2 == 0 ){
 6470               		.loc 3 1772 0
 6471 219c 8091 0000 		lds r24,seconds
 6472               	.LVL710:
 6473 21a0 8095      		com r24
1773:main.c        **** 			myDecimal = 1;
1774:main.c        **** 		}
1775:main.c        **** 		else{
1776:main.c        **** 			myDecimal = 0;
 6474               		.loc 3 1776 0
 6475 21a2 8170      		andi r24,1
 6476 21a4 C82F      		mov r28,r24
 6477 21a6 00C0      		rjmp .L348
 6478               	.LVL711:
 6479               	.L351:
1777:main.c        **** 			}
1778:main.c        **** 		}else{
1779:main.c        **** 			myDecimal = 1;	// Else, they are steady ON.	
 6480               		.loc 3 1779 0
 6481 21a8 C1E0      		ldi r28,lo8(1)
 6482 21aa D0E0      		ldi r29,0
 6483               	.LVL712:
 6484               	.L348:
1780:main.c        **** 	}
1781:main.c        **** 	
1782:main.c        **** 	
1783:main.c        **** 	// Seconds
1784:main.c        **** 	// It can happen that nixiePrintTime() is called before updateDateTime() has had a change to roll 
1785:main.c        **** 	// In which case seconds here can be >= 60.  This does not effect the determinism or accuracy of t
1786:main.c        **** 	// However, it may be disturbing to some people to see 60 seconds displayed on a clock when it sho
1787:main.c        **** 	// We will adjust the 10's of seconds below, the one's of seconds will take care of themselves.
1788:main.c        **** 	 
1789:main.c        **** 	uint8_t tens = seconds;
 6485               		.loc 3 1789 0
 6486 21ac 2091 0000 		lds r18,seconds
 6487               	.LVL713:
1790:main.c        **** 	uint8_t ones = tens;
1791:main.c        **** 				
1792:main.c        **** 	tens /= 10;		// Get the "ten's" of seconds.
 6488               		.loc 3 1792 0
 6489 21b0 822F      		mov r24,r18
 6490 21b2 6AE0      		ldi r22,lo8(10)
 6491 21b4 0E94 0000 		call __udivmodqi4
 6492 21b8 182F      		mov r17,r24
 6493               	.LVL714:
1793:main.c        **** 	if( tens > 5 )
 6494               		.loc 3 1793 0
 6495 21ba 8630      		cpi r24,lo8(6)
 6496 21bc 00F0      		brlo .L349
1794:main.c        **** 		tens = 0;	// Restrict the display to 0::59 seconds. ( Read above that this does not affect accura
 6497               		.loc 3 1794 0
 6498 21be 10E0      		ldi r17,0
 6499               	.LVL715:
 6500               	.L349:
1795:main.c        **** 	ones %= 10;		// Get the "one's" of seconds
 6501               		.loc 3 1795 0
 6502 21c0 DAE0      		ldi r29,lo8(10)
 6503 21c2 822F      		mov r24,r18
 6504 21c4 6D2F      		mov r22,r29
 6505 21c6 0E94 0000 		call __udivmodqi4
 6506               	.LVL716:
 6507 21ca 892F      		mov r24,r25
1796:main.c        **** 	
1797:main.c        **** 	sendIntegerToNixie( ones, 0 );
 6508               		.loc 3 1797 0
 6509 21cc 60E0      		ldi r22,0
 6510 21ce 0E94 0000 		call sendIntegerToNixie
 6511               	.LVL717:
1798:main.c        **** 	sendIntegerToNixie( tens, myDecimal );
 6512               		.loc 3 1798 0
 6513 21d2 6C2F      		mov r22,r28
 6514 21d4 812F      		mov r24,r17
 6515 21d6 0E94 0000 		call sendIntegerToNixie
 6516               	.LVL718:
1799:main.c        **** 	
1800:main.c        **** 	
1801:main.c        **** 	// Minutes
1802:main.c        **** 	tens = minutes;
 6517               		.loc 3 1802 0
 6518 21da 8091 0000 		lds r24,minutes
 6519               	.LVL719:
1803:main.c        **** 	ones = tens;
1804:main.c        **** 	
1805:main.c        **** 	tens /= 10;		// Get the "ten's" of minutes.
1806:main.c        **** 	ones %= 10;		// Get the "one's" of minutes
 6520               		.loc 3 1806 0
 6521 21de 6D2F      		mov r22,r29
 6522 21e0 0E94 0000 		call __udivmodqi4
 6523               	.LVL720:
 6524 21e4 D82F      		mov r29,r24
 6525 21e6 892F      		mov r24,r25
 6526               	.LVL721:
1807:main.c        **** 	
1808:main.c        **** 	sendIntegerToNixie( ones, 0 );
 6527               		.loc 3 1808 0
 6528 21e8 60E0      		ldi r22,0
 6529 21ea 0E94 0000 		call sendIntegerToNixie
 6530               	.LVL722:
1809:main.c        **** 	sendIntegerToNixie( tens, myDecimal );
 6531               		.loc 3 1809 0
 6532 21ee 6C2F      		mov r22,r28
 6533 21f0 8D2F      		mov r24,r29
 6534 21f2 0E94 0000 		call sendIntegerToNixie
 6535               	.LVL723:
1810:main.c        **** 	
1811:main.c        **** 	
1812:main.c        **** 	// Hours
1813:main.c        **** 	uint8_t myHours = hours;
 6536               		.loc 3 1813 0
 6537 21f6 8091 0000 		lds r24,hours
 6538               	.LVL724:
1814:main.c        **** 	
1815:main.c        **** 	if( miltime == 0 && hours > 12 )
 6539               		.loc 3 1815 0
 6540 21fa 9091 0000 		lds r25,miltime
 6541 21fe 9111      		cpse r25,__zero_reg__
 6542 2200 00C0      		rjmp .L350
 6543               		.loc 3 1815 0 is_stmt 0 discriminator 1
 6544 2202 8D30      		cpi r24,lo8(13)
 6545 2204 00F0      		brlo .L350
1816:main.c        **** 		myHours -= 12;
 6546               		.loc 3 1816 0 is_stmt 1
 6547 2206 8C50      		subi r24,lo8(-(-12))
 6548               	.LVL725:
 6549               	.L350:
1817:main.c        **** 		
1818:main.c        **** 	tens = myHours;
1819:main.c        **** 	ones = tens;
1820:main.c        **** 	
1821:main.c        **** 	tens /= 10;		// Get the "ten's" of hours.
1822:main.c        **** 	ones %= 10;		// Get the "one's" of hours.
 6550               		.loc 3 1822 0
 6551 2208 6AE0      		ldi r22,lo8(10)
 6552 220a 0E94 0000 		call __udivmodqi4
 6553               	.LVL726:
 6554 220e C82F      		mov r28,r24
 6555 2210 892F      		mov r24,r25
 6556               	.LVL727:
1823:main.c        **** 	
1824:main.c        **** 	sendIntegerToNixie( ones, 0 );
 6557               		.loc 3 1824 0
 6558 2212 60E0      		ldi r22,0
 6559 2214 0E94 0000 		call sendIntegerToNixie
 6560               	.LVL728:
1825:main.c        **** 	sendIntegerToNixie( tens, 0 );
 6561               		.loc 3 1825 0
 6562 2218 60E0      		ldi r22,0
 6563 221a 8C2F      		mov r24,r28
 6564               	/* epilogue start */
1826:main.c        **** 
1827:main.c        **** }
 6565               		.loc 3 1827 0
 6566 221c DF91      		pop r29
 6567 221e CF91      		pop r28
 6568               	.LVL729:
 6569 2220 1F91      		pop r17
1825:main.c        **** 	sendIntegerToNixie( tens, 0 );
 6570               		.loc 3 1825 0
 6571 2222 0C94 0000 		jmp sendIntegerToNixie
 6572               	.LVL730:
 6573               		.cfi_endproc
 6574               	.LFE57:
 6576               	.global	nixiePrintDate
 6578               	nixiePrintDate:
 6579               	.LFB58:
1828:main.c        **** 
1829:main.c        **** 
1830:main.c        **** 
1831:main.c        **** 
1832:main.c        **** void nixiePrintDate( void )
1833:main.c        **** {
 6580               		.loc 3 1833 0
 6581               		.cfi_startproc
 6582 2226 0F93      		push r16
 6583               	.LCFI102:
 6584               		.cfi_def_cfa_offset 3
 6585               		.cfi_offset 16, -2
 6586 2228 1F93      		push r17
 6587               	.LCFI103:
 6588               		.cfi_def_cfa_offset 4
 6589               		.cfi_offset 17, -3
 6590 222a CF93      		push r28
 6591               	.LCFI104:
 6592               		.cfi_def_cfa_offset 5
 6593               		.cfi_offset 28, -4
 6594 222c DF93      		push r29
 6595               	.LCFI105:
 6596               		.cfi_def_cfa_offset 6
 6597               		.cfi_offset 29, -5
 6598               	/* prologue: function */
 6599               	/* frame size = 0 */
 6600               	/* stack size = 4 */
 6601               	.L__stack_usage = 4
1834:main.c        **** 	// Printing the date in YY.MM.DD format to the nixies
1835:main.c        **** 	
1836:main.c        **** 	// Print the day.
1837:main.c        **** 	uint8_t ones = day;
 6602               		.loc 3 1837 0
 6603 222e 8091 0000 		lds r24,day
 6604               	.LVL731:
1838:main.c        **** 	uint8_t tens = ones;
1839:main.c        **** 				
1840:main.c        **** 	tens /= 10;		// Get the "ten's" of days.
1841:main.c        **** 	ones %= 10;		// Get the "one's" of days.
 6605               		.loc 3 1841 0
 6606 2232 CAE0      		ldi r28,lo8(10)
 6607 2234 6C2F      		mov r22,r28
 6608 2236 0E94 0000 		call __udivmodqi4
 6609               	.LVL732:
 6610 223a D82F      		mov r29,r24
 6611 223c 892F      		mov r24,r25
 6612               	.LVL733:
1842:main.c        **** 	
1843:main.c        **** 	sendIntegerToNixie( ones, 0 );
 6613               		.loc 3 1843 0
 6614 223e 60E0      		ldi r22,0
 6615 2240 0E94 0000 		call sendIntegerToNixie
 6616               	.LVL734:
1844:main.c        **** 	sendIntegerToNixie( tens, 1 );
 6617               		.loc 3 1844 0
 6618 2244 61E0      		ldi r22,lo8(1)
 6619 2246 8D2F      		mov r24,r29
 6620 2248 0E94 0000 		call sendIntegerToNixie
 6621               	.LVL735:
1845:main.c        **** 	
1846:main.c        **** 	
1847:main.c        **** 	// Print the month.
1848:main.c        **** 	 ones = month;
 6622               		.loc 3 1848 0
 6623 224c 8091 0000 		lds r24,month
 6624               	.LVL736:
1849:main.c        **** 	 tens = ones;
1850:main.c        **** 				
1851:main.c        **** 	tens /= 10;		// Get the "ten's" of months.
1852:main.c        **** 	ones %= 10;		// Get the "one's" of months.
 6625               		.loc 3 1852 0
 6626 2250 6C2F      		mov r22,r28
 6627 2252 0E94 0000 		call __udivmodqi4
 6628               	.LVL737:
 6629 2256 C82F      		mov r28,r24
 6630 2258 892F      		mov r24,r25
 6631               	.LVL738:
1853:main.c        **** 	
1854:main.c        **** 	sendIntegerToNixie( ones, 0 );
 6632               		.loc 3 1854 0
 6633 225a 60E0      		ldi r22,0
 6634 225c 0E94 0000 		call sendIntegerToNixie
 6635               	.LVL739:
1855:main.c        **** 	sendIntegerToNixie( tens, 1 );
 6636               		.loc 3 1855 0
 6637 2260 61E0      		ldi r22,lo8(1)
 6638 2262 8C2F      		mov r24,r28
 6639 2264 0E94 0000 		call sendIntegerToNixie
 6640               	.LVL740:
1856:main.c        **** 
1857:main.c        **** 	
1858:main.c        **** 	// Print the Year.
1859:main.c        **** 	uint16_t myYear = year;
 6641               		.loc 3 1859 0
 6642 2268 8091 0000 		lds r24,year
 6643 226c 9091 0000 		lds r25,year+1
 6644               	.LVL741:
1860:main.c        **** 	
1861:main.c        **** 	ones = myYear % 10;   
 6645               		.loc 3 1861 0
 6646 2270 CAE0      		ldi r28,lo8(10)
 6647 2272 D0E0      		ldi r29,0
 6648 2274 BE01      		movw r22,r28
 6649 2276 0E94 0000 		call __udivmodhi4
 6650               	.LVL742:
 6651 227a 8B01      		movw r16,r22
1862:main.c        ****     myYear /= 10;
1863:main.c        ****     tens = myYear % 10;
1864:main.c        ****     
1865:main.c        **** 	sendIntegerToNixie( ones, 0 );		// Display the digits.
 6652               		.loc 3 1865 0
 6653 227c 60E0      		ldi r22,0
 6654               	.LVL743:
 6655 227e 0E94 0000 		call sendIntegerToNixie
 6656               	.LVL744:
1863:main.c        ****     tens = myYear % 10;
 6657               		.loc 3 1863 0
 6658 2282 C801      		movw r24,r16
 6659 2284 BE01      		movw r22,r28
 6660 2286 0E94 0000 		call __udivmodhi4
1866:main.c        **** 	sendIntegerToNixie( tens, 0 );		
 6661               		.loc 3 1866 0
 6662 228a 60E0      		ldi r22,0
 6663               	/* epilogue start */
1867:main.c        **** 	
1868:main.c        **** }
 6664               		.loc 3 1868 0
 6665 228c DF91      		pop r29
 6666 228e CF91      		pop r28
 6667 2290 1F91      		pop r17
 6668 2292 0F91      		pop r16
 6669               	.LVL745:
1866:main.c        **** 	sendIntegerToNixie( tens, 0 );		
 6670               		.loc 3 1866 0
 6671 2294 0C94 0000 		jmp sendIntegerToNixie
 6672               	.LVL746:
 6673               		.cfi_endproc
 6674               	.LFE58:
 6676               	.global	nixiePrintAcFrequency
 6678               	nixiePrintAcFrequency:
 6679               	.LFB59:
1869:main.c        **** 
1870:main.c        **** 
1871:main.c        **** 
1872:main.c        **** 
1873:main.c        **** 
1874:main.c        **** 
1875:main.c        **** void nixiePrintAcFrequency( void )
1876:main.c        **** {
 6680               		.loc 3 1876 0
 6681               		.cfi_startproc
 6682 2298 AF92      		push r10
 6683               	.LCFI106:
 6684               		.cfi_def_cfa_offset 3
 6685               		.cfi_offset 10, -2
 6686 229a BF92      		push r11
 6687               	.LCFI107:
 6688               		.cfi_def_cfa_offset 4
 6689               		.cfi_offset 11, -3
 6690 229c CF92      		push r12
 6691               	.LCFI108:
 6692               		.cfi_def_cfa_offset 5
 6693               		.cfi_offset 12, -4
 6694 229e DF92      		push r13
 6695               	.LCFI109:
 6696               		.cfi_def_cfa_offset 6
 6697               		.cfi_offset 13, -5
 6698 22a0 EF92      		push r14
 6699               	.LCFI110:
 6700               		.cfi_def_cfa_offset 7
 6701               		.cfi_offset 14, -6
 6702 22a2 FF92      		push r15
 6703               	.LCFI111:
 6704               		.cfi_def_cfa_offset 8
 6705               		.cfi_offset 15, -7
 6706 22a4 0F93      		push r16
 6707               	.LCFI112:
 6708               		.cfi_def_cfa_offset 9
 6709               		.cfi_offset 16, -8
 6710 22a6 1F93      		push r17
 6711               	.LCFI113:
 6712               		.cfi_def_cfa_offset 10
 6713               		.cfi_offset 17, -9
 6714 22a8 CF93      		push r28
 6715               	.LCFI114:
 6716               		.cfi_def_cfa_offset 11
 6717               		.cfi_offset 28, -10
 6718 22aa DF93      		push r29
 6719               	.LCFI115:
 6720               		.cfi_def_cfa_offset 12
 6721               		.cfi_offset 29, -11
 6722               	/* prologue: function */
 6723               	/* frame size = 0 */
 6724               	/* stack size = 10 */
 6725               	.L__stack_usage = 10
1877:main.c        **** 	uint32_t myFrequency = acFrequency * 1000;	// Shift everything over 3 decimal places.
 6726               		.loc 3 1877 0
 6727 22ac 6091 0000 		lds r22,acFrequency
 6728 22b0 7091 0000 		lds r23,acFrequency+1
 6729 22b4 8091 0000 		lds r24,acFrequency+2
 6730 22b8 9091 0000 		lds r25,acFrequency+3
 6731 22bc 20E0      		ldi r18,0
 6732 22be 30E0      		ldi r19,0
 6733 22c0 4AE7      		ldi r20,lo8(122)
 6734 22c2 54E4      		ldi r21,lo8(68)
 6735 22c4 0E94 0000 		call __mulsf3
 6736               	.LVL747:
 6737 22c8 0E94 0000 		call __fixunssfsi
 6738               	.LVL748:
 6739 22cc B62E      		mov r11,r22
 6740 22ce A72E      		mov r10,r23
 6741 22d0 182F      		mov r17,r24
 6742 22d2 092F      		mov r16,r25
 6743               	.LVL749:
1878:main.c        **** 	uint8_t intToSend = 0;						// The extracted digit to send to the nixie.
1879:main.c        **** 	
1880:main.c        **** 	// Loop 5 times because we have 5 digits to display.
1881:main.c        **** 	for( int i = 0; i < 5; i++ )
 6744               		.loc 3 1881 0
 6745 22d4 C0E0      		ldi r28,0
 6746 22d6 D0E0      		ldi r29,0
 6747               	.LBB307:
 6748               	.LBB308:
1882:main.c        **** 	{
1883:main.c        **** 		uint8_t myDecimal = 0;
1884:main.c        **** 		
1885:main.c        **** 		if( i == 2 ){		// put a decimal point in the right spot.
1886:main.c        **** 			myDecimal = 1;
1887:main.c        **** 		}else{
1888:main.c        **** 			myDecimal = 0;
1889:main.c        **** 		}
1890:main.c        **** 		
1891:main.c        **** 		intToSend = myFrequency % 10;				// Extract the rightmost digit.
 6749               		.loc 3 1891 0
 6750 22d8 4AE0      		ldi r20,lo8(10)
 6751 22da C42E      		mov r12,r20
 6752 22dc D12C      		mov r13,__zero_reg__
 6753 22de E12C      		mov r14,__zero_reg__
 6754 22e0 F12C      		mov r15,__zero_reg__
 6755               	.LVL750:
 6756               	.L356:
 6757 22e2 6B2D      		mov r22,r11
 6758 22e4 7A2D      		mov r23,r10
 6759 22e6 812F      		mov r24,r17
 6760 22e8 902F      		mov r25,r16
 6761 22ea A701      		movw r20,r14
 6762 22ec 9601      		movw r18,r12
 6763 22ee 0E94 0000 		call __udivmodsi4
 6764 22f2 862F      		mov r24,r22
 6765               	.LVL751:
1892:main.c        **** 		myFrequency /= 10;							// Shift right.
 6766               		.loc 3 1892 0
 6767 22f4 B22E      		mov r11,r18
 6768 22f6 A32E      		mov r10,r19
 6769 22f8 142F      		mov r17,r20
 6770 22fa 052F      		mov r16,r21
 6771               	.LVL752:
1885:main.c        **** 		if( i == 2 ){		// put a decimal point in the right spot.
 6772               		.loc 3 1885 0
 6773 22fc 61E0      		ldi r22,lo8(1)
 6774               	.LVL753:
 6775 22fe C230      		cpi r28,2
 6776 2300 D105      		cpc r29,__zero_reg__
 6777 2302 01F0      		breq .L355
 6778 2304 60E0      		ldi r22,0
 6779               	.L355:
1893:main.c        **** 		sendIntegerToNixie( intToSend, myDecimal );	// And print it to the nixie tubes.
 6780               		.loc 3 1893 0
 6781 2306 0E94 0000 		call sendIntegerToNixie
 6782               	.LVL754:
 6783               	.LBE308:
1881:main.c        **** 	for( int i = 0; i < 5; i++ )
 6784               		.loc 3 1881 0
 6785 230a 2196      		adiw r28,1
 6786               	.LVL755:
 6787 230c C530      		cpi r28,5
 6788 230e D105      		cpc r29,__zero_reg__
 6789 2310 01F4      		brne .L356
 6790               	.LVL756:
 6791               	.LBE307:
 6792               	.LBB309:
 6793               	.LBB310:
1605:main.c        **** 			shiftByteOut( 0b00000000 );
 6794               		.loc 3 1605 0
 6795 2312 80E0      		ldi r24,0
 6796               	/* epilogue start */
 6797               	.LBE310:
 6798               	.LBE309:
1894:main.c        **** 	}
1895:main.c        **** 	
1896:main.c        **** 	sendIntegerToNixie( 0, 0 );		//  Send an extra "0" to shift everything "right" one.
1897:main.c        **** 
1898:main.c        **** }
 6799               		.loc 3 1898 0
 6800 2314 DF91      		pop r29
 6801 2316 CF91      		pop r28
 6802               	.LVL757:
 6803 2318 1F91      		pop r17
 6804 231a 0F91      		pop r16
 6805 231c FF90      		pop r15
 6806 231e EF90      		pop r14
 6807 2320 DF90      		pop r13
 6808 2322 CF90      		pop r12
 6809 2324 BF90      		pop r11
 6810 2326 AF90      		pop r10
 6811               	.LBB312:
 6812               	.LBB311:
1605:main.c        **** 			shiftByteOut( 0b00000000 );
 6813               		.loc 3 1605 0
 6814 2328 0C94 0000 		jmp shiftByteOut
 6815               	.LVL758:
 6816               	.LBE311:
 6817               	.LBE312:
 6818               		.cfi_endproc
 6819               	.LFE59:
 6821               		.section	.text.startup,"ax",@progbits
 6822               	.global	main
 6824               	main:
 6825               	.LFB13:
 225:main.c        **** {
 6826               		.loc 3 225 0
 6827               		.cfi_startproc
 6828               	/* prologue: function */
 6829               	/* frame size = 0 */
 6830               	/* stack size = 0 */
 6831               	.L__stack_usage = 0
 226:main.c        ****     cli();
 6832               		.loc 3 226 0
 6833               	/* #APP */
 6834               	 ;  226 "main.c" 1
 6835 0000 F894      		cli
 6836               	 ;  0 "" 2
 227:main.c        ****     ioInit();
 6837               		.loc 3 227 0
 6838               	/* #NOAPP */
 6839 0002 0E94 0000 		call ioInit
 6840               	.LVL759:
 228:main.c        ****     adcInit();
 6841               		.loc 3 228 0
 6842 0006 0E94 0000 		call adcInit
 6843               	.LVL760:
 229:main.c        ****     boostConverterInit();
 6844               		.loc 3 229 0
 6845 000a 0E94 0000 		call boostConverterInit
 6846               	.LVL761:
 230:main.c        ****     rtcInit();
 6847               		.loc 3 230 0
 6848 000e 0E94 0000 		call rtcInit
 6849               	.LVL762:
 231:main.c        ****     uartInit();
 6850               		.loc 3 231 0
 6851 0012 0E94 0000 		call uartInit
 6852               	.LVL763:
 232:main.c        ****     extInterruptInit();
 6853               		.loc 3 232 0
 6854 0016 0E94 0000 		call extInterruptInit
 6855               	.LVL764:
 233:main.c        ****     readEepromToVars();  
 6856               		.loc 3 233 0
 6857 001a 0E94 0000 		call readEepromToVars
 6858               	.LVL765:
 234:main.c        ****     sei();
 6859               		.loc 3 234 0
 6860               	/* #APP */
 6861               	 ;  234 "main.c" 1
 6862 001e 7894      		sei
 6863               	 ;  0 "" 2
 236:main.c        ****     uartWelcome();
 6864               		.loc 3 236 0
 6865               	/* #NOAPP */
 6866 0020 0E94 0000 		call uartWelcome
 6867               	.LVL766:
 6868               	.LBB313:
 6869               	.LBB314:
 6870               	.LBB315:
 6871               	.LBB316:
 6872               		.loc 2 105 0
 6873 0024 C9E9      		ldi r28,lo8(-103)
 6874 0026 D1E0      		ldi r29,lo8(1)
 6875               	.L373:
 6876               	.LBE316:
 6877               	.LBE315:
 6878               	.LBE314:
 6879               	.LBE313:
 242:main.c        ****     	updateAcFrequency();			// Every AC_FRQ_FILT_SEC seconds, compute the average.
 6880               		.loc 3 242 0
 6881 0028 0E94 0000 		call updateAcFrequency
 6882               	.LVL767:
 243:main.c        ****     	updateTemperatureFilter( 20 );	// FIR averaging filter for the DS18b20.
 6883               		.loc 3 243 0
 6884 002c 84E1      		ldi r24,lo8(20)
 6885 002e 0E94 0000 		call updateTemperatureFilter
 6886               	.LVL768:
 244:main.c        ****         updateNixieOutputState();		// Turns ON or OFF the nixie tubes based on input power and slee
 6887               		.loc 3 244 0
 6888 0032 0E94 0000 		call updateNixieOutputState
 6889               	.LVL769:
 245:main.c        ****       	checkSerialIn();				// Is there new serial data available?
 6890               		.loc 3 245 0
 6891 0036 0E94 0000 		call checkSerialIn
 6892               	.LVL770:
 246:main.c        **** 		updateDateTime();				// Keep track of the current date and time.
 6893               		.loc 3 246 0
 6894 003a 0E94 0000 		call updateDateTime
 6895               	.LVL771:
 249:main.c        ****         if( seconds != prevSeconds)
 6896               		.loc 3 249 0
 6897 003e 9091 0000 		lds r25,seconds
 6898 0042 8091 0000 		lds r24,prevSeconds
 6899 0046 9817      		cp r25,r24
 6900 0048 01F0      		breq .L362
 251:main.c        ****             nixiePrintTime( 1 );	// Display the current time on the nixie tubes and toggle the deci
 6901               		.loc 3 251 0
 6902 004a 81E0      		ldi r24,lo8(1)
 6903 004c 0E94 0000 		call nixiePrintTime
 6904               	.LVL772:
 252:main.c        ****             prevSeconds = seconds;
 6905               		.loc 3 252 0
 6906 0050 8091 0000 		lds r24,seconds
 6907 0054 8093 0000 		sts prevSeconds,r24
 6908               	.L362:
 257:main.c        ****         if( minutes != prevMinutes)
 6909               		.loc 3 257 0
 6910 0058 9091 0000 		lds r25,minutes
 6911 005c 8091 0000 		lds r24,prevMinutes
 6912 0060 9817      		cp r25,r24
 6913 0062 01F4      		brne .+2
 6914 0064 00C0      		rjmp .L363
 259:main.c        ****         	cathodePoisonFlag = 1;		// Set every minute.  Cleared in checkCathodePoison(). 
 6915               		.loc 3 259 0
 6916 0066 81E0      		ldi r24,lo8(1)
 6917 0068 8093 0000 		sts cathodePoisonFlag,r24
 261:main.c        ****             serialPrintDateTime();
 6918               		.loc 3 261 0
 6919 006c 0E94 0000 		call serialPrintDateTime
 6920               	.LVL773:
 262:main.c        ****             serialPrintTemperature();
 6921               		.loc 3 262 0
 6922 0070 0E94 0000 		call serialPrintTemperature
 6923               	.LVL774:
 263:main.c        ****             serialPrintAcFrequency();
 6924               		.loc 3 263 0
 6925 0074 0E94 0000 		call serialPrintAcFrequency
 6926               	.LVL775:
 264:main.c        ****             uart_puts(RETURN_NEWLINE);
 6927               		.loc 3 264 0
 6928 0078 80E0      		ldi r24,lo8(.LC3)
 6929 007a 90E0      		ldi r25,hi8(.LC3)
 6930 007c 0E94 0000 		call uart_puts
 6931               	.LVL776:
 268:main.c        ****             if( showdate ){
 6932               		.loc 3 268 0
 6933 0080 8091 0000 		lds r24,showdate
 6934 0084 8111      		cpse r24,__zero_reg__
 6935 0086 00C0      		rjmp .L364
 6936               	.L368:
 274:main.c        ****            	if( showtherm ){
 6937               		.loc 3 274 0
 6938 0088 8091 0000 		lds r24,showtherm
 6939 008c 8823      		tst r24
 6940 008e 01F0      		breq .L366
 6941 0090 00C0      		rjmp .L365
 6942               	.L364:
 269:main.c        ****             	nixiePrintDate();
 6943               		.loc 3 269 0
 6944 0092 0E94 0000 		call nixiePrintDate
 6945               	.LVL777:
 6946 0096 80E5      		ldi r24,lo8(80)
 6947 0098 93EC      		ldi r25,lo8(-61)
 6948               	.LVL778:
 6949               	.L367:
 6950               	.LBB320:
 6951               	.LBB319:
 6952               	.LBB318:
 6953               	.LBB317:
 6954               		.loc 2 105 0
 6955 009a FE01      		movw r30,r28
 6956               	/* #APP */
 6957               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 6958 009c 3197      		1: sbiw r30,1
 6959 009e 01F4      		brne 1b
 6960               	 ;  0 "" 2
 6961               	.LVL779:
 6962               	/* #NOAPP */
 6963 00a0 0197      		sbiw r24,1
 6964               	.LBE317:
 6965               	.LBE318:
 174:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 6966               		.loc 4 174 0
 6967 00a2 01F4      		brne .L367
 6968 00a4 00C0      		rjmp .L368
 6969               	.LVL780:
 6970               	.L366:
 6971               	.LBE319:
 6972               	.LBE320:
 280:main.c        ****            	if( showfreq ){
 6973               		.loc 3 280 0
 6974 00a6 8091 0000 		lds r24,showfreq
 6975 00aa 8823      		tst r24
 6976 00ac 01F0      		breq .L370
 6977 00ae 00C0      		rjmp .L369
 6978               	.L365:
 275:main.c        ****            		nixiePrintTemperature();
 6979               		.loc 3 275 0
 6980 00b0 0E94 0000 		call nixiePrintTemperature
 6981               	.LVL781:
 6982 00b4 80E5      		ldi r24,lo8(80)
 6983 00b6 93EC      		ldi r25,lo8(-61)
 6984               	.LVL782:
 6985               	.L371:
 6986               	.LBB321:
 6987               	.LBB322:
 6988               	.LBB323:
 6989               	.LBB324:
 6990               		.loc 2 105 0
 6991 00b8 FE01      		movw r30,r28
 6992               	/* #APP */
 6993               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 6994 00ba 3197      		1: sbiw r30,1
 6995 00bc 01F4      		brne 1b
 6996               	 ;  0 "" 2
 6997               	.LVL783:
 6998               	/* #NOAPP */
 6999 00be 0197      		sbiw r24,1
 7000               	.LBE324:
 7001               	.LBE323:
 174:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 7002               		.loc 4 174 0
 7003 00c0 01F4      		brne .L371
 7004 00c2 00C0      		rjmp .L366
 7005               	.LVL784:
 7006               	.L370:
 7007               	.LBE322:
 7008               	.LBE321:
 285:main.c        ****             prevMinutes = minutes;   
 7009               		.loc 3 285 0
 7010 00c4 8091 0000 		lds r24,minutes
 7011 00c8 8093 0000 		sts prevMinutes,r24
 7012 00cc 00C0      		rjmp .L363
 7013               	.L369:
 281:main.c        ****            		nixiePrintAcFrequency();
 7014               		.loc 3 281 0
 7015 00ce 0E94 0000 		call nixiePrintAcFrequency
 7016               	.LVL785:
 7017 00d2 80E5      		ldi r24,lo8(80)
 7018 00d4 93EC      		ldi r25,lo8(-61)
 7019               	.LVL786:
 7020               	.L372:
 7021               	.LBB325:
 7022               	.LBB326:
 7023               	.LBB327:
 7024               	.LBB328:
 7025               		.loc 2 105 0
 7026 00d6 FE01      		movw r30,r28
 7027               	/* #APP */
 7028               	 ;  105 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay_basic.h" 1
 7029 00d8 3197      		1: sbiw r30,1
 7030 00da 01F4      		brne 1b
 7031               	 ;  0 "" 2
 7032               	.LVL787:
 7033               	/* #NOAPP */
 7034 00dc 0197      		sbiw r24,1
 7035               	.LBE328:
 7036               	.LBE327:
 174:/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 7037               		.loc 4 174 0
 7038 00de 01F4      		brne .L372
 7039 00e0 00C0      		rjmp .L370
 7040               	.LVL788:
 7041               	.L363:
 7042               	.LBE326:
 7043               	.LBE325:
 288:main.c        ****         checkCathodePoison();			// do the antipoison routine if ready.
 7044               		.loc 3 288 0
 7045 00e2 0E94 0000 		call checkCathodePoison
 7046               	.LVL789:
 290:main.c        ****     }
 7047               		.loc 3 290 0
 7048 00e6 00C0      		rjmp .L373
 7049               		.cfi_endproc
 7050               	.LFE13:
 7052               	.global	cathodePoisonFlag
 7053               		.section .bss
 7056               	cathodePoisonFlag:
 7057 0000 00        		.zero	1
 7058               	.global	acFreqFlag
 7061               	acFreqFlag:
 7062 0001 00        		.zero	1
 7063               	.global	acFrequency
 7066               	acFrequency:
 7067 0002 0000 0000 		.zero	4
 7068               	.global	acZeroCrossSnapshot
 7071               	acZeroCrossSnapshot:
 7072 0006 0000      		.zero	2
 7073               	.global	acZeroCrossCounter
 7076               	acZeroCrossCounter:
 7077 0008 0000      		.zero	2
 7078               		.comm	adc_raw,4,1
 7079               	.global	boostLowPwm
 7080               		.data
 7083               	boostLowPwm:
 7084 0000 1E        		.byte	30
 7085               	.global	boostHighPwm
 7088               	boostHighPwm:
 7089 0001 50        		.byte	80
 7090               	.global	boostConverterPwm
 7091               		.section .bss
 7094               	boostConverterPwm:
 7095 000a 00        		.zero	1
 7096               		.comm	movingAverageArray,24,1
 7097               	.global	arraySum
 7100               	arraySum:
 7101 000b 0000 0000 		.zero	4
 7102               	.global	averageCelsiusTemperature
 7103               		.data
 7106               	averageCelsiusTemperature:
 7107 0002 00        		.byte	0
 7108 0003 00        		.byte	0
 7109 0004 C6        		.byte	-58
 7110 0005 42        		.byte	66
 7111               	.global	celsiusTemperature
 7114               	celsiusTemperature:
 7115 0006 00        		.byte	0
 7116 0007 00        		.byte	0
 7117 0008 C6        		.byte	-58
 7118 0009 42        		.byte	66
 7119               	.global	ee_nixiesleepend
 7120               		.section	.eeprom,"aw",@progbits
 7123               	ee_nixiesleepend:
 7124 0000 0000 0000 		.zero	4
 7125               	.global	nixiesleepend
 7126               		.section .bss
 7129               	nixiesleepend:
 7130 000f 0000 0000 		.zero	4
 7131               	.global	ee_nixiesleepstart
 7132               		.section	.eeprom
 7135               	ee_nixiesleepstart:
 7136 0004 0000 0000 		.zero	4
 7137               	.global	nixiesleepstart
 7138               		.section .bss
 7141               	nixiesleepstart:
 7142 0013 0000 0000 		.zero	4
 7143               	.global	ee_toggleled
 7144               		.section	.eeprom
 7147               	ee_toggleled:
 7148 0008 01        		.byte	1
 7149               	.global	toggleled
 7150               		.data
 7153               	toggleled:
 7154 000a 01        		.byte	1
 7155               	.global	ee_xtalisfast
 7156               		.section	.eeprom
 7159               	ee_xtalisfast:
 7160 0009 01        		.byte	1
 7161               	.global	xtalisfast
 7162               		.data
 7165               	xtalisfast:
 7166 000b 01        		.byte	1
 7167               	.global	ee_acclock
 7168               		.section	.eeprom
 7171               	ee_acclock:
 7172 000a 01        		.byte	1
 7173               	.global	acclock
 7174               		.data
 7177               	acclock:
 7178 000c 01        		.byte	1
 7179               	.global	ee_doecho
 7180               		.section	.eeprom
 7183               	ee_doecho:
 7184 000b 01        		.byte	1
 7185               	.global	doecho
 7186               		.data
 7189               	doecho:
 7190 000d 01        		.byte	1
 7191               	.global	ee_celsius
 7192               		.section	.eeprom
 7195               	ee_celsius:
 7196 000c 01        		.byte	1
 7197               	.global	celsius
 7198               		.data
 7201               	celsius:
 7202 000e 01        		.byte	1
 7203               	.global	ee_showdate
 7204               		.section	.eeprom
 7207               	ee_showdate:
 7208 000d 00        		.zero	1
 7209               	.global	showdate
 7210               		.section .bss
 7213               	showdate:
 7214 0017 00        		.zero	1
 7215               	.global	ee_showfreq
 7216               		.section	.eeprom
 7219               	ee_showfreq:
 7220 000e 00        		.zero	1
 7221               	.global	showfreq
 7222               		.section .bss
 7225               	showfreq:
 7226 0018 00        		.zero	1
 7227               	.global	ee_showtherm
 7228               		.section	.eeprom
 7231               	ee_showtherm:
 7232 000f 00        		.zero	1
 7233               	.global	showtherm
 7234               		.section .bss
 7237               	showtherm:
 7238 0019 00        		.zero	1
 7239               	.global	ee_miltime
 7240               		.section	.eeprom
 7243               	ee_miltime:
 7244 0010 01        		.byte	1
 7245               	.global	miltime
 7246               		.data
 7249               	miltime:
 7250 000f 01        		.byte	1
 7251               	.global	prevMinutes
 7252               		.section .bss
 7255               	prevMinutes:
 7256 001a 00        		.zero	1
 7257               	.global	prevSeconds
 7260               	prevSeconds:
 7261 001b 00        		.zero	1
 7262               	.global	ee_mscal
 7263               		.section	.eeprom
 7266               	ee_mscal:
 7267 0011 0000 0000 		.zero	4
 7268               	.global	mscal
 7269               		.section .bss
 7272               	mscal:
 7273 001c 0000 0000 		.zero	4
 7274               	.global	seconds
 7275               		.data
 7278               	seconds:
 7279 0010 1E        		.byte	30
 7280               	.global	year
 7283               	year:
 7284 0011 DF07      		.word	2015
 7285               	.global	month
 7288               	month:
 7289 0013 02        		.byte	2
 7290               	.global	day
 7293               	day:
 7294 0014 01        		.byte	1
 7295               	.global	minutes
 7298               	minutes:
 7299 0015 0A        		.byte	10
 7300               	.global	hours
 7303               	hours:
 7304 0016 0A        		.byte	10
 7305               	.global	serialInInteger
 7306               		.section .bss
 7309               	serialInInteger:
 7310 0020 0000      		.zero	2
 7311               		.comm	printBuffer,100,1
 7312               		.comm	myUartString,100,1
 7313               		.comm	uartString,100,1
 7314               	.global	uartStringIndex
 7317               	uartStringIndex:
 7318 0022 00        		.zero	1
 7319               	.global	SERIAL_NUMBER
 7320               		.section	.rodata
 7323               	SERIAL_NUMBER:
 7324 000d 6400      		.word	100
 7325               		.local	input_index.2181
 7326               		.comm	input_index.2181,1,1
 7327               		.local	timebaseCounter.2187
 7328               		.comm	timebaseCounter.2187,1,1
 7329               		.section	.progmem.data,"a",@progbits
 7332               	__c.2230:
 7333 0000 5541 5254 		.string	"UART Frame Error: "
 7333      2046 7261 
 7333      6D65 2045 
 7333      7272 6F72 
 7333      3A20 00
 7336               	__c.2232:
 7337 0013 5541 5254 		.string	"UART Overrun Error: "
 7337      204F 7665 
 7337      7272 756E 
 7337      2045 7272 
 7337      6F72 3A20 
 7340               	__c.2234:
 7341 0028 4275 6666 		.string	"Buffer overflow error: "
 7341      6572 206F 
 7341      7665 7266 
 7341      6C6F 7720 
 7341      6572 726F 
 7342               		.local	milliSeconds.2247
 7343               		.comm	milliSeconds.2247,2,1
 7344               		.local	clockCalCounter.2248
 7345               		.comm	clockCalCounter.2248,4,1
 7346               		.local	acFreqFiltCtr.2250
 7347               		.comm	acFreqFiltCtr.2250,2,1
 7348               		.text
 7349               	.Letext0:
 7350               		.file 5 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/stdint.h"
 7351               		.file 6 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/string.h"
 7352               		.file 7 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/stdlib.h"
 7353               		.file 8 "uart.h"
 7354               		.file 9 "/opt/local/lib/gcc/avr/4.7.2/../../../../avr/include/avr/eeprom.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:4      *ABS*:000000000000003f __SREG__
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:12     .text:0000000000000000 ds18b20_reset
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:108    .text:0000000000000024 ds18b20_writebit
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:176    .text:000000000000003e ds18b20_readbit
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:258    .text:0000000000000060 ds18b20_writebyte
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:305    .text:000000000000007e ds18b20_readbyte
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:363    .text:00000000000000a4 ds18b20_gettemp
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:513    .text:0000000000000154 ioInit
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:548    .text:0000000000000170 extInterruptInit
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:567    .text:000000000000017c rtcInit
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:598    .text:000000000000019c adcInit
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:624    .text:00000000000001b4 boostConverterInit
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:646    .text:00000000000001c2 __vector_21
                             .bss:0000000000000023 input_index.2181
                            *COM*:0000000000000004 adc_raw
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:723    .text:000000000000021c __vector_3
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7326   .bss:0000000000000024 timebaseCounter.2187
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7177   .data:000000000000000c acclock
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7278   .data:0000000000000010 seconds
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7076   .bss:0000000000000008 acZeroCrossCounter
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:788    .text:000000000000026e toggle_led
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:806    .text:0000000000000276 blip_led
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:843    .text:0000000000000284 is_switch_pressed
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:877    .text:000000000000029e splitString
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:943    .text:00000000000002e6 copy_command
                            *COM*:0000000000000064 uartString
                            *COM*:0000000000000064 myUartString
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:977    .text:0000000000000308 inRange
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:1037   .text:0000000000000334 print_value
                            *COM*:0000000000000064 printBuffer
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:1090   .text:0000000000000364 print_csv
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:1144   .text:000000000000038c uart_ok
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:1185   .text:000000000000039c uartWelcome
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:1288   .text:000000000000042c uartInit
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:1310   .text:0000000000000434 serialPrintDateTime
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7283   .data:0000000000000011 year
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7288   .data:0000000000000013 month
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7293   .data:0000000000000014 day
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7249   .data:000000000000000f miltime
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7303   .data:0000000000000016 hours
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7298   .data:0000000000000015 minutes
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:1444   .text:0000000000000510 isLeapYear
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:1507   .text:000000000000054a updateDateTime
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:1646   .text:000000000000061e dayOfWeek
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:1725   .text:0000000000000684 readTemperature
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7114   .data:0000000000000006 celsiusTemperature
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:1754   .text:00000000000006a8 updateBoostConverter
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7083   .data:0000000000000000 boostLowPwm
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7088   .data:0000000000000001 boostHighPwm
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7094   .bss:000000000000000a boostConverterPwm
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:1789   .text:00000000000006c6 updateTemperatureFilter
                            *COM*:0000000000000018 movingAverageArray
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7100   .bss:000000000000000b arraySum
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7106   .data:0000000000000002 averageCelsiusTemperature
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:1927   .text:000000000000078e serialPrintTemperature
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7201   .data:000000000000000e celsius
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:2000   .text:00000000000007f0 serialPrintAcFrequency
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7066   .bss:0000000000000002 acFrequency
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:2045   .text:0000000000000820 readEepromToVars
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7266   .eeprom:0000000000000011 ee_mscal
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7272   .bss:000000000000001c mscal
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7135   .eeprom:0000000000000004 ee_nixiesleepstart
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7141   .bss:0000000000000013 nixiesleepstart
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7123   .eeprom:0000000000000000 ee_nixiesleepend
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7129   .bss:000000000000000f nixiesleepend
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7243   .eeprom:0000000000000010 ee_miltime
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7231   .eeprom:000000000000000f ee_showtherm
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7237   .bss:0000000000000019 showtherm
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7219   .eeprom:000000000000000e ee_showfreq
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7225   .bss:0000000000000018 showfreq
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7207   .eeprom:000000000000000d ee_showdate
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7213   .bss:0000000000000017 showdate
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7195   .eeprom:000000000000000c ee_celsius
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7183   .eeprom:000000000000000b ee_doecho
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7189   .data:000000000000000d doecho
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7171   .eeprom:000000000000000a ee_acclock
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7159   .eeprom:0000000000000009 ee_xtalisfast
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7165   .data:000000000000000b xtalisfast
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7147   .eeprom:0000000000000008 ee_toggleled
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7153   .data:000000000000000a toggleled
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:2140   .text:00000000000008d6 updateVarsToEeprom
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:2376   .text:000000000000098a process_command
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:4793   .text:00000000000019da checkSerialIn
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7332   .progmem.data:0000000000000000 __c.2230
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7336   .progmem.data:0000000000000013 __c.2232
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7340   .progmem.data:0000000000000028 __c.2234
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7317   .bss:0000000000000022 uartStringIndex
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:4901   .text:0000000000001a54 acPowerOk
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:4923   .text:0000000000001a62 __vector_11
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7328   .bss:0000000000000025 milliSeconds.2247
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7343   .bss:0000000000000027 clockCalCounter.2248
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7345   .bss:000000000000002b acFreqFiltCtr.2250
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7071   .bss:0000000000000006 acZeroCrossSnapshot
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7061   .bss:0000000000000001 acFreqFlag
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:5169   .text:0000000000001c0a turnOnOffBoostConverter
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:5206   .text:0000000000001c20 updateNixieOutputState
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:5317   .text:0000000000001cb2 updateAcFrequency
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:5380   .text:0000000000001d2c shiftRegisterPulse
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:5398   .text:0000000000001d32 shiftRegisterSetOutput
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:5416   .text:0000000000001d38 shiftByteOut
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:5491   .text:0000000000001d76 sendIntegerToNixie
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:5690   .text:0000000000001e26 antiCathodePoisonPattern
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:6144   .text:0000000000001ffe checkCathodePoison
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7056   .bss:0000000000000000 cathodePoisonFlag
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:6240   .text:0000000000002080 nixiePrintTemperature
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:6445   .text:0000000000002192 nixiePrintTime
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:6578   .text:0000000000002226 nixiePrintDate
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:6678   .text:0000000000002298 nixiePrintAcFrequency
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:6824   .text.startup:0000000000000000 main
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7260   .bss:000000000000001b prevSeconds
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7255   .bss:000000000000001a prevMinutes
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7309   .bss:0000000000000020 serialInInteger
/var/folders/gw/xxv8r3sd1k1bh9__g9pnzs_80000gn/T//ccng3sn1.s:7323   .rodata:000000000000000d SERIAL_NUMBER

UNDEFINED SYMBOLS
__floatsisf
__floatunsisf
__mulsf3
__addsf3
strchr
strcpy
atol
ultoa
uart_puts
uart_init
itoa
uart_putc
__udivmodhi4
__divmodhi4
__divsf3
__udivmodqi4
dtostrf
__eerd_dword_m328p
__eerd_byte_m328p
__eeupd_dword_m328p
__eeupd_byte_m328p
strcasestr
strstr
uart_getc
uart_puts_p
__ltsf2
__gtsf2
__fixunssfsi
__gesf2
__subsf3
__udivmodsi4
__do_copy_data
__do_clear_bss
